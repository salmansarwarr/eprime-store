{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.prepareDocs = exports.indexInformation = void 0;\nvar error_1 = require(\"../error\");\nvar utils_1 = require(\"../utils\");\nfunction indexInformation(db, name, _optionsOrCallback, _callback) {\n  var options = _optionsOrCallback;\n  var callback = _callback;\n  if ('function' === typeof _optionsOrCallback) {\n    callback = _optionsOrCallback;\n    options = {};\n  }\n  // If we specified full information\n  var full = options.full == null ? false : options.full;\n  var topology;\n  try {\n    topology = (0, utils_1.getTopology)(db);\n  } catch (error) {\n    return callback(error);\n  }\n  // Did the user destroy the topology\n  if (topology.isDestroyed()) return callback(new error_1.MongoTopologyClosedError());\n  // Process all the results from the index command and collection\n  function processResults(indexes) {\n    // Contains all the information\n    var info = {};\n    // Process all the indexes\n    for (var i = 0; i < indexes.length; i++) {\n      var index = indexes[i];\n      // Let's unpack the object\n      info[index.name] = [];\n      for (var _name in index.key) {\n        info[index.name].push([_name, index.key[_name]]);\n      }\n    }\n    return info;\n  }\n  // Get the list of indexes of the specified collection\n  db.collection(name).listIndexes(options).toArray().then(function (indexes) {\n    if (!Array.isArray(indexes)) return callback(undefined, []);\n    if (full) return callback(undefined, indexes);\n    callback(undefined, processResults(indexes));\n  }, function (error) {\n    return callback(error);\n  });\n}\nexports.indexInformation = indexInformation;\nfunction prepareDocs(coll, docs, options) {\n  var _coll$s$db$options;\n  var forceServerObjectId = typeof options.forceServerObjectId === 'boolean' ? options.forceServerObjectId : (_coll$s$db$options = coll.s.db.options) === null || _coll$s$db$options === void 0 ? void 0 : _coll$s$db$options.forceServerObjectId;\n  // no need to modify the docs if server sets the ObjectId\n  if (forceServerObjectId === true) {\n    return docs;\n  }\n  return docs.map(function (doc) {\n    if (doc._id == null) {\n      doc._id = coll.s.pkFactory.createPk();\n    }\n    return doc;\n  });\n}\nexports.prepareDocs = prepareDocs;","map":{"version":3,"names":["error_1","require","utils_1","indexInformation","db","name","_optionsOrCallback","_callback","options","callback","full","topology","getTopology","error","isDestroyed","MongoTopologyClosedError","processResults","indexes","info","i","length","index","key","push","collection","listIndexes","toArray","then","Array","isArray","undefined","exports","prepareDocs","coll","docs","_coll$s$db$options","forceServerObjectId","s","map","doc","_id","pkFactory","createPk"],"sources":["/home/salman/Documents/GitHub/FakeShop/node_modules/mongodb/src/operations/common_functions.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Collection } from '../collection';\nimport type { Db } from '../db';\nimport { MongoTopologyClosedError } from '../error';\nimport type { ReadPreference } from '../read_preference';\nimport type { ClientSession } from '../sessions';\nimport { type Callback, getTopology } from '../utils';\n\n/** @public */\nexport interface IndexInformationOptions {\n  full?: boolean;\n  readPreference?: ReadPreference;\n  session?: ClientSession;\n}\n/**\n * Retrieves this collections index info.\n *\n * @param db - The Db instance on which to retrieve the index info.\n * @param name - The name of the collection.\n */\nexport function indexInformation(db: Db, name: string, callback: Callback): void;\nexport function indexInformation(\n  db: Db,\n  name: string,\n  options: IndexInformationOptions,\n  callback?: Callback\n): void;\nexport function indexInformation(\n  db: Db,\n  name: string,\n  _optionsOrCallback: IndexInformationOptions | Callback,\n  _callback?: Callback\n): void {\n  let options = _optionsOrCallback as IndexInformationOptions;\n  let callback = _callback as Callback;\n  if ('function' === typeof _optionsOrCallback) {\n    callback = _optionsOrCallback;\n    options = {};\n  }\n  // If we specified full information\n  const full = options.full == null ? false : options.full;\n\n  let topology;\n  try {\n    topology = getTopology(db);\n  } catch (error) {\n    return callback(error);\n  }\n\n  // Did the user destroy the topology\n  if (topology.isDestroyed()) return callback(new MongoTopologyClosedError());\n  // Process all the results from the index command and collection\n  function processResults(indexes: any) {\n    // Contains all the information\n    const info: any = {};\n    // Process all the indexes\n    for (let i = 0; i < indexes.length; i++) {\n      const index = indexes[i];\n      // Let's unpack the object\n      info[index.name] = [];\n      for (const name in index.key) {\n        info[index.name].push([name, index.key[name]]);\n      }\n    }\n\n    return info;\n  }\n\n  // Get the list of indexes of the specified collection\n  db.collection(name)\n    .listIndexes(options)\n    .toArray()\n    .then(\n      indexes => {\n        if (!Array.isArray(indexes)) return callback(undefined, []);\n        if (full) return callback(undefined, indexes);\n        callback(undefined, processResults(indexes));\n      },\n      error => callback(error)\n    );\n}\n\nexport function prepareDocs(\n  coll: Collection,\n  docs: Document[],\n  options: { forceServerObjectId?: boolean }\n): Document[] {\n  const forceServerObjectId =\n    typeof options.forceServerObjectId === 'boolean'\n      ? options.forceServerObjectId\n      : coll.s.db.options?.forceServerObjectId;\n\n  // no need to modify the docs if server sets the ObjectId\n  if (forceServerObjectId === true) {\n    return docs;\n  }\n\n  return docs.map(doc => {\n    if (doc._id == null) {\n      doc._id = coll.s.pkFactory.createPk();\n    }\n\n    return doc;\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}