{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TopologyDescription = void 0;\nvar WIRE_CONSTANTS = require(\"../cmap/wire_protocol/constants\");\nvar error_1 = require(\"../error\");\nvar utils_1 = require(\"../utils\");\nvar common_1 = require(\"./common\");\nvar server_description_1 = require(\"./server_description\");\n// constants related to compatibility checks\nvar MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nvar MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nvar MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nvar MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nvar MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);\nvar MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);\nvar NON_PRIMARY_RS_MEMBERS = new Set([common_1.ServerType.RSSecondary, common_1.ServerType.RSArbiter, common_1.ServerType.RSOther]);\n/**\n * Representation of a deployment of servers\n * @public\n */\nvar TopologyDescription = /*#__PURE__*/function () {\n  /**\n   * Create a TopologyDescription\n   */\n  function TopologyDescription(topologyType) {\n    var _options, _options$heartbeatFre, _options$localThresho;\n    var serverDescriptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var setName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var maxSetVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var maxElectionId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var commonWireVersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    var options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n    _classCallCheck(this, TopologyDescription);\n    options = (_options = options) !== null && _options !== void 0 ? _options : {};\n    this.type = topologyType !== null && topologyType !== void 0 ? topologyType : common_1.TopologyType.Unknown;\n    this.servers = serverDescriptions !== null && serverDescriptions !== void 0 ? serverDescriptions : new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.heartbeatFrequencyMS = (_options$heartbeatFre = options.heartbeatFrequencyMS) !== null && _options$heartbeatFre !== void 0 ? _options$heartbeatFre : 0;\n    this.localThresholdMS = (_options$localThresho = options.localThresholdMS) !== null && _options$localThresho !== void 0 ? _options$localThresho : 15;\n    this.setName = setName !== null && setName !== void 0 ? setName : null;\n    this.maxElectionId = maxElectionId !== null && maxElectionId !== void 0 ? maxElectionId : null;\n    this.maxSetVersion = maxSetVersion !== null && maxSetVersion !== void 0 ? maxSetVersion : null;\n    this.commonWireVersion = commonWireVersion !== null && commonWireVersion !== void 0 ? commonWireVersion : 0;\n    // determine server compatibility\n    var _iterator = _createForOfIteratorHelper(this.servers.values()),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var serverDescription = _step.value;\n        // Load balancer mode is always compatible.\n        if (serverDescription.type === common_1.ServerType.Unknown || serverDescription.type === common_1.ServerType.LoadBalancer) {\n          continue;\n        }\n        if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n          this.compatible = false;\n          this.compatibilityError = \"Server at \".concat(serverDescription.address, \" requires wire version \").concat(serverDescription.minWireVersion, \", but this version of the driver only supports up to \").concat(MAX_SUPPORTED_WIRE_VERSION, \" (MongoDB \").concat(MAX_SUPPORTED_SERVER_VERSION, \")\");\n        }\n        if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n          this.compatible = false;\n          this.compatibilityError = \"Server at \".concat(serverDescription.address, \" reports wire version \").concat(serverDescription.maxWireVersion, \", but this version of the driver requires at least \").concat(MIN_SUPPORTED_WIRE_VERSION, \" (MongoDB \").concat(MIN_SUPPORTED_SERVER_VERSION, \").\");\n          break;\n        }\n      }\n      // Whenever a client updates the TopologyDescription from a hello response, it MUST set\n      // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n      // value among ServerDescriptions of all data-bearing server types. If any have a null\n      // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n      // set to null.\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    this.logicalSessionTimeoutMinutes = null;\n    var _iterator2 = _createForOfIteratorHelper(this.servers),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n          server = _step2$value[1];\n        if (server.isReadable) {\n          if (server.logicalSessionTimeoutMinutes == null) {\n            // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n            this.logicalSessionTimeoutMinutes = null;\n            break;\n          }\n          if (this.logicalSessionTimeoutMinutes == null) {\n            // First server with a non null logicalSessionsTimeout\n            this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n            continue;\n          }\n          // Always select the smaller of the:\n          // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n          this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @internal\n   */\n  _createClass(TopologyDescription, [{\n    key: \"updateFromSrvPollingEvent\",\n    value: function updateFromSrvPollingEvent(ev) {\n      var srvMaxHosts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      /** The SRV addresses defines the set of addresses we should be using */\n      var incomingHostnames = ev.hostnames();\n      var currentHostnames = new Set(this.servers.keys());\n      var hostnamesToAdd = new Set(incomingHostnames);\n      var hostnamesToRemove = new Set();\n      var _iterator3 = _createForOfIteratorHelper(currentHostnames),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var hostname = _step3.value;\n          // filter hostnamesToAdd (made from incomingHostnames) down to what is *not* present in currentHostnames\n          hostnamesToAdd.delete(hostname);\n          if (!incomingHostnames.has(hostname)) {\n            // If the SRV Records no longer include this hostname\n            // we have to stop using it\n            hostnamesToRemove.add(hostname);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {\n        // No new hosts to add and none to remove\n        return this;\n      }\n      var serverDescriptions = new Map(this.servers);\n      var _iterator4 = _createForOfIteratorHelper(hostnamesToRemove),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var removedHost = _step4.value;\n          serverDescriptions.delete(removedHost);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      if (hostnamesToAdd.size > 0) {\n        if (srvMaxHosts === 0) {\n          // Add all!\n          var _iterator5 = _createForOfIteratorHelper(hostnamesToAdd),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var hostToAdd = _step5.value;\n              serverDescriptions.set(hostToAdd, new server_description_1.ServerDescription(hostToAdd));\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        } else if (serverDescriptions.size < srvMaxHosts) {\n          // Add only the amount needed to get us back to srvMaxHosts\n          var selectedHosts = (0, utils_1.shuffle)(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);\n          var _iterator6 = _createForOfIteratorHelper(selectedHosts),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var selectedHostToAdd = _step6.value;\n              serverDescriptions.set(selectedHostToAdd, new server_description_1.ServerDescription(selectedHostToAdd));\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      }\n      return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, {\n        heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n        localThresholdMS: this.localThresholdMS\n      });\n    }\n    /**\n     * Returns a copy of this description updated with a given ServerDescription\n     * @internal\n     */\n  }, {\n    key: \"update\",\n    value: function update(serverDescription) {\n      var address = serverDescription.address;\n      // potentially mutated values\n      var topologyType = this.type,\n        setName = this.setName,\n        maxSetVersion = this.maxSetVersion,\n        maxElectionId = this.maxElectionId,\n        commonWireVersion = this.commonWireVersion;\n      var serverType = serverDescription.type;\n      var serverDescriptions = new Map(this.servers);\n      // update common wire version\n      if (serverDescription.maxWireVersion !== 0) {\n        if (commonWireVersion == null) {\n          commonWireVersion = serverDescription.maxWireVersion;\n        } else {\n          commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n        }\n      }\n      if (typeof serverDescription.setName === 'string' && typeof setName === 'string' && serverDescription.setName !== setName) {\n        if (topologyType === common_1.TopologyType.Single) {\n          // \"Single\" Topology with setName mismatch is direct connection usage, mark unknown do not remove\n          serverDescription = new server_description_1.ServerDescription(address);\n        } else {\n          serverDescriptions.delete(address);\n        }\n      }\n      // update the actual server description\n      serverDescriptions.set(address, serverDescription);\n      if (topologyType === common_1.TopologyType.Single) {\n        // once we are defined as single, that never changes\n        return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {\n          heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n          localThresholdMS: this.localThresholdMS\n        });\n      }\n      if (topologyType === common_1.TopologyType.Unknown) {\n        if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {\n          serverDescriptions.delete(address);\n        } else {\n          topologyType = topologyTypeForServerType(serverType);\n        }\n      }\n      if (topologyType === common_1.TopologyType.Sharded) {\n        if (!MONGOS_OR_UNKNOWN.has(serverType)) {\n          serverDescriptions.delete(address);\n        }\n      }\n      if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {\n        if (MONGOS_OR_STANDALONE.has(serverType)) {\n          serverDescriptions.delete(address);\n        }\n        if (serverType === common_1.ServerType.RSPrimary) {\n          var result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n          topologyType = result[0];\n          setName = result[1];\n          maxSetVersion = result[2];\n          maxElectionId = result[3];\n        } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n          var _result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);\n          topologyType = _result[0];\n          setName = _result[1];\n        }\n      }\n      if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {\n        if (MONGOS_OR_STANDALONE.has(serverType)) {\n          serverDescriptions.delete(address);\n          topologyType = checkHasPrimary(serverDescriptions);\n        } else if (serverType === common_1.ServerType.RSPrimary) {\n          var _result2 = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n          topologyType = _result2[0];\n          setName = _result2[1];\n          maxSetVersion = _result2[2];\n          maxElectionId = _result2[3];\n        } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n          topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);\n        } else {\n          topologyType = checkHasPrimary(serverDescriptions);\n        }\n      }\n      return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {\n        heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n        localThresholdMS: this.localThresholdMS\n      });\n    }\n  }, {\n    key: \"error\",\n    get: function get() {\n      var descriptionsWithError = Array.from(this.servers.values()).filter(function (sd) {\n        return sd.error;\n      });\n      if (descriptionsWithError.length > 0) {\n        return descriptionsWithError[0].error;\n      }\n      return null;\n    }\n    /**\n     * Determines if the topology description has any known servers\n     */\n  }, {\n    key: \"hasKnownServers\",\n    get: function get() {\n      return Array.from(this.servers.values()).some(function (sd) {\n        return sd.type !== common_1.ServerType.Unknown;\n      });\n    }\n    /**\n     * Determines if this topology description has a data-bearing server available.\n     */\n  }, {\n    key: \"hasDataBearingServers\",\n    get: function get() {\n      return Array.from(this.servers.values()).some(function (sd) {\n        return sd.isDataBearing;\n      });\n    }\n    /**\n     * Determines if the topology has a definition for the provided address\n     * @internal\n     */\n  }, {\n    key: \"hasServer\",\n    value: function hasServer(address) {\n      return this.servers.has(address);\n    }\n  }]);\n  return TopologyDescription;\n}();\nexports.TopologyDescription = TopologyDescription;\nfunction topologyTypeForServerType(serverType) {\n  switch (serverType) {\n    case common_1.ServerType.Standalone:\n      return common_1.TopologyType.Single;\n    case common_1.ServerType.Mongos:\n      return common_1.TopologyType.Sharded;\n    case common_1.ServerType.RSPrimary:\n      return common_1.TopologyType.ReplicaSetWithPrimary;\n    case common_1.ServerType.RSOther:\n    case common_1.ServerType.RSSecondary:\n      return common_1.TopologyType.ReplicaSetNoPrimary;\n    default:\n      return common_1.TopologyType.Unknown;\n  }\n}\nfunction updateRsFromPrimary(serverDescriptions, serverDescription) {\n  var setName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var maxSetVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var maxElectionId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n  if (serverDescription.maxWireVersion >= 17) {\n    var _maxSetVersion, _serverDescription$se;\n    var electionIdComparison = (0, utils_1.compareObjectId)(maxElectionId, serverDescription.electionId);\n    var maxElectionIdIsEqual = electionIdComparison === 0;\n    var maxElectionIdIsLess = electionIdComparison === -1;\n    var maxSetVersionIsLessOrEqual = ((_maxSetVersion = maxSetVersion) !== null && _maxSetVersion !== void 0 ? _maxSetVersion : -1) <= ((_serverDescription$se = serverDescription.setVersion) !== null && _serverDescription$se !== void 0 ? _serverDescription$se : -1);\n    if (maxElectionIdIsLess || maxElectionIdIsEqual && maxSetVersionIsLessOrEqual) {\n      // The reported electionId was greater\n      // or the electionId was equal and reported setVersion was greater\n      // Always update both values, they are a tuple\n      maxElectionId = serverDescription.electionId;\n      maxSetVersion = serverDescription.setVersion;\n    } else {\n      // Stale primary\n      // replace serverDescription with a default ServerDescription of type \"Unknown\"\n      serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));\n      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n    }\n  } else {\n    var electionId = serverDescription.electionId ? serverDescription.electionId : null;\n    if (serverDescription.setVersion && electionId) {\n      if (maxSetVersion && maxElectionId) {\n        if (maxSetVersion > serverDescription.setVersion || (0, utils_1.compareObjectId)(maxElectionId, electionId) > 0) {\n          // this primary is stale, we must remove it\n          serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));\n          return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n        }\n      }\n      maxElectionId = serverDescription.electionId;\n    }\n    if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {\n      maxSetVersion = serverDescription.setVersion;\n    }\n  }\n  // We've heard from the primary. Is it the same primary as before?\n  var _iterator7 = _createForOfIteratorHelper(serverDescriptions),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var _step7$value = _slicedToArray(_step7.value, 2),\n        address = _step7$value[0],\n        server = _step7$value[1];\n      if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {\n        // Reset old primary's type to Unknown.\n        serverDescriptions.set(address, new server_description_1.ServerDescription(server.address));\n        // There can only be one primary\n        break;\n      }\n    }\n    // Discover new hosts from this primary's response.\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  serverDescription.allHosts.forEach(function (address) {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n    }\n  });\n  // Remove hosts not in the response.\n  var currentAddresses = Array.from(serverDescriptions.keys());\n  var responseAddresses = serverDescription.allHosts;\n  currentAddresses.filter(function (addr) {\n    return responseAddresses.indexOf(addr) === -1;\n  }).forEach(function (address) {\n    serverDescriptions.delete(address);\n  });\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\nfunction updateRsWithPrimaryFromMember(serverDescriptions, serverDescription) {\n  var setName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (setName == null) {\n    // TODO(NODE-3483): should be an appropriate runtime error\n    throw new error_1.MongoRuntimeError('Argument \"setName\" is required if connected to a replica set');\n  }\n  if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n  return checkHasPrimary(serverDescriptions);\n}\nfunction updateRsNoPrimaryFromMember(serverDescriptions, serverDescription) {\n  var _setName;\n  var setName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var topologyType = common_1.TopologyType.ReplicaSetNoPrimary;\n  setName = (_setName = setName) !== null && _setName !== void 0 ? _setName : serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n  serverDescription.allHosts.forEach(function (address) {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n    }\n  });\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n  return [topologyType, setName];\n}\nfunction checkHasPrimary(serverDescriptions) {\n  var _iterator8 = _createForOfIteratorHelper(serverDescriptions.values()),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var serverDescription = _step8.value;\n      if (serverDescription.type === common_1.ServerType.RSPrimary) {\n        return common_1.TopologyType.ReplicaSetWithPrimary;\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  return common_1.TopologyType.ReplicaSetNoPrimary;\n}","map":{"version":3,"names":["WIRE_CONSTANTS","require","error_1","utils_1","common_1","server_description_1","MIN_SUPPORTED_SERVER_VERSION","MAX_SUPPORTED_SERVER_VERSION","MIN_SUPPORTED_WIRE_VERSION","MAX_SUPPORTED_WIRE_VERSION","MONGOS_OR_UNKNOWN","Set","ServerType","Mongos","Unknown","MONGOS_OR_STANDALONE","Standalone","NON_PRIMARY_RS_MEMBERS","RSSecondary","RSArbiter","RSOther","TopologyDescription","topologyType","_options","_options$heartbeatFre","_options$localThresho","serverDescriptions","arguments","length","undefined","setName","maxSetVersion","maxElectionId","commonWireVersion","options","_classCallCheck","type","TopologyType","servers","Map","stale","compatible","heartbeatFrequencyMS","localThresholdMS","_iterator","_createForOfIteratorHelper","values","_step","s","n","done","serverDescription","value","LoadBalancer","minWireVersion","compatibilityError","concat","address","maxWireVersion","err","e","f","logicalSessionTimeoutMinutes","_iterator2","_step2","_step2$value","_slicedToArray","server","isReadable","Math","min","_createClass","key","updateFromSrvPollingEvent","ev","srvMaxHosts","incomingHostnames","hostnames","currentHostnames","keys","hostnamesToAdd","hostnamesToRemove","_iterator3","_step3","hostname","delete","has","add","size","_iterator4","_step4","removedHost","_iterator5","_step5","hostToAdd","set","ServerDescription","selectedHosts","shuffle","_iterator6","_step6","selectedHostToAdd","update","serverType","Single","topologyTypeForServerType","Sharded","ReplicaSetNoPrimary","RSPrimary","result","updateRsFromPrimary","updateRsNoPrimaryFromMember","ReplicaSetWithPrimary","checkHasPrimary","updateRsWithPrimaryFromMember","get","descriptionsWithError","Array","from","filter","sd","error","some","isDataBearing","hasServer","exports","_maxSetVersion","_serverDescription$se","electionIdComparison","compareObjectId","electionId","maxElectionIdIsEqual","maxElectionIdIsLess","maxSetVersionIsLessOrEqual","setVersion","_iterator7","_step7","_step7$value","allHosts","forEach","currentAddresses","responseAddresses","addr","indexOf","MongoRuntimeError","me","_setName","_iterator8","_step8"],"sources":["/home/salman/Documents/GitHub/FakeShop/node_modules/mongodb/src/sdam/topology_description.ts"],"sourcesContent":["import type { ObjectId } from '../bson';\nimport * as WIRE_CONSTANTS from '../cmap/wire_protocol/constants';\nimport { MongoRuntimeError, type MongoServerError } from '../error';\nimport { compareObjectId, shuffle } from '../utils';\nimport { ServerType, TopologyType } from './common';\nimport { ServerDescription } from './server_description';\nimport type { SrvPollingEvent } from './srv_polling';\n\n// constants related to compatibility checks\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\n\nconst MONGOS_OR_UNKNOWN = new Set<ServerType>([ServerType.Mongos, ServerType.Unknown]);\nconst MONGOS_OR_STANDALONE = new Set<ServerType>([ServerType.Mongos, ServerType.Standalone]);\nconst NON_PRIMARY_RS_MEMBERS = new Set<ServerType>([\n  ServerType.RSSecondary,\n  ServerType.RSArbiter,\n  ServerType.RSOther\n]);\n\n/** @public */\nexport interface TopologyDescriptionOptions {\n  heartbeatFrequencyMS?: number;\n  localThresholdMS?: number;\n}\n\n/**\n * Representation of a deployment of servers\n * @public\n */\nexport class TopologyDescription {\n  type: TopologyType;\n  setName: string | null;\n  maxSetVersion: number | null;\n  maxElectionId: ObjectId | null;\n  servers: Map<string, ServerDescription>;\n  stale: boolean;\n  compatible: boolean;\n  compatibilityError?: string;\n  logicalSessionTimeoutMinutes: number | null;\n  heartbeatFrequencyMS: number;\n  localThresholdMS: number;\n  commonWireVersion: number;\n\n  /**\n   * Create a TopologyDescription\n   */\n  constructor(\n    topologyType: TopologyType,\n    serverDescriptions: Map<string, ServerDescription> | null = null,\n    setName: string | null = null,\n    maxSetVersion: number | null = null,\n    maxElectionId: ObjectId | null = null,\n    commonWireVersion: number | null = null,\n    options: TopologyDescriptionOptions | null = null\n  ) {\n    options = options ?? {};\n\n    this.type = topologyType ?? TopologyType.Unknown;\n    this.servers = serverDescriptions ?? new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 0;\n    this.localThresholdMS = options.localThresholdMS ?? 15;\n    this.setName = setName ?? null;\n    this.maxElectionId = maxElectionId ?? null;\n    this.maxSetVersion = maxSetVersion ?? null;\n    this.commonWireVersion = commonWireVersion ?? 0;\n\n    // determine server compatibility\n    for (const serverDescription of this.servers.values()) {\n      // Load balancer mode is always compatible.\n      if (\n        serverDescription.type === ServerType.Unknown ||\n        serverDescription.type === ServerType.LoadBalancer\n      ) {\n        continue;\n      }\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    }\n\n    // Whenever a client updates the TopologyDescription from a hello response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n    this.logicalSessionTimeoutMinutes = null;\n    for (const [, server] of this.servers) {\n      if (server.isReadable) {\n        if (server.logicalSessionTimeoutMinutes == null) {\n          // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n          this.logicalSessionTimeoutMinutes = null;\n          break;\n        }\n\n        if (this.logicalSessionTimeoutMinutes == null) {\n          // First server with a non null logicalSessionsTimeout\n          this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n          continue;\n        }\n\n        // Always select the smaller of the:\n        // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n        this.logicalSessionTimeoutMinutes = Math.min(\n          this.logicalSessionTimeoutMinutes,\n          server.logicalSessionTimeoutMinutes\n        );\n      }\n    }\n  }\n\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @internal\n   */\n  updateFromSrvPollingEvent(ev: SrvPollingEvent, srvMaxHosts = 0): TopologyDescription {\n    /** The SRV addresses defines the set of addresses we should be using */\n    const incomingHostnames = ev.hostnames();\n    const currentHostnames = new Set(this.servers.keys());\n\n    const hostnamesToAdd = new Set<string>(incomingHostnames);\n    const hostnamesToRemove = new Set<string>();\n    for (const hostname of currentHostnames) {\n      // filter hostnamesToAdd (made from incomingHostnames) down to what is *not* present in currentHostnames\n      hostnamesToAdd.delete(hostname);\n      if (!incomingHostnames.has(hostname)) {\n        // If the SRV Records no longer include this hostname\n        // we have to stop using it\n        hostnamesToRemove.add(hostname);\n      }\n    }\n\n    if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {\n      // No new hosts to add and none to remove\n      return this;\n    }\n\n    const serverDescriptions = new Map(this.servers);\n    for (const removedHost of hostnamesToRemove) {\n      serverDescriptions.delete(removedHost);\n    }\n\n    if (hostnamesToAdd.size > 0) {\n      if (srvMaxHosts === 0) {\n        // Add all!\n        for (const hostToAdd of hostnamesToAdd) {\n          serverDescriptions.set(hostToAdd, new ServerDescription(hostToAdd));\n        }\n      } else if (serverDescriptions.size < srvMaxHosts) {\n        // Add only the amount needed to get us back to srvMaxHosts\n        const selectedHosts = shuffle(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);\n        for (const selectedHostToAdd of selectedHosts) {\n          serverDescriptions.set(selectedHostToAdd, new ServerDescription(selectedHostToAdd));\n        }\n      }\n    }\n\n    return new TopologyDescription(\n      this.type,\n      serverDescriptions,\n      this.setName,\n      this.maxSetVersion,\n      this.maxElectionId,\n      this.commonWireVersion,\n      { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\n    );\n  }\n\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   * @internal\n   */\n  update(serverDescription: ServerDescription): TopologyDescription {\n    const address = serverDescription.address;\n\n    // potentially mutated values\n    let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;\n\n    const serverType = serverDescription.type;\n    const serverDescriptions = new Map(this.servers);\n\n    // update common wire version\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    }\n\n    if (\n      typeof serverDescription.setName === 'string' &&\n      typeof setName === 'string' &&\n      serverDescription.setName !== setName\n    ) {\n      if (topologyType === TopologyType.Single) {\n        // \"Single\" Topology with setName mismatch is direct connection usage, mark unknown do not remove\n        serverDescription = new ServerDescription(address);\n      } else {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    // update the actual server description\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(\n        TopologyType.Single,\n        serverDescriptions,\n        setName,\n        maxSetVersion,\n        maxElectionId,\n        commonWireVersion,\n        { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\n      );\n    }\n\n    if (topologyType === TopologyType.Unknown) {\n      if (serverType === ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === TopologyType.Sharded) {\n      if (!MONGOS_OR_UNKNOWN.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetNoPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          serverDescription,\n          setName,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);\n        topologyType = result[0];\n        setName = result[1];\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetWithPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          serverDescription,\n          setName,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        topologyType = updateRsWithPrimaryFromMember(\n          serverDescriptions,\n          serverDescription,\n          setName\n        );\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(\n      topologyType,\n      serverDescriptions,\n      setName,\n      maxSetVersion,\n      maxElectionId,\n      commonWireVersion,\n      { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\n    );\n  }\n\n  get error(): MongoServerError | null {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(\n      (sd: ServerDescription) => sd.error\n    );\n\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n\n    return null;\n  }\n\n  /**\n   * Determines if the topology description has any known servers\n   */\n  get hasKnownServers(): boolean {\n    return Array.from(this.servers.values()).some(\n      (sd: ServerDescription) => sd.type !== ServerType.Unknown\n    );\n  }\n\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n  get hasDataBearingServers(): boolean {\n    return Array.from(this.servers.values()).some((sd: ServerDescription) => sd.isDataBearing);\n  }\n\n  /**\n   * Determines if the topology has a definition for the provided address\n   * @internal\n   */\n  hasServer(address: string): boolean {\n    return this.servers.has(address);\n  }\n}\n\nfunction topologyTypeForServerType(serverType: ServerType): TopologyType {\n  switch (serverType) {\n    case ServerType.Standalone:\n      return TopologyType.Single;\n    case ServerType.Mongos:\n      return TopologyType.Sharded;\n    case ServerType.RSPrimary:\n      return TopologyType.ReplicaSetWithPrimary;\n    case ServerType.RSOther:\n    case ServerType.RSSecondary:\n      return TopologyType.ReplicaSetNoPrimary;\n    default:\n      return TopologyType.Unknown;\n  }\n}\n\nfunction updateRsFromPrimary(\n  serverDescriptions: Map<string, ServerDescription>,\n  serverDescription: ServerDescription,\n  setName: string | null = null,\n  maxSetVersion: number | null = null,\n  maxElectionId: ObjectId | null = null\n): [TopologyType, string | null, number | null, ObjectId | null] {\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  if (serverDescription.maxWireVersion >= 17) {\n    const electionIdComparison = compareObjectId(maxElectionId, serverDescription.electionId);\n    const maxElectionIdIsEqual = electionIdComparison === 0;\n    const maxElectionIdIsLess = electionIdComparison === -1;\n    const maxSetVersionIsLessOrEqual =\n      (maxSetVersion ?? -1) <= (serverDescription.setVersion ?? -1);\n\n    if (maxElectionIdIsLess || (maxElectionIdIsEqual && maxSetVersionIsLessOrEqual)) {\n      // The reported electionId was greater\n      // or the electionId was equal and reported setVersion was greater\n      // Always update both values, they are a tuple\n      maxElectionId = serverDescription.electionId;\n      maxSetVersion = serverDescription.setVersion;\n    } else {\n      // Stale primary\n      // replace serverDescription with a default ServerDescription of type \"Unknown\"\n      serverDescriptions.set(\n        serverDescription.address,\n        new ServerDescription(serverDescription.address)\n      );\n\n      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n    }\n  } else {\n    const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n    if (serverDescription.setVersion && electionId) {\n      if (maxSetVersion && maxElectionId) {\n        if (\n          maxSetVersion > serverDescription.setVersion ||\n          compareObjectId(maxElectionId, electionId) > 0\n        ) {\n          // this primary is stale, we must remove it\n          serverDescriptions.set(\n            serverDescription.address,\n            new ServerDescription(serverDescription.address)\n          );\n\n          return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n        }\n      }\n\n      maxElectionId = serverDescription.electionId;\n    }\n\n    if (\n      serverDescription.setVersion != null &&\n      (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)\n    ) {\n      maxSetVersion = serverDescription.setVersion;\n    }\n  }\n\n  // We've heard from the primary. Is it the same primary as before?\n  for (const [address, server] of serverDescriptions) {\n    if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new ServerDescription(server.address));\n\n      // There can only be one primary\n      break;\n    }\n  }\n\n  // Discover new hosts from this primary's response.\n  serverDescription.allHosts.forEach((address: string) => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  // Remove hosts not in the response.\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses\n    .filter((addr: string) => responseAddresses.indexOf(addr) === -1)\n    .forEach((address: string) => {\n      serverDescriptions.delete(address);\n    });\n\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(\n  serverDescriptions: Map<string, ServerDescription>,\n  serverDescription: ServerDescription,\n  setName: string | null = null\n): TopologyType {\n  if (setName == null) {\n    // TODO(NODE-3483): should be an appropriate runtime error\n    throw new MongoRuntimeError('Argument \"setName\" is required if connected to a replica set');\n  }\n\n  if (\n    setName !== serverDescription.setName ||\n    (serverDescription.me && serverDescription.address !== serverDescription.me)\n  ) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(\n  serverDescriptions: Map<string, ServerDescription>,\n  serverDescription: ServerDescription,\n  setName: string | null = null\n): [TopologyType, string | null] {\n  const topologyType = TopologyType.ReplicaSetNoPrimary;\n  setName = setName ?? serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach((address: string) => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions: Map<string, ServerDescription>): TopologyType {\n  for (const serverDescription of serverDescriptions.values()) {\n    if (serverDescription.type === ServerType.RSPrimary) {\n      return TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}