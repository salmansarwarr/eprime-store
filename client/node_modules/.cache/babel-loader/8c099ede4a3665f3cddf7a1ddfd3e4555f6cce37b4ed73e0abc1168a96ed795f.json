{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessageStream = void 0;\nvar stream_1 = require(\"stream\");\nvar error_1 = require(\"../error\");\nvar utils_1 = require(\"../utils\");\nvar commands_1 = require(\"./commands\");\nvar compression_1 = require(\"./wire_protocol/compression\");\nvar constants_1 = require(\"./wire_protocol/constants\");\nvar MESSAGE_HEADER_SIZE = 16;\nvar COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID\nvar kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\n/** @internal */\nvar kBuffer = Symbol('buffer');\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n * @internal\n */\nvar MessageStream = /*#__PURE__*/function (_stream_1$Duplex) {\n  _inherits(MessageStream, _stream_1$Duplex);\n  var _super = _createSuper(MessageStream);\n  function MessageStream() {\n    var _this;\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, MessageStream);\n    _this = _super.call(this, options);\n    /** @internal */\n    _this.isMonitoringConnection = false;\n    _this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n    _this[kBuffer] = new utils_1.BufferPool();\n    return _this;\n  }\n  _createClass(MessageStream, [{\n    key: \"buffer\",\n    get: function get() {\n      return this[kBuffer];\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, _, callback) {\n      this[kBuffer].append(chunk);\n      processIncomingData(this, callback);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read( /* size */\n    ) {\n      // NOTE: This implementation is empty because we explicitly push data to be read\n      //       when `writeMessage` is called.\n      return;\n    }\n  }, {\n    key: \"writeCommand\",\n    value: function writeCommand(command, operationDescription) {\n      var _operationDescription,\n        _operationDescription2,\n        _this2 = this;\n      var agreedCompressor = (_operationDescription = operationDescription.agreedCompressor) !== null && _operationDescription !== void 0 ? _operationDescription : 'none';\n      if (agreedCompressor === 'none' || !canCompress(command)) {\n        var data = command.toBin();\n        this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n        return;\n      }\n      // otherwise, compress the message\n      var concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n      var messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n      // Extract information needed for OP_COMPRESSED from the uncompressed message\n      var originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n      var options = {\n        agreedCompressor: agreedCompressor,\n        zlibCompressionLevel: (_operationDescription2 = operationDescription.zlibCompressionLevel) !== null && _operationDescription2 !== void 0 ? _operationDescription2 : 0\n      };\n      // Compress the message body\n      (0, compression_1.compress)(options, messageToBeCompressed).then(function (compressedMessage) {\n        // Create the msgHeader of OP_COMPRESSED\n        var msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n        msgHeader.writeInt32LE(command.requestId, 4); // requestID\n        msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n        msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12); // opCode\n        // Create the compression details of OP_COMPRESSED\n        var compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n        compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n        compressionDetails.writeUInt8(compression_1.Compressor[agreedCompressor], 8); // compressorID\n        _this2.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n      }, function (error) {\n        operationDescription.cb(error);\n      });\n    }\n  }]);\n  return MessageStream;\n}(stream_1.Duplex);\nexports.MessageStream = MessageStream;\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command) {\n  var commandDoc = command instanceof commands_1.Msg ? command.command : command.query;\n  var commandName = Object.keys(commandDoc)[0];\n  return !compression_1.uncompressibleCommands.has(commandName);\n}\nfunction processIncomingData(stream, callback) {\n  var buffer = stream[kBuffer];\n  var sizeOfMessage = buffer.getInt32();\n  if (sizeOfMessage == null) {\n    return callback();\n  }\n  if (sizeOfMessage < 0) {\n    return callback(new error_1.MongoParseError(\"Invalid message size: \".concat(sizeOfMessage)));\n  }\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    return callback(new error_1.MongoParseError(\"Invalid message size: \".concat(sizeOfMessage, \", max allowed: \").concat(stream.maxBsonMessageSize)));\n  }\n  if (sizeOfMessage > buffer.length) {\n    return callback();\n  }\n  var message = buffer.read(sizeOfMessage);\n  var messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n  var monitorHasAnotherHello = function monitorHasAnotherHello() {\n    if (stream.isMonitoringConnection) {\n      // Can we read the next message size?\n      var _sizeOfMessage = buffer.getInt32();\n      if (_sizeOfMessage != null && _sizeOfMessage <= buffer.length) {\n        return true;\n      }\n    }\n    return false;\n  };\n  var ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n  if (messageHeader.opCode !== constants_1.OP_COMPRESSED) {\n    var messageBody = message.subarray(MESSAGE_HEADER_SIZE);\n    // If we are a monitoring connection message stream and\n    // there is more in the buffer that can be read, skip processing since we\n    // want the last hello command response that is in the buffer.\n    if (monitorHasAnotherHello()) {\n      return processIncomingData(stream, callback);\n    }\n    stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n    if (buffer.length >= 4) {\n      return processIncomingData(stream, callback);\n    }\n    return callback();\n  }\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  var compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  var compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n  // recalculate based on wrapped opcode\n  ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n  (0, compression_1.decompress)(compressorID, compressedBuffer).then(function (messageBody) {\n    if (messageBody.length !== messageHeader.length) {\n      return callback(new error_1.MongoDecompressionError('Message body and message header must be the same length'));\n    }\n    // If we are a monitoring connection message stream and\n    // there is more in the buffer that can be read, skip processing since we\n    // want the last hello command response that is in the buffer.\n    if (monitorHasAnotherHello()) {\n      return processIncomingData(stream, callback);\n    }\n    stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n    if (buffer.length >= 4) {\n      return processIncomingData(stream, callback);\n    }\n    return callback();\n  }, function (error) {\n    return callback(error);\n  });\n}","map":{"version":3,"names":["stream_1","require","error_1","utils_1","commands_1","compression_1","constants_1","MESSAGE_HEADER_SIZE","COMPRESSION_DETAILS_SIZE","kDefaultMaxBsonMessageSize","kBuffer","Symbol","MessageStream","_stream_1$Duplex","_inherits","_super","_createSuper","_this","options","arguments","length","undefined","_classCallCheck","call","isMonitoringConnection","maxBsonMessageSize","BufferPool","_createClass","key","get","value","_write","chunk","_","callback","append","processIncomingData","_read","writeCommand","command","operationDescription","_operationDescription","_operationDescription2","_this2","agreedCompressor","canCompress","data","toBin","push","Array","isArray","Buffer","concat","concatenatedOriginalCommandBuffer","messageToBeCompressed","slice","originalCommandOpCode","readInt32LE","zlibCompressionLevel","compress","then","compressedMessage","msgHeader","alloc","writeInt32LE","requestId","OP_COMPRESSED","compressionDetails","writeUInt8","Compressor","error","cb","Duplex","exports","commandDoc","Msg","query","commandName","Object","keys","uncompressibleCommands","has","stream","buffer","sizeOfMessage","getInt32","MongoParseError","message","read","messageHeader","responseTo","opCode","monitorHasAnotherHello","ResponseType","OP_MSG","BinMsg","Response","messageBody","subarray","emit","fromCompressed","compressorID","compressedBuffer","decompress","MongoDecompressionError"],"sources":["/home/salman/Documents/GitHub/FakeShop/node_modules/mongodb/src/cmap/message_stream.ts"],"sourcesContent":["import { Duplex, type DuplexOptions } from 'stream';\n\nimport type { BSONSerializeOptions, Document } from '../bson';\nimport { MongoDecompressionError, MongoParseError } from '../error';\nimport type { ClientSession } from '../sessions';\nimport { BufferPool, type Callback } from '../utils';\nimport {\n  BinMsg,\n  type MessageHeader,\n  Msg,\n  Response,\n  type WriteProtocolMessageType\n} from './commands';\nimport {\n  compress,\n  Compressor,\n  type CompressorName,\n  decompress,\n  uncompressibleCommands\n} from './wire_protocol/compression';\nimport { OP_COMPRESSED, OP_MSG } from './wire_protocol/constants';\n\nconst MESSAGE_HEADER_SIZE = 16;\nconst COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID\n\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\n/** @internal */\nconst kBuffer = Symbol('buffer');\n\n/** @internal */\nexport interface MessageStreamOptions extends DuplexOptions {\n  maxBsonMessageSize?: number;\n}\n\n/** @internal */\nexport interface OperationDescription extends BSONSerializeOptions {\n  started: number;\n  cb: Callback<Document>;\n  documentsReturnedIn?: string;\n  noResponse: boolean;\n  raw: boolean;\n  requestId: number;\n  session?: ClientSession;\n  agreedCompressor?: CompressorName;\n  zlibCompressionLevel?: number;\n  $clusterTime?: Document;\n}\n\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n * @internal\n */\nexport class MessageStream extends Duplex {\n  /** @internal */\n  maxBsonMessageSize: number;\n  /** @internal */\n  [kBuffer]: BufferPool;\n  /** @internal */\n  isMonitoringConnection = false;\n\n  constructor(options: MessageStreamOptions = {}) {\n    super(options);\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n    this[kBuffer] = new BufferPool();\n  }\n\n  get buffer(): BufferPool {\n    return this[kBuffer];\n  }\n\n  override _write(chunk: Buffer, _: unknown, callback: Callback<Buffer>): void {\n    this[kBuffer].append(chunk);\n    processIncomingData(this, callback);\n  }\n\n  override _read(/* size */): void {\n    // NOTE: This implementation is empty because we explicitly push data to be read\n    //       when `writeMessage` is called.\n    return;\n  }\n\n  writeCommand(\n    command: WriteProtocolMessageType,\n    operationDescription: OperationDescription\n  ): void {\n    const agreedCompressor = operationDescription.agreedCompressor ?? 'none';\n    if (agreedCompressor === 'none' || !canCompress(command)) {\n      const data = command.toBin();\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n      return;\n    }\n    // otherwise, compress the message\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n\n    // Extract information needed for OP_COMPRESSED from the uncompressed message\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n\n    const options = {\n      agreedCompressor,\n      zlibCompressionLevel: operationDescription.zlibCompressionLevel ?? 0\n    };\n    // Compress the message body\n    compress(options, messageToBeCompressed).then(\n      compressedMessage => {\n        // Create the msgHeader of OP_COMPRESSED\n        const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n        msgHeader.writeInt32LE(\n          MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length,\n          0\n        ); // messageLength\n        msgHeader.writeInt32LE(command.requestId, 4); // requestID\n        msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n        msgHeader.writeInt32LE(OP_COMPRESSED, 12); // opCode\n\n        // Create the compression details of OP_COMPRESSED\n        const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n        compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n        compressionDetails.writeUInt8(Compressor[agreedCompressor], 8); // compressorID\n        this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n      },\n      error => {\n        operationDescription.cb(error);\n      }\n    );\n  }\n}\n\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command: WriteProtocolMessageType) {\n  const commandDoc = command instanceof Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n}\n\nfunction processIncomingData(stream: MessageStream, callback: Callback<Buffer>): void {\n  const buffer = stream[kBuffer];\n  const sizeOfMessage = buffer.getInt32();\n\n  if (sizeOfMessage == null) {\n    return callback();\n  }\n\n  if (sizeOfMessage < 0) {\n    return callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n  }\n\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    return callback(\n      new MongoParseError(\n        `Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`\n      )\n    );\n  }\n\n  if (sizeOfMessage > buffer.length) {\n    return callback();\n  }\n\n  const message = buffer.read(sizeOfMessage);\n  const messageHeader: MessageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n\n  const monitorHasAnotherHello = () => {\n    if (stream.isMonitoringConnection) {\n      // Can we read the next message size?\n      const sizeOfMessage = buffer.getInt32();\n      if (sizeOfMessage != null && sizeOfMessage <= buffer.length) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  if (messageHeader.opCode !== OP_COMPRESSED) {\n    const messageBody = message.subarray(MESSAGE_HEADER_SIZE);\n\n    // If we are a monitoring connection message stream and\n    // there is more in the buffer that can be read, skip processing since we\n    // want the last hello command response that is in the buffer.\n    if (monitorHasAnotherHello()) {\n      return processIncomingData(stream, callback);\n    }\n\n    stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n\n    if (buffer.length >= 4) {\n      return processIncomingData(stream, callback);\n    }\n    return callback();\n  }\n\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n\n  // recalculate based on wrapped opcode\n  ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  decompress(compressorID, compressedBuffer).then(\n    messageBody => {\n      if (messageBody.length !== messageHeader.length) {\n        return callback(\n          new MongoDecompressionError('Message body and message header must be the same length')\n        );\n      }\n\n      // If we are a monitoring connection message stream and\n      // there is more in the buffer that can be read, skip processing since we\n      // want the last hello command response that is in the buffer.\n      if (monitorHasAnotherHello()) {\n        return processIncomingData(stream, callback);\n      }\n      stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n\n      if (buffer.length >= 4) {\n        return processIncomingData(stream, callback);\n      }\n      return callback();\n    },\n    error => {\n      return callback(error);\n    }\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}