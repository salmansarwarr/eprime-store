{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _regeneratorRuntime = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _createForOfIteratorHelper = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _asyncToGenerator = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _objectSpread = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.prepareHandshakeDocument = exports.connect = exports.AUTH_PROVIDERS = void 0;\nvar net = require(\"net\");\nvar socks_1 = require(\"socks\");\nvar tls = require(\"tls\");\nvar constants_1 = require(\"../constants\");\nvar error_1 = require(\"../error\");\nvar utils_1 = require(\"../utils\");\nvar auth_provider_1 = require(\"./auth/auth_provider\");\nvar gssapi_1 = require(\"./auth/gssapi\");\nvar mongocr_1 = require(\"./auth/mongocr\");\nvar mongodb_aws_1 = require(\"./auth/mongodb_aws\");\nvar mongodb_oidc_1 = require(\"./auth/mongodb_oidc\");\nvar plain_1 = require(\"./auth/plain\");\nvar providers_1 = require(\"./auth/providers\");\nvar scram_1 = require(\"./auth/scram\");\nvar x509_1 = require(\"./auth/x509\");\nvar connection_1 = require(\"./connection\");\nvar constants_2 = require(\"./wire_protocol/constants\");\n/** @internal */\nexports.AUTH_PROVIDERS = new Map([[providers_1.AuthMechanism.MONGODB_AWS, new mongodb_aws_1.MongoDBAWS()], [providers_1.AuthMechanism.MONGODB_CR, new mongocr_1.MongoCR()], [providers_1.AuthMechanism.MONGODB_GSSAPI, new gssapi_1.GSSAPI()], [providers_1.AuthMechanism.MONGODB_OIDC, new mongodb_oidc_1.MongoDBOIDC()], [providers_1.AuthMechanism.MONGODB_PLAIN, new plain_1.Plain()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, new scram_1.ScramSHA1()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, new scram_1.ScramSHA256()], [providers_1.AuthMechanism.MONGODB_X509, new x509_1.X509()]]);\nfunction connect(options, callback) {\n  makeConnection(_objectSpread(_objectSpread({}, options), {}, {\n    existingSocket: undefined\n  }), function (err, socket) {\n    var _options$connectionTy;\n    if (err || !socket) {\n      return callback(err);\n    }\n    var ConnectionType = (_options$connectionTy = options.connectionType) !== null && _options$connectionTy !== void 0 ? _options$connectionTy : connection_1.Connection;\n    if (options.autoEncrypter) {\n      ConnectionType = connection_1.CryptoConnection;\n    }\n    var connection = new ConnectionType(socket, options);\n    performInitialHandshake(connection, options).then(function () {\n      return callback(undefined, connection);\n    }, function (error) {\n      connection.destroy({\n        force: false\n      });\n      callback(error);\n    });\n  });\n}\nexports.connect = connect;\nfunction checkSupportedServer(hello, options) {\n  var _JSON$stringify;\n  var maxWireVersion = Number(hello.maxWireVersion);\n  var minWireVersion = Number(hello.minWireVersion);\n  var serverVersionHighEnough = !Number.isNaN(maxWireVersion) && maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;\n  var serverVersionLowEnough = !Number.isNaN(minWireVersion) && minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n    var _message = \"Server at \".concat(options.hostAddress, \" reports minimum wire version \").concat(JSON.stringify(hello.minWireVersion), \", but this version of the Node.js Driver requires at most \").concat(constants_2.MAX_SUPPORTED_WIRE_VERSION, \" (MongoDB \").concat(constants_2.MAX_SUPPORTED_SERVER_VERSION, \")\");\n    return new error_1.MongoCompatibilityError(_message);\n  }\n  var message = \"Server at \".concat(options.hostAddress, \" reports maximum wire version \").concat((_JSON$stringify = JSON.stringify(hello.maxWireVersion)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : 0, \", but this version of the Node.js Driver requires at least \").concat(constants_2.MIN_SUPPORTED_WIRE_VERSION, \" (MongoDB \").concat(constants_2.MIN_SUPPORTED_SERVER_VERSION, \")\");\n  return new error_1.MongoCompatibilityError(message);\n}\nfunction performInitialHandshake(_x, _x2) {\n  return _performInitialHandshake.apply(this, arguments);\n}\n/**\n * @internal\n *\n * This function is only exposed for testing purposes.\n */\nfunction _performInitialHandshake() {\n  _performInitialHandshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(conn, options) {\n    var credentials, authContext, handshakeDoc, handshakeOptions, start, response, supportedServerErr, resolvedCredentials, provider;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          credentials = options.credentials;\n          if (!credentials) {\n            _context.next = 4;\n            break;\n          }\n          if (!(!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !exports.AUTH_PROVIDERS.get(credentials.mechanism))) {\n            _context.next = 4;\n            break;\n          }\n          throw new error_1.MongoInvalidArgumentError(\"AuthMechanism '\".concat(credentials.mechanism, \"' not supported\"));\n        case 4:\n          authContext = new auth_provider_1.AuthContext(conn, credentials, options);\n          conn.authContext = authContext;\n          _context.next = 8;\n          return prepareHandshakeDocument(authContext);\n        case 8:\n          handshakeDoc = _context.sent;\n          // @ts-expect-error: TODO(NODE-5141): The options need to be filtered properly, Connection options differ from Command options\n          handshakeOptions = _objectSpread({}, options);\n          if (typeof options.connectTimeoutMS === 'number') {\n            // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n            handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n          }\n          start = new Date().getTime();\n          _context.next = 14;\n          return conn.commandAsync((0, utils_1.ns)('admin.$cmd'), handshakeDoc, handshakeOptions);\n        case 14:\n          response = _context.sent;\n          if (!('isWritablePrimary' in response)) {\n            // Provide hello-style response document.\n            response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];\n          }\n          if (response.helloOk) {\n            conn.helloOk = true;\n          }\n          supportedServerErr = checkSupportedServer(response, options);\n          if (!supportedServerErr) {\n            _context.next = 20;\n            break;\n          }\n          throw supportedServerErr;\n        case 20:\n          if (!options.loadBalanced) {\n            _context.next = 23;\n            break;\n          }\n          if (response.serviceId) {\n            _context.next = 23;\n            break;\n          }\n          throw new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' + 'but the server does not support this mode.');\n        case 23:\n          // NOTE: This is metadata attached to the connection while porting away from\n          //       handshake being done in the `Server` class. Likely, it should be\n          //       relocated, or at very least restructured.\n          conn.hello = response;\n          conn.lastHelloMS = new Date().getTime() - start;\n          if (!(!response.arbiterOnly && credentials)) {\n            _context.next = 40;\n            break;\n          }\n          // store the response on auth context\n          authContext.response = response;\n          resolvedCredentials = credentials.resolveAuthMechanism(response);\n          provider = exports.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n          if (provider) {\n            _context.next = 31;\n            break;\n          }\n          throw new error_1.MongoInvalidArgumentError(\"No AuthProvider for \".concat(resolvedCredentials.mechanism, \" defined.\"));\n        case 31:\n          _context.prev = 31;\n          _context.next = 34;\n          return provider.auth(authContext);\n        case 34:\n          _context.next = 40;\n          break;\n        case 36:\n          _context.prev = 36;\n          _context.t0 = _context[\"catch\"](31);\n          if (_context.t0 instanceof error_1.MongoError) {\n            _context.t0.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);\n            if ((0, error_1.needsRetryableWriteLabel)(_context.t0, response.maxWireVersion)) {\n              _context.t0.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);\n            }\n          }\n          throw _context.t0;\n        case 40:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[31, 36]]);\n  }));\n  return _performInitialHandshake.apply(this, arguments);\n}\nfunction prepareHandshakeDocument(_x3) {\n  return _prepareHandshakeDocument.apply(this, arguments);\n}\nfunction _prepareHandshakeDocument() {\n  _prepareHandshakeDocument = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(authContext) {\n    var _handshakeDoc;\n    var options, compressors, serverApi, handshakeDoc, credentials, _provider, provider;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          options = authContext.options;\n          compressors = options.compressors ? options.compressors : [];\n          serverApi = authContext.connection.serverApi;\n          handshakeDoc = (_handshakeDoc = {}, _defineProperty(_handshakeDoc, serverApi !== null && serverApi !== void 0 && serverApi.version ? 'hello' : constants_1.LEGACY_HELLO_COMMAND, 1), _defineProperty(_handshakeDoc, \"helloOk\", true), _defineProperty(_handshakeDoc, \"client\", options.metadata), _defineProperty(_handshakeDoc, \"compression\", compressors), _handshakeDoc);\n          if (options.loadBalanced === true) {\n            handshakeDoc.loadBalanced = true;\n          }\n          credentials = authContext.credentials;\n          if (!credentials) {\n            _context2.next = 17;\n            break;\n          }\n          if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username)) {\n            _context2.next = 13;\n            break;\n          }\n          handshakeDoc.saslSupportedMechs = \"\".concat(credentials.source, \".\").concat(credentials.username);\n          _provider = exports.AUTH_PROVIDERS.get(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256);\n          if (_provider) {\n            _context2.next = 12;\n            break;\n          }\n          throw new error_1.MongoInvalidArgumentError(\"No AuthProvider for \".concat(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, \" defined.\"));\n        case 12:\n          return _context2.abrupt(\"return\", _provider.prepare(handshakeDoc, authContext));\n        case 13:\n          provider = exports.AUTH_PROVIDERS.get(credentials.mechanism);\n          if (provider) {\n            _context2.next = 16;\n            break;\n          }\n          throw new error_1.MongoInvalidArgumentError(\"No AuthProvider for \".concat(credentials.mechanism, \" defined.\"));\n        case 16:\n          return _context2.abrupt(\"return\", provider.prepare(handshakeDoc, authContext));\n        case 17:\n          return _context2.abrupt(\"return\", handshakeDoc);\n        case 18:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _prepareHandshakeDocument.apply(this, arguments);\n}\nexports.prepareHandshakeDocument = prepareHandshakeDocument;\n/** @public */\nexports.LEGAL_TLS_SOCKET_OPTIONS = ['ALPNProtocols', 'ca', 'cert', 'checkServerIdentity', 'ciphers', 'crl', 'ecdhCurve', 'key', 'minDHSize', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureContext', 'secureProtocol', 'servername', 'session'];\n/** @public */\nexports.LEGAL_TCP_SOCKET_OPTIONS = ['family', 'hints', 'localAddress', 'localPort', 'lookup'];\nfunction parseConnectOptions(options) {\n  var hostAddress = options.hostAddress;\n  if (!hostAddress) throw new error_1.MongoInvalidArgumentError('Option \"hostAddress\" is required');\n  var result = {};\n  var _iterator = _createForOfIteratorHelper(exports.LEGAL_TCP_SOCKET_OPTIONS),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var name = _step.value;\n      if (options[name] != null) {\n        result[name] = options[name];\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError(\"Unexpected HostAddress \".concat(JSON.stringify(hostAddress)));\n  }\n}\nfunction parseSslOptions(options) {\n  var result = parseConnectOptions(options);\n  // Merge in valid SSL options\n  var _iterator2 = _createForOfIteratorHelper(exports.LEGAL_TLS_SOCKET_OPTIONS),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var name = _step2.value;\n      if (options[name] != null) {\n        result[name] = options[name];\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  if (options.existingSocket) {\n    result.socket = options.existingSocket;\n  }\n  // Set default sni servername to be the same as host\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n  return result;\n}\nvar SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];\nvar SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\nfunction makeConnection(options, _callback) {\n  var _options$tls, _options$keepAlive, _ref, _options$socketTimeou, _options$noDelay, _options$connectTimeo, _options$rejectUnauth, _ref2, _options$keepAliveIni;\n  var useTLS = (_options$tls = options.tls) !== null && _options$tls !== void 0 ? _options$tls : false;\n  var keepAlive = (_options$keepAlive = options.keepAlive) !== null && _options$keepAlive !== void 0 ? _options$keepAlive : true;\n  var socketTimeoutMS = (_ref = (_options$socketTimeou = options.socketTimeoutMS) !== null && _options$socketTimeou !== void 0 ? _options$socketTimeou : Reflect.get(options, 'socketTimeout')) !== null && _ref !== void 0 ? _ref : 0;\n  var noDelay = (_options$noDelay = options.noDelay) !== null && _options$noDelay !== void 0 ? _options$noDelay : true;\n  var connectTimeoutMS = (_options$connectTimeo = options.connectTimeoutMS) !== null && _options$connectTimeo !== void 0 ? _options$connectTimeo : 30000;\n  var rejectUnauthorized = (_options$rejectUnauth = options.rejectUnauthorized) !== null && _options$rejectUnauth !== void 0 ? _options$rejectUnauth : true;\n  var keepAliveInitialDelay = (_ref2 = ((_options$keepAliveIni = options.keepAliveInitialDelay) !== null && _options$keepAliveIni !== void 0 ? _options$keepAliveIni : 120000) > socketTimeoutMS ? Math.round(socketTimeoutMS / 2) : options.keepAliveInitialDelay) !== null && _ref2 !== void 0 ? _ref2 : 120000;\n  var existingSocket = options.existingSocket;\n  var socket;\n  var callback = function callback(err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n    _callback(err, ret);\n  };\n  if (options.proxyHost != null) {\n    // Currently, only Socks5 is supported.\n    return makeSocks5Connection(_objectSpread(_objectSpread({}, options), {}, {\n      connectTimeoutMS: connectTimeoutMS // Should always be present for Socks5\n    }), callback);\n  }\n  if (useTLS) {\n    var tlsSocket = tls.connect(parseSslOptions(options));\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n    socket = tlsSocket;\n  } else if (existingSocket) {\n    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\n    // so we only need to handle the non-TLS case here (where existingSocket\n    // gives us all we need out of the box).\n    socket = existingSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectTimeoutMS);\n  socket.setNoDelay(noDelay);\n  var connectEvent = useTLS ? 'secureConnect' : 'connect';\n  var cancellationHandler;\n  function errorHandler(eventName) {\n    return function (err) {\n      SOCKET_ERROR_EVENTS.forEach(function (event) {\n        return socket.removeAllListeners(event);\n      });\n      if (cancellationHandler && options.cancellationToken) {\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(function (event) {\n      return socket.removeAllListeners(event);\n    });\n    if (cancellationHandler && options.cancellationToken) {\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n    if ('authorizationError' in socket) {\n      if (socket.authorizationError && rejectUnauthorized) {\n        // TODO(NODE-5192): wrap this with a MongoError subclass\n        return callback(socket.authorizationError);\n      }\n    }\n    socket.setTimeout(0);\n    callback(undefined, socket);\n  }\n  SOCKET_ERROR_EVENTS.forEach(function (event) {\n    return socket.once(event, errorHandler(event));\n  });\n  if (options.cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    options.cancellationToken.once('cancel', cancellationHandler);\n  }\n  if (existingSocket) {\n    process.nextTick(connectHandler);\n  } else {\n    socket.once(connectEvent, connectHandler);\n  }\n}\nfunction makeSocks5Connection(options, callback) {\n  var _options$proxyHost, _options$proxyPort;\n  var hostAddress = utils_1.HostAddress.fromHostPort((_options$proxyHost = options.proxyHost) !== null && _options$proxyHost !== void 0 ? _options$proxyHost : '', // proxyHost is guaranteed to set here\n  (_options$proxyPort = options.proxyPort) !== null && _options$proxyPort !== void 0 ? _options$proxyPort : 1080);\n  // First, connect to the proxy server itself:\n  makeConnection(_objectSpread(_objectSpread({}, options), {}, {\n    hostAddress: hostAddress,\n    tls: false,\n    proxyHost: undefined\n  }), function (err, rawSocket) {\n    if (err) {\n      return callback(err);\n    }\n    var destination = parseConnectOptions(options);\n    if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\n      return callback(new error_1.MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts'));\n    }\n    // Then, establish the Socks5 proxy connection:\n    socks_1.SocksClient.createConnection({\n      existing_socket: rawSocket,\n      timeout: options.connectTimeoutMS,\n      command: 'connect',\n      destination: {\n        host: destination.host,\n        port: destination.port\n      },\n      proxy: {\n        // host and port are ignored because we pass existing_socket\n        host: 'iLoveJavaScript',\n        port: 0,\n        type: 5,\n        userId: options.proxyUsername || undefined,\n        password: options.proxyPassword || undefined\n      }\n    }).then(function (_ref3) {\n      var socket = _ref3.socket;\n      // Finally, now treat the resulting duplex stream as the\n      // socket over which we send and receive wire protocol messages:\n      makeConnection(_objectSpread(_objectSpread({}, options), {}, {\n        existingSocket: socket,\n        proxyHost: undefined\n      }), callback);\n    }, function (error) {\n      return callback(connectionFailureError('error', error));\n    });\n  });\n}\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new error_1.MongoNetworkError(err);\n    case 'timeout':\n      return new error_1.MongoNetworkTimeoutError('connection timed out');\n    case 'close':\n      return new error_1.MongoNetworkError('connection closed');\n    case 'cancel':\n      return new error_1.MongoNetworkError('connection establishment was cancelled');\n    default:\n      return new error_1.MongoNetworkError('unknown network error');\n  }\n}","map":{"version":3,"names":["net","require","socks_1","tls","constants_1","error_1","utils_1","auth_provider_1","gssapi_1","mongocr_1","mongodb_aws_1","mongodb_oidc_1","plain_1","providers_1","scram_1","x509_1","connection_1","constants_2","exports","AUTH_PROVIDERS","Map","AuthMechanism","MONGODB_AWS","MongoDBAWS","MONGODB_CR","MongoCR","MONGODB_GSSAPI","GSSAPI","MONGODB_OIDC","MongoDBOIDC","MONGODB_PLAIN","Plain","MONGODB_SCRAM_SHA1","ScramSHA1","MONGODB_SCRAM_SHA256","ScramSHA256","MONGODB_X509","X509","connect","options","callback","makeConnection","_objectSpread","existingSocket","undefined","err","socket","_options$connectionTy","ConnectionType","connectionType","Connection","autoEncrypter","CryptoConnection","connection","performInitialHandshake","then","error","destroy","force","checkSupportedServer","hello","_JSON$stringify","maxWireVersion","Number","minWireVersion","serverVersionHighEnough","isNaN","MIN_SUPPORTED_WIRE_VERSION","serverVersionLowEnough","MAX_SUPPORTED_WIRE_VERSION","message","concat","hostAddress","JSON","stringify","MAX_SUPPORTED_SERVER_VERSION","MongoCompatibilityError","MIN_SUPPORTED_SERVER_VERSION","_x","_x2","_performInitialHandshake","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","conn","credentials","authContext","handshakeDoc","handshakeOptions","start","response","supportedServerErr","resolvedCredentials","provider","wrap","_callee$","_context","prev","next","mechanism","MONGODB_DEFAULT","get","MongoInvalidArgumentError","AuthContext","prepareHandshakeDocument","sent","connectTimeoutMS","socketTimeoutMS","Date","getTime","commandAsync","ns","isWritablePrimary","LEGACY_HELLO_COMMAND","helloOk","loadBalanced","serviceId","lastHelloMS","arbiterOnly","resolveAuthMechanism","auth","t0","MongoError","addErrorLabel","MongoErrorLabel","HandshakeError","needsRetryableWriteLabel","RetryableWriteError","stop","_x3","_prepareHandshakeDocument","_callee2","_handshakeDoc","compressors","serverApi","_provider","_callee2$","_context2","_defineProperty","version","metadata","username","saslSupportedMechs","source","abrupt","prepare","LEGAL_TLS_SOCKET_OPTIONS","LEGAL_TCP_SOCKET_OPTIONS","parseConnectOptions","result","_iterator","_createForOfIteratorHelper","_step","s","n","done","name","value","e","f","socketPath","path","host","port","MongoRuntimeError","parseSslOptions","_iterator2","_step2","servername","isIP","SOCKET_ERROR_EVENT_LIST","SOCKET_ERROR_EVENTS","Set","_callback","_options$tls","_options$keepAlive","_ref","_options$socketTimeou","_options$noDelay","_options$connectTimeo","_options$rejectUnauth","_ref2","_options$keepAliveIni","useTLS","keepAlive","Reflect","noDelay","rejectUnauthorized","keepAliveInitialDelay","Math","round","ret","proxyHost","makeSocks5Connection","tlsSocket","disableRenegotiation","createConnection","setKeepAlive","setTimeout","setNoDelay","connectEvent","cancellationHandler","errorHandler","eventName","forEach","event","removeAllListeners","cancellationToken","removeListener","connectHandler","connectionFailureError","authorizationError","once","process","nextTick","_options$proxyHost","_options$proxyPort","HostAddress","fromHostPort","proxyPort","rawSocket","destination","SocksClient","existing_socket","timeout","command","proxy","type","userId","proxyUsername","password","proxyPassword","_ref3","MongoNetworkError","MongoNetworkTimeoutError"],"sources":["/home/salman/Documents/GitHub/FakeShop/node_modules/mongodb/src/cmap/connect.ts"],"sourcesContent":["import type { Socket, SocketConnectOpts } from 'net';\nimport * as net from 'net';\nimport { SocksClient } from 'socks';\nimport type { ConnectionOptions as TLSConnectionOpts, TLSSocket } from 'tls';\nimport * as tls from 'tls';\n\nimport type { Document } from '../bson';\nimport { LEGACY_HELLO_COMMAND } from '../constants';\nimport {\n  MongoCompatibilityError,\n  MongoError,\n  MongoErrorLabel,\n  MongoInvalidArgumentError,\n  MongoNetworkError,\n  MongoNetworkTimeoutError,\n  MongoRuntimeError,\n  needsRetryableWriteLabel\n} from '../error';\nimport { type Callback, HostAddress, ns } from '../utils';\nimport { AuthContext, type AuthProvider } from './auth/auth_provider';\nimport { GSSAPI } from './auth/gssapi';\nimport { MongoCR } from './auth/mongocr';\nimport { MongoDBAWS } from './auth/mongodb_aws';\nimport { MongoDBOIDC } from './auth/mongodb_oidc';\nimport { Plain } from './auth/plain';\nimport { AuthMechanism } from './auth/providers';\nimport { ScramSHA1, ScramSHA256 } from './auth/scram';\nimport { X509 } from './auth/x509';\nimport {\n  type CommandOptions,\n  Connection,\n  type ConnectionOptions,\n  CryptoConnection\n} from './connection';\nimport type { ClientMetadata } from './handshake/client_metadata';\nimport {\n  MAX_SUPPORTED_SERVER_VERSION,\n  MAX_SUPPORTED_WIRE_VERSION,\n  MIN_SUPPORTED_SERVER_VERSION,\n  MIN_SUPPORTED_WIRE_VERSION\n} from './wire_protocol/constants';\n\n/** @internal */\nexport const AUTH_PROVIDERS = new Map<AuthMechanism | string, AuthProvider>([\n  [AuthMechanism.MONGODB_AWS, new MongoDBAWS()],\n  [AuthMechanism.MONGODB_CR, new MongoCR()],\n  [AuthMechanism.MONGODB_GSSAPI, new GSSAPI()],\n  [AuthMechanism.MONGODB_OIDC, new MongoDBOIDC()],\n  [AuthMechanism.MONGODB_PLAIN, new Plain()],\n  [AuthMechanism.MONGODB_SCRAM_SHA1, new ScramSHA1()],\n  [AuthMechanism.MONGODB_SCRAM_SHA256, new ScramSHA256()],\n  [AuthMechanism.MONGODB_X509, new X509()]\n]);\n\n/** @public */\nexport type Stream = Socket | TLSSocket;\n\nexport function connect(options: ConnectionOptions, callback: Callback<Connection>): void {\n  makeConnection({ ...options, existingSocket: undefined }, (err, socket) => {\n    if (err || !socket) {\n      return callback(err);\n    }\n\n    let ConnectionType = options.connectionType ?? Connection;\n    if (options.autoEncrypter) {\n      ConnectionType = CryptoConnection;\n    }\n\n    const connection = new ConnectionType(socket, options);\n\n    performInitialHandshake(connection, options).then(\n      () => callback(undefined, connection),\n      error => {\n        connection.destroy({ force: false });\n        callback(error);\n      }\n    );\n  });\n}\n\nfunction checkSupportedServer(hello: Document, options: ConnectionOptions) {\n  const maxWireVersion = Number(hello.maxWireVersion);\n  const minWireVersion = Number(hello.minWireVersion);\n  const serverVersionHighEnough =\n    !Number.isNaN(maxWireVersion) && maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough =\n    !Number.isNaN(minWireVersion) && minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(\n      hello.minWireVersion\n    )}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n    return new MongoCompatibilityError(message);\n  }\n\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${\n    JSON.stringify(hello.maxWireVersion) ?? 0\n  }, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\n  return new MongoCompatibilityError(message);\n}\n\nasync function performInitialHandshake(\n  conn: Connection,\n  options: ConnectionOptions\n): Promise<void> {\n  const credentials = options.credentials;\n\n  if (credentials) {\n    if (\n      !(credentials.mechanism === AuthMechanism.MONGODB_DEFAULT) &&\n      !AUTH_PROVIDERS.get(credentials.mechanism)\n    ) {\n      throw new MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`);\n    }\n  }\n\n  const authContext = new AuthContext(conn, credentials, options);\n  conn.authContext = authContext;\n\n  const handshakeDoc = await prepareHandshakeDocument(authContext);\n\n  // @ts-expect-error: TODO(NODE-5141): The options need to be filtered properly, Connection options differ from Command options\n  const handshakeOptions: CommandOptions = { ...options };\n  if (typeof options.connectTimeoutMS === 'number') {\n    // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n    handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n  }\n\n  const start = new Date().getTime();\n  const response = await conn.commandAsync(ns('admin.$cmd'), handshakeDoc, handshakeOptions);\n\n  if (!('isWritablePrimary' in response)) {\n    // Provide hello-style response document.\n    response.isWritablePrimary = response[LEGACY_HELLO_COMMAND];\n  }\n\n  if (response.helloOk) {\n    conn.helloOk = true;\n  }\n\n  const supportedServerErr = checkSupportedServer(response, options);\n  if (supportedServerErr) {\n    throw supportedServerErr;\n  }\n\n  if (options.loadBalanced) {\n    if (!response.serviceId) {\n      throw new MongoCompatibilityError(\n        'Driver attempted to initialize in load balancing mode, ' +\n          'but the server does not support this mode.'\n      );\n    }\n  }\n\n  // NOTE: This is metadata attached to the connection while porting away from\n  //       handshake being done in the `Server` class. Likely, it should be\n  //       relocated, or at very least restructured.\n  conn.hello = response;\n  conn.lastHelloMS = new Date().getTime() - start;\n\n  if (!response.arbiterOnly && credentials) {\n    // store the response on auth context\n    authContext.response = response;\n\n    const resolvedCredentials = credentials.resolveAuthMechanism(response);\n    const provider = AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n    if (!provider) {\n      throw new MongoInvalidArgumentError(\n        `No AuthProvider for ${resolvedCredentials.mechanism} defined.`\n      );\n    }\n\n    try {\n      await provider.auth(authContext);\n    } catch (error) {\n      if (error instanceof MongoError) {\n        error.addErrorLabel(MongoErrorLabel.HandshakeError);\n        if (needsRetryableWriteLabel(error, response.maxWireVersion)) {\n          error.addErrorLabel(MongoErrorLabel.RetryableWriteError);\n        }\n      }\n      throw error;\n    }\n  }\n}\n\nexport interface HandshakeDocument extends Document {\n  /**\n   * @deprecated Use hello instead\n   */\n  ismaster?: boolean;\n  hello?: boolean;\n  helloOk?: boolean;\n  client: ClientMetadata;\n  compression: string[];\n  saslSupportedMechs?: string;\n  loadBalanced?: boolean;\n}\n\n/**\n * @internal\n *\n * This function is only exposed for testing purposes.\n */\nexport async function prepareHandshakeDocument(\n  authContext: AuthContext\n): Promise<HandshakeDocument> {\n  const options = authContext.options;\n  const compressors = options.compressors ? options.compressors : [];\n  const { serverApi } = authContext.connection;\n\n  const handshakeDoc: HandshakeDocument = {\n    [serverApi?.version ? 'hello' : LEGACY_HELLO_COMMAND]: 1,\n    helloOk: true,\n    client: options.metadata,\n    compression: compressors\n  };\n\n  if (options.loadBalanced === true) {\n    handshakeDoc.loadBalanced = true;\n  }\n\n  const credentials = authContext.credentials;\n  if (credentials) {\n    if (credentials.mechanism === AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n      handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n\n      const provider = AUTH_PROVIDERS.get(AuthMechanism.MONGODB_SCRAM_SHA256);\n      if (!provider) {\n        // This auth mechanism is always present.\n        throw new MongoInvalidArgumentError(\n          `No AuthProvider for ${AuthMechanism.MONGODB_SCRAM_SHA256} defined.`\n        );\n      }\n      return provider.prepare(handshakeDoc, authContext);\n    }\n    const provider = AUTH_PROVIDERS.get(credentials.mechanism);\n    if (!provider) {\n      throw new MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`);\n    }\n    return provider.prepare(handshakeDoc, authContext);\n  }\n  return handshakeDoc;\n}\n\n/** @public */\nexport const LEGAL_TLS_SOCKET_OPTIONS = [\n  'ALPNProtocols',\n  'ca',\n  'cert',\n  'checkServerIdentity',\n  'ciphers',\n  'crl',\n  'ecdhCurve',\n  'key',\n  'minDHSize',\n  'passphrase',\n  'pfx',\n  'rejectUnauthorized',\n  'secureContext',\n  'secureProtocol',\n  'servername',\n  'session'\n] as const;\n\n/** @public */\nexport const LEGAL_TCP_SOCKET_OPTIONS = [\n  'family',\n  'hints',\n  'localAddress',\n  'localPort',\n  'lookup'\n] as const;\n\nfunction parseConnectOptions(options: ConnectionOptions): SocketConnectOpts {\n  const hostAddress = options.hostAddress;\n  if (!hostAddress) throw new MongoInvalidArgumentError('Option \"hostAddress\" is required');\n\n  const result: Partial<net.TcpNetConnectOpts & net.IpcNetConnectOpts> = {};\n  for (const name of LEGAL_TCP_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      (result as Document)[name] = options[name];\n    }\n  }\n\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result as net.IpcNetConnectOpts;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result as net.TcpNetConnectOpts;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n  }\n}\n\ntype MakeConnectionOptions = ConnectionOptions & { existingSocket?: Stream };\n\nfunction parseSslOptions(options: MakeConnectionOptions): TLSConnectionOpts {\n  const result: TLSConnectionOpts = parseConnectOptions(options);\n  // Merge in valid SSL options\n  for (const name of LEGAL_TLS_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      (result as Document)[name] = options[name];\n    }\n  }\n\n  if (options.existingSocket) {\n    result.socket = options.existingSocket;\n  }\n\n  // Set default sni servername to be the same as host\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'] as const;\ntype ErrorHandlerEventName = (typeof SOCKET_ERROR_EVENT_LIST)[number] | 'cancel';\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\n\nfunction makeConnection(options: MakeConnectionOptions, _callback: Callback<Stream>) {\n  const useTLS = options.tls ?? false;\n  const keepAlive = options.keepAlive ?? true;\n  const socketTimeoutMS = options.socketTimeoutMS ?? Reflect.get(options, 'socketTimeout') ?? 0;\n  const noDelay = options.noDelay ?? true;\n  const connectTimeoutMS = options.connectTimeoutMS ?? 30000;\n  const rejectUnauthorized = options.rejectUnauthorized ?? true;\n  const keepAliveInitialDelay =\n    ((options.keepAliveInitialDelay ?? 120000) > socketTimeoutMS\n      ? Math.round(socketTimeoutMS / 2)\n      : options.keepAliveInitialDelay) ?? 120000;\n  const existingSocket = options.existingSocket;\n\n  let socket: Stream;\n  const callback: Callback<Stream> = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  if (options.proxyHost != null) {\n    // Currently, only Socks5 is supported.\n    return makeSocks5Connection(\n      {\n        ...options,\n        connectTimeoutMS // Should always be present for Socks5\n      },\n      callback\n    );\n  }\n\n  if (useTLS) {\n    const tlsSocket = tls.connect(parseSslOptions(options));\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n    socket = tlsSocket;\n  } else if (existingSocket) {\n    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\n    // so we only need to handle the non-TLS case here (where existingSocket\n    // gives us all we need out of the box).\n    socket = existingSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectTimeoutMS);\n  socket.setNoDelay(noDelay);\n\n  const connectEvent = useTLS ? 'secureConnect' : 'connect';\n  let cancellationHandler: (err: Error) => void;\n  function errorHandler(eventName: ErrorHandlerEventName) {\n    return (err: Error) => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n      if (cancellationHandler && options.cancellationToken) {\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n    if (cancellationHandler && options.cancellationToken) {\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if ('authorizationError' in socket) {\n      if (socket.authorizationError && rejectUnauthorized) {\n        // TODO(NODE-5192): wrap this with a MongoError subclass\n        return callback(socket.authorizationError);\n      }\n    }\n\n    socket.setTimeout(0);\n    callback(undefined, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n  if (options.cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    options.cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  if (existingSocket) {\n    process.nextTick(connectHandler);\n  } else {\n    socket.once(connectEvent, connectHandler);\n  }\n}\n\nfunction makeSocks5Connection(options: MakeConnectionOptions, callback: Callback<Stream>) {\n  const hostAddress = HostAddress.fromHostPort(\n    options.proxyHost ?? '', // proxyHost is guaranteed to set here\n    options.proxyPort ?? 1080\n  );\n\n  // First, connect to the proxy server itself:\n  makeConnection(\n    {\n      ...options,\n      hostAddress,\n      tls: false,\n      proxyHost: undefined\n    },\n    (err, rawSocket) => {\n      if (err) {\n        return callback(err);\n      }\n\n      const destination = parseConnectOptions(options) as net.TcpNetConnectOpts;\n      if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\n        return callback(\n          new MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts')\n        );\n      }\n\n      // Then, establish the Socks5 proxy connection:\n      SocksClient.createConnection({\n        existing_socket: rawSocket,\n        timeout: options.connectTimeoutMS,\n        command: 'connect',\n        destination: {\n          host: destination.host,\n          port: destination.port\n        },\n        proxy: {\n          // host and port are ignored because we pass existing_socket\n          host: 'iLoveJavaScript',\n          port: 0,\n          type: 5,\n          userId: options.proxyUsername || undefined,\n          password: options.proxyPassword || undefined\n        }\n      }).then(\n        ({ socket }) => {\n          // Finally, now treat the resulting duplex stream as the\n          // socket over which we send and receive wire protocol messages:\n          makeConnection(\n            {\n              ...options,\n              existingSocket: socket,\n              proxyHost: undefined\n            },\n            callback\n          );\n        },\n        error => callback(connectionFailureError('error', error))\n      );\n    }\n  );\n}\n\nfunction connectionFailureError(type: ErrorHandlerEventName, err: Error) {\n  switch (type) {\n    case 'error':\n      return new MongoNetworkError(err);\n    case 'timeout':\n      return new MongoNetworkTimeoutError('connection timed out');\n    case 'close':\n      return new MongoNetworkError('connection closed');\n    case 'cancel':\n      return new MongoNetworkError('connection establishment was cancelled');\n    default:\n      return new MongoNetworkError('unknown network error');\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}