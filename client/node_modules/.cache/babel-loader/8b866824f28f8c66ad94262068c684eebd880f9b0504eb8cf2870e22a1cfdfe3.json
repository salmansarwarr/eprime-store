{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IsCappedOperation = void 0;\nvar error_1 = require(\"../error\");\nvar operation_1 = require(\"./operation\");\n/** @internal */\nvar IsCappedOperation = /*#__PURE__*/function (_operation_1$Abstract) {\n  _inherits(IsCappedOperation, _operation_1$Abstract);\n  var _super = _createSuper(IsCappedOperation);\n  function IsCappedOperation(collection, options) {\n    var _this;\n    _classCallCheck(this, IsCappedOperation);\n    _this = _super.call(this, options);\n    _this.options = options;\n    _this.collection = collection;\n    return _this;\n  }\n  _createClass(IsCappedOperation, [{\n    key: \"executeCallback\",\n    value: function executeCallback(server, session, callback) {\n      var coll = this.collection;\n      coll.s.db.listCollections({\n        name: coll.collectionName\n      }, _objectSpread(_objectSpread({}, this.options), {}, {\n        nameOnly: false,\n        readPreference: this.readPreference,\n        session: session\n      })).toArray().then(function (collections) {\n        var _collections$0$option;\n        if (collections.length === 0) {\n          // TODO(NODE-3485)\n          return callback(new error_1.MongoAPIError(\"collection \".concat(coll.namespace, \" not found\")));\n        }\n        callback(undefined, !!((_collections$0$option = collections[0].options) !== null && _collections$0$option !== void 0 && _collections$0$option.capped));\n      }, function (error) {\n        return callback(error);\n      });\n    }\n  }]);\n  return IsCappedOperation;\n}(operation_1.AbstractCallbackOperation);\nexports.IsCappedOperation = IsCappedOperation;","map":{"version":3,"names":["error_1","require","operation_1","IsCappedOperation","_operation_1$Abstract","_inherits","_super","_createSuper","collection","options","_this","_classCallCheck","call","_createClass","key","value","executeCallback","server","session","callback","coll","s","db","listCollections","name","collectionName","_objectSpread","nameOnly","readPreference","toArray","then","collections","_collections$0$option","length","MongoAPIError","concat","namespace","undefined","capped","error","AbstractCallbackOperation","exports"],"sources":["/home/salman/Documents/GitHub/FakeShop/node_modules/mongodb/src/operations/is_capped.ts"],"sourcesContent":["import type { Collection } from '../collection';\nimport { MongoAPIError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport type { Callback } from '../utils';\nimport { AbstractCallbackOperation, type OperationOptions } from './operation';\n\n/** @internal */\nexport class IsCappedOperation extends AbstractCallbackOperation<boolean> {\n  override options: OperationOptions;\n  collection: Collection;\n\n  constructor(collection: Collection, options: OperationOptions) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n  }\n\n  override executeCallback(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<boolean>\n  ): void {\n    const coll = this.collection;\n\n    coll.s.db\n      .listCollections(\n        { name: coll.collectionName },\n        { ...this.options, nameOnly: false, readPreference: this.readPreference, session }\n      )\n      .toArray()\n      .then(\n        collections => {\n          if (collections.length === 0) {\n            // TODO(NODE-3485)\n            return callback(new MongoAPIError(`collection ${coll.namespace} not found`));\n          }\n\n          callback(undefined, !!collections[0].options?.capped);\n        },\n        error => callback(error)\n      );\n  }\n}\n"],"mappings":";;;;;;;;;;;AACA,IAAAA,OAAA,GAAAC,OAAA;AAIA,IAAAC,WAAA,GAAAD,OAAA;AAEA;AAAA,IACaE,iBAAkB,0BAAAC,qBAAA;EAAAC,SAAA,CAAAF,iBAAA,EAAAC,qBAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,iBAAA;EAI7B,SAAAA,kBAAYK,UAAsB,EAAEC,OAAyB;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAR,iBAAA;IAC3DO,KAAA,GAAAJ,MAAA,CAAAM,IAAA,OAAMH,OAAO;IACbC,KAAA,CAAKD,OAAO,GAAGA,OAAO;IACtBC,KAAA,CAAKF,UAAU,GAAGA,UAAU;IAAC,OAAAE,KAAA;EAC/B;EAACG,YAAA,CAAAV,iBAAA;IAAAW,GAAA;IAAAC,KAAA,EAEQ,SAAAC,gBACPC,MAAc,EACdC,OAAkC,EAClCC,QAA2B;MAE3B,IAAMC,IAAI,GAAG,IAAI,CAACZ,UAAU;MAE5BY,IAAI,CAACC,CAAC,CAACC,EAAE,CACNC,eAAe,CACd;QAAEC,IAAI,EAAEJ,IAAI,CAACK;MAAc,CAAE,EAAAC,aAAA,CAAAA,aAAA,KACxB,IAAI,CAACjB,OAAO;QAAEkB,QAAQ,EAAE,KAAK;QAAEC,cAAc,EAAE,IAAI,CAACA,cAAc;QAAEV,OAAO,EAAPA;MAAO,EAAE,CACnF,CACAW,OAAO,EAAE,CACTC,IAAI,CACH,UAAAC,WAAW,EAAG;QAAA,IAAAC,qBAAA;QACZ,IAAID,WAAW,CAACE,MAAM,KAAK,CAAC,EAAE;UAC5B;UACA,OAAOd,QAAQ,CAAC,IAAInB,OAAA,CAAAkC,aAAa,eAAAC,MAAA,CAAef,IAAI,CAACgB,SAAS,eAAY,CAAC,CAAC;;QAG9EjB,QAAQ,CAACkB,SAAS,EAAE,CAAC,GAAAL,qBAAA,GAACD,WAAW,CAAC,CAAC,CAAC,CAACtB,OAAO,cAAAuB,qBAAA,eAAtBA,qBAAA,CAAwBM,MAAM,EAAC;MACvD,CAAC,EACD,UAAAC,KAAK;QAAA,OAAIpB,QAAQ,CAACoB,KAAK,CAAC;MAAA,EACzB;IACL;EAAC;EAAA,OAAApC,iBAAA;AAAA,EAlCoCD,WAAA,CAAAsC,yBAAkC;AAAzEC,OAAA,CAAAtC,iBAAA,GAAAA,iBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}