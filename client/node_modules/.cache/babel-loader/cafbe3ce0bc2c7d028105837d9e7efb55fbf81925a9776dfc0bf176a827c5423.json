{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isSharded = exports.getReadPreference = void 0;\nvar error_1 = require(\"../../error\");\nvar read_preference_1 = require(\"../../read_preference\");\nvar common_1 = require(\"../../sdam/common\");\nvar topology_description_1 = require(\"../../sdam/topology_description\");\nfunction getReadPreference(options) {\n  var _options$readPreferen;\n  // Default to command version of the readPreference\n  var readPreference = (_options$readPreferen = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _options$readPreferen !== void 0 ? _options$readPreferen : read_preference_1.ReadPreference.primary;\n  // If we have an option readPreference override the command one\n  if (options !== null && options !== void 0 && options.readPreference) {\n    readPreference = options.readPreference;\n  }\n  if (typeof readPreference === 'string') {\n    readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n  }\n  if (!(readPreference instanceof read_preference_1.ReadPreference)) {\n    throw new error_1.MongoInvalidArgumentError('Option \"readPreference\" must be a ReadPreference instance');\n  }\n  return readPreference;\n}\nexports.getReadPreference = getReadPreference;\nfunction isSharded(topologyOrServer) {\n  if (topologyOrServer == null) {\n    return false;\n  }\n  if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {\n    return true;\n  }\n  // NOTE: This is incredibly inefficient, and should be removed once command construction\n  //       happens based on `Server` not `Topology`.\n  if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {\n    var servers = Array.from(topologyOrServer.description.servers.values());\n    return servers.some(function (server) {\n      return server.type === common_1.ServerType.Mongos;\n    });\n  }\n  return false;\n}\nexports.isSharded = isSharded;","map":{"version":3,"names":["error_1","require","read_preference_1","common_1","topology_description_1","getReadPreference","options","_options$readPreferen","readPreference","ReadPreference","primary","fromString","MongoInvalidArgumentError","exports","isSharded","topologyOrServer","description","type","ServerType","Mongos","TopologyDescription","servers","Array","from","values","some","server"],"sources":["/home/salman/Documents/GitHub/FakeShop/node_modules/mongodb/src/cmap/wire_protocol/shared.ts"],"sourcesContent":["import { MongoInvalidArgumentError } from '../../error';\nimport type { ReadPreferenceLike } from '../../read_preference';\nimport { ReadPreference } from '../../read_preference';\nimport { ServerType } from '../../sdam/common';\nimport type { Server } from '../../sdam/server';\nimport type { ServerDescription } from '../../sdam/server_description';\nimport type { Topology } from '../../sdam/topology';\nimport { TopologyDescription } from '../../sdam/topology_description';\nimport type { Connection } from '../connection';\n\nexport interface ReadPreferenceOption {\n  readPreference?: ReadPreferenceLike;\n}\n\nexport function getReadPreference(options?: ReadPreferenceOption): ReadPreference {\n  // Default to command version of the readPreference\n  let readPreference = options?.readPreference ?? ReadPreference.primary;\n  // If we have an option readPreference override the command one\n  if (options?.readPreference) {\n    readPreference = options.readPreference;\n  }\n\n  if (typeof readPreference === 'string') {\n    readPreference = ReadPreference.fromString(readPreference);\n  }\n\n  if (!(readPreference instanceof ReadPreference)) {\n    throw new MongoInvalidArgumentError(\n      'Option \"readPreference\" must be a ReadPreference instance'\n    );\n  }\n\n  return readPreference;\n}\n\nexport function isSharded(topologyOrServer?: Topology | Server | Connection): boolean {\n  if (topologyOrServer == null) {\n    return false;\n  }\n\n  if (topologyOrServer.description && topologyOrServer.description.type === ServerType.Mongos) {\n    return true;\n  }\n\n  // NOTE: This is incredibly inefficient, and should be removed once command construction\n  //       happens based on `Server` not `Topology`.\n  if (topologyOrServer.description && topologyOrServer.description instanceof TopologyDescription) {\n    const servers: ServerDescription[] = Array.from(topologyOrServer.description.servers.values());\n    return servers.some((server: ServerDescription) => server.type === ServerType.Mongos);\n  }\n\n  return false;\n}\n"],"mappings":";;;;;;AAAA,IAAAA,OAAA,GAAAC,OAAA;AAEA,IAAAC,iBAAA,GAAAD,OAAA;AACA,IAAAE,QAAA,GAAAF,OAAA;AAIA,IAAAG,sBAAA,GAAAH,OAAA;AAOA,SAAgBI,iBAAiBA,CAACC,OAA8B;EAAA,IAAAC,qBAAA;EAC9D;EACA,IAAIC,cAAc,IAAAD,qBAAA,GAAGD,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEE,cAAc,cAAAD,qBAAA,cAAAA,qBAAA,GAAIL,iBAAA,CAAAO,cAAc,CAACC,OAAO;EACtE;EACA,IAAIJ,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAEE,cAAc,EAAE;IAC3BA,cAAc,GAAGF,OAAO,CAACE,cAAc;;EAGzC,IAAI,OAAOA,cAAc,KAAK,QAAQ,EAAE;IACtCA,cAAc,GAAGN,iBAAA,CAAAO,cAAc,CAACE,UAAU,CAACH,cAAc,CAAC;;EAG5D,IAAI,EAAEA,cAAc,YAAYN,iBAAA,CAAAO,cAAc,CAAC,EAAE;IAC/C,MAAM,IAAIT,OAAA,CAAAY,yBAAyB,CACjC,2DAA2D,CAC5D;;EAGH,OAAOJ,cAAc;AACvB;AAnBAK,OAAA,CAAAR,iBAAA,GAAAA,iBAAA;AAqBA,SAAgBS,SAASA,CAACC,gBAAiD;EACzE,IAAIA,gBAAgB,IAAI,IAAI,EAAE;IAC5B,OAAO,KAAK;;EAGd,IAAIA,gBAAgB,CAACC,WAAW,IAAID,gBAAgB,CAACC,WAAW,CAACC,IAAI,KAAKd,QAAA,CAAAe,UAAU,CAACC,MAAM,EAAE;IAC3F,OAAO,IAAI;;EAGb;EACA;EACA,IAAIJ,gBAAgB,CAACC,WAAW,IAAID,gBAAgB,CAACC,WAAW,YAAYZ,sBAAA,CAAAgB,mBAAmB,EAAE;IAC/F,IAAMC,OAAO,GAAwBC,KAAK,CAACC,IAAI,CAACR,gBAAgB,CAACC,WAAW,CAACK,OAAO,CAACG,MAAM,EAAE,CAAC;IAC9F,OAAOH,OAAO,CAACI,IAAI,CAAC,UAACC,MAAyB;MAAA,OAAKA,MAAM,CAACT,IAAI,KAAKd,QAAA,CAAAe,UAAU,CAACC,MAAM;IAAA,EAAC;;EAGvF,OAAO,KAAK;AACd;AAjBAN,OAAA,CAAAC,SAAA,GAAAA,SAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}