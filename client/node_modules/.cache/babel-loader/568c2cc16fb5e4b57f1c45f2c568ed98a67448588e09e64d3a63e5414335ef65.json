{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallbackWorkflow = void 0;\nvar bson_1 = require(\"bson\");\nvar error_1 = require(\"../../../error\");\nvar utils_1 = require(\"../../../utils\");\nvar providers_1 = require(\"../providers\");\nvar callback_lock_cache_1 = require(\"./callback_lock_cache\");\nvar token_entry_cache_1 = require(\"./token_entry_cache\");\n/** The current version of OIDC implementation. */\nvar OIDC_VERSION = 0;\n/** 5 minutes in seconds */\nvar TIMEOUT_S = 300;\n/** Properties allowed on results of callbacks. */\nvar RESULT_PROPERTIES = ['accessToken', 'expiresInSeconds', 'refreshToken'];\n/** Error message when the callback result is invalid. */\nvar CALLBACK_RESULT_ERROR = 'User provided OIDC callbacks must return a valid object with an accessToken.';\n/**\n * OIDC implementation of a callback based workflow.\n * @internal\n */\nvar CallbackWorkflow = /*#__PURE__*/function () {\n  /**\n   * Instantiate the workflow\n   */\n  function CallbackWorkflow() {\n    _classCallCheck(this, CallbackWorkflow);\n    this.cache = new token_entry_cache_1.TokenEntryCache();\n    this.callbackCache = new callback_lock_cache_1.CallbackLockCache();\n  }\n  /**\n   * Get the document to add for speculative authentication. This also needs\n   * to add a db field from the credentials source.\n   */\n  _createClass(CallbackWorkflow, [{\n    key: \"speculativeAuth\",\n    value: function () {\n      var _speculativeAuth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(credentials) {\n        var document;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              document = startCommandDocument(credentials);\n              document.db = credentials.source;\n              return _context.abrupt(\"return\", {\n                speculativeAuthenticate: document\n              });\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      function speculativeAuth(_x) {\n        return _speculativeAuth.apply(this, arguments);\n      }\n      return speculativeAuth;\n    }()\n    /**\n     * Execute the OIDC callback workflow.\n     */\n  }, {\n    key: \"execute\",\n    value: function () {\n      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(connection, credentials, reauthenticating, response) {\n        var _this$callbackCache$g, requestCallback, refreshCallback, callbackHash, entry, result, _response$speculative, tokenResult, _response$speculative2, startDocument, conversationId, serverResult, _tokenResult;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              // Get the callbacks with locks from the callback lock cache.\n              _this$callbackCache$g = this.callbackCache.getEntry(connection, credentials), requestCallback = _this$callbackCache$g.requestCallback, refreshCallback = _this$callbackCache$g.refreshCallback, callbackHash = _this$callbackCache$g.callbackHash; // Look for an existing entry in the cache.\n              entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);\n              if (!entry) {\n                _context2.next = 30;\n                break;\n              }\n              if (!(entry.isValid() && !reauthenticating)) {\n                _context2.next = 9;\n                break;\n              }\n              _context2.next = 6;\n              return this.finishAuthentication(connection, credentials, entry.tokenResult, response === null || response === void 0 || (_response$speculative = response.speculativeAuthenticate) === null || _response$speculative === void 0 ? void 0 : _response$speculative.conversationId);\n            case 6:\n              result = _context2.sent;\n              _context2.next = 28;\n              break;\n            case 9:\n              _context2.next = 11;\n              return this.fetchAccessToken(connection, credentials, entry.serverInfo, reauthenticating, callbackHash, requestCallback, refreshCallback);\n            case 11:\n              tokenResult = _context2.sent;\n              _context2.prev = 12;\n              _context2.next = 15;\n              return this.finishAuthentication(connection, credentials, tokenResult, reauthenticating ? undefined : response === null || response === void 0 || (_response$speculative2 = response.speculativeAuthenticate) === null || _response$speculative2 === void 0 ? void 0 : _response$speculative2.conversationId);\n            case 15:\n              result = _context2.sent;\n              _context2.next = 28;\n              break;\n            case 18:\n              _context2.prev = 18;\n              _context2.t0 = _context2[\"catch\"](12);\n              if (!(reauthenticating && _context2.t0 instanceof error_1.MongoError && _context2.t0.code === error_1.MONGODB_ERROR_CODES.Reauthenticate)) {\n                _context2.next = 27;\n                break;\n              }\n              this.cache.deleteEntry(connection.address, credentials.username, callbackHash);\n              _context2.next = 24;\n              return this.execute(connection, credentials, reauthenticating);\n            case 24:\n              result = _context2.sent;\n              _context2.next = 28;\n              break;\n            case 27:\n              throw _context2.t0;\n            case 28:\n              _context2.next = 41;\n              break;\n            case 30:\n              _context2.next = 32;\n              return this.startAuthentication(connection, credentials, reauthenticating, response);\n            case 32:\n              startDocument = _context2.sent;\n              conversationId = startDocument.conversationId;\n              serverResult = bson_1.BSON.deserialize(startDocument.payload.buffer);\n              _context2.next = 37;\n              return this.fetchAccessToken(connection, credentials, serverResult, reauthenticating, callbackHash, requestCallback, refreshCallback);\n            case 37:\n              _tokenResult = _context2.sent;\n              _context2.next = 40;\n              return this.finishAuthentication(connection, credentials, _tokenResult, conversationId);\n            case 40:\n              result = _context2.sent;\n            case 41:\n              return _context2.abrupt(\"return\", result);\n            case 42:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[12, 18]]);\n      }));\n      function execute(_x2, _x3, _x4, _x5) {\n        return _execute.apply(this, arguments);\n      }\n      return execute;\n    }()\n    /**\n     * Starts the callback authentication process. If there is a speculative\n     * authentication document from the initial handshake, then we will use that\n     * value to get the issuer, otherwise we will send the saslStart command.\n     */\n  }, {\n    key: \"startAuthentication\",\n    value: function () {\n      var _startAuthentication = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(connection, credentials, reauthenticating, response) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!(!reauthenticating && response !== null && response !== void 0 && response.speculativeAuthenticate)) {\n                _context3.next = 4;\n                break;\n              }\n              result = response.speculativeAuthenticate;\n              _context3.next = 7;\n              break;\n            case 4:\n              _context3.next = 6;\n              return connection.commandAsync((0, utils_1.ns)(credentials.source), startCommandDocument(credentials), undefined);\n            case 6:\n              result = _context3.sent;\n            case 7:\n              return _context3.abrupt(\"return\", result);\n            case 8:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }));\n      function startAuthentication(_x6, _x7, _x8, _x9) {\n        return _startAuthentication.apply(this, arguments);\n      }\n      return startAuthentication;\n    }()\n    /**\n     * Finishes the callback authentication process.\n     */\n  }, {\n    key: \"finishAuthentication\",\n    value: function () {\n      var _finishAuthentication = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(connection, credentials, tokenResult, conversationId) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return connection.commandAsync((0, utils_1.ns)(credentials.source), finishCommandDocument(tokenResult.accessToken, conversationId), undefined);\n            case 2:\n              result = _context4.sent;\n              return _context4.abrupt(\"return\", result);\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }));\n      function finishAuthentication(_x10, _x11, _x12, _x13) {\n        return _finishAuthentication.apply(this, arguments);\n      }\n      return finishAuthentication;\n    }()\n    /**\n     * Fetches an access token using either the request or refresh callbacks and\n     * puts it in the cache.\n     */\n  }, {\n    key: \"fetchAccessToken\",\n    value: function () {\n      var _fetchAccessToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(connection, credentials, serverInfo, reauthenticating, callbackHash, requestCallback, refreshCallback) {\n        var entry, result, context;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              // Get the token from the cache.\n              entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);\n              context = {\n                timeoutSeconds: TIMEOUT_S,\n                version: OIDC_VERSION\n              }; // Check if there's a token in the cache.\n              if (!entry) {\n                _context5.next = 17;\n                break;\n              }\n              if (!(entry.isValid() && !reauthenticating)) {\n                _context5.next = 5;\n                break;\n              }\n              return _context5.abrupt(\"return\", entry.tokenResult);\n            case 5:\n              if (!refreshCallback) {\n                _context5.next = 12;\n                break;\n              }\n              context.refreshToken = entry.tokenResult.refreshToken;\n              _context5.next = 9;\n              return refreshCallback(serverInfo, context);\n            case 9:\n              result = _context5.sent;\n              _context5.next = 15;\n              break;\n            case 12:\n              _context5.next = 14;\n              return requestCallback(serverInfo, context);\n            case 14:\n              result = _context5.sent;\n            case 15:\n              _context5.next = 20;\n              break;\n            case 17:\n              _context5.next = 19;\n              return requestCallback(serverInfo, context);\n            case 19:\n              result = _context5.sent;\n            case 20:\n              if (!isCallbackResultInvalid(result)) {\n                _context5.next = 23;\n                break;\n              }\n              this.cache.deleteEntry(connection.address, credentials.username, callbackHash);\n              throw new error_1.MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);\n            case 23:\n              // Cleanup the cache.\n              this.cache.deleteExpiredEntries();\n              // Put the new entry into the cache.\n              this.cache.addEntry(connection.address, credentials.username || '', callbackHash, result, serverInfo);\n              return _context5.abrupt(\"return\", result);\n            case 26:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function fetchAccessToken(_x14, _x15, _x16, _x17, _x18, _x19, _x20) {\n        return _fetchAccessToken.apply(this, arguments);\n      }\n      return fetchAccessToken;\n    }()\n  }]);\n  return CallbackWorkflow;\n}();\nexports.CallbackWorkflow = CallbackWorkflow;\n/**\n * Generate the finishing command document for authentication. Will be a\n * saslStart or saslContinue depending on the presence of a conversation id.\n */\nfunction finishCommandDocument(token, conversationId) {\n  if (conversationId != null && typeof conversationId === 'number') {\n    return {\n      saslContinue: 1,\n      conversationId: conversationId,\n      payload: new bson_1.Binary(bson_1.BSON.serialize({\n        jwt: token\n      }))\n    };\n  }\n  // saslContinue requires a conversationId in the command to be valid so in this\n  // case the server allows \"step two\" to actually be a saslStart with the token\n  // as the jwt since the use of the cached value has no correlating conversating\n  // on the particular connection.\n  return {\n    saslStart: 1,\n    mechanism: providers_1.AuthMechanism.MONGODB_OIDC,\n    payload: new bson_1.Binary(bson_1.BSON.serialize({\n      jwt: token\n    }))\n  };\n}\n/**\n * Determines if a result returned from a request or refresh callback\n * function is invalid. This means the result is nullish, doesn't contain\n * the accessToken required field, and does not contain extra fields.\n */\nfunction isCallbackResultInvalid(tokenResult) {\n  if (tokenResult == null || typeof tokenResult !== 'object') return true;\n  if (!('accessToken' in tokenResult)) return true;\n  return !Object.getOwnPropertyNames(tokenResult).every(function (prop) {\n    return RESULT_PROPERTIES.includes(prop);\n  });\n}\n/**\n * Generate the saslStart command document.\n */\nfunction startCommandDocument(credentials) {\n  var payload = {};\n  if (credentials.username) {\n    payload.n = credentials.username;\n  }\n  return {\n    saslStart: 1,\n    autoAuthorize: 1,\n    mechanism: providers_1.AuthMechanism.MONGODB_OIDC,\n    payload: new bson_1.Binary(bson_1.BSON.serialize(payload))\n  };\n}","map":{"version":3,"names":["bson_1","require","error_1","utils_1","providers_1","callback_lock_cache_1","token_entry_cache_1","OIDC_VERSION","TIMEOUT_S","RESULT_PROPERTIES","CALLBACK_RESULT_ERROR","CallbackWorkflow","_classCallCheck","cache","TokenEntryCache","callbackCache","CallbackLockCache","_createClass","key","value","_speculativeAuth","_asyncToGenerator","_regeneratorRuntime","mark","_callee","credentials","document","wrap","_callee$","_context","prev","next","startCommandDocument","db","source","abrupt","speculativeAuthenticate","stop","speculativeAuth","_x","apply","arguments","_execute","_callee2","connection","reauthenticating","response","_this$callbackCache$g","requestCallback","refreshCallback","callbackHash","entry","result","_response$speculative","tokenResult","_response$speculative2","startDocument","conversationId","serverResult","_tokenResult","_callee2$","_context2","getEntry","address","username","isValid","finishAuthentication","sent","fetchAccessToken","serverInfo","undefined","t0","MongoError","code","MONGODB_ERROR_CODES","Reauthenticate","deleteEntry","execute","startAuthentication","BSON","deserialize","payload","buffer","_x2","_x3","_x4","_x5","_startAuthentication","_callee3","_callee3$","_context3","commandAsync","ns","_x6","_x7","_x8","_x9","_finishAuthentication","_callee4","_callee4$","_context4","finishCommandDocument","accessToken","_x10","_x11","_x12","_x13","_fetchAccessToken","_callee5","context","_callee5$","_context5","timeoutSeconds","version","refreshToken","isCallbackResultInvalid","MongoMissingCredentialsError","deleteExpiredEntries","addEntry","_x14","_x15","_x16","_x17","_x18","_x19","_x20","exports","token","saslContinue","Binary","serialize","jwt","saslStart","mechanism","AuthMechanism","MONGODB_OIDC","Object","getOwnPropertyNames","every","prop","includes","n","autoAuthorize"],"sources":["/home/salman/Documents/GitHub/FakeShop/node_modules/mongodb/src/cmap/auth/mongodb_oidc/callback_workflow.ts"],"sourcesContent":["import { Binary, BSON, type Document } from 'bson';\n\nimport { MONGODB_ERROR_CODES, MongoError, MongoMissingCredentialsError } from '../../../error';\nimport { ns } from '../../../utils';\nimport type { Connection } from '../../connection';\nimport type { MongoCredentials } from '../mongo_credentials';\nimport type {\n  IdPServerInfo,\n  IdPServerResponse,\n  OIDCCallbackContext,\n  OIDCRefreshFunction,\n  OIDCRequestFunction,\n  Workflow\n} from '../mongodb_oidc';\nimport { AuthMechanism } from '../providers';\nimport { CallbackLockCache } from './callback_lock_cache';\nimport { TokenEntryCache } from './token_entry_cache';\n\n/** The current version of OIDC implementation. */\nconst OIDC_VERSION = 0;\n\n/** 5 minutes in seconds */\nconst TIMEOUT_S = 300;\n\n/** Properties allowed on results of callbacks. */\nconst RESULT_PROPERTIES = ['accessToken', 'expiresInSeconds', 'refreshToken'];\n\n/** Error message when the callback result is invalid. */\nconst CALLBACK_RESULT_ERROR =\n  'User provided OIDC callbacks must return a valid object with an accessToken.';\n\n/**\n * OIDC implementation of a callback based workflow.\n * @internal\n */\nexport class CallbackWorkflow implements Workflow {\n  cache: TokenEntryCache;\n  callbackCache: CallbackLockCache;\n\n  /**\n   * Instantiate the workflow\n   */\n  constructor() {\n    this.cache = new TokenEntryCache();\n    this.callbackCache = new CallbackLockCache();\n  }\n\n  /**\n   * Get the document to add for speculative authentication. This also needs\n   * to add a db field from the credentials source.\n   */\n  async speculativeAuth(credentials: MongoCredentials): Promise<Document> {\n    const document = startCommandDocument(credentials);\n    document.db = credentials.source;\n    return { speculativeAuthenticate: document };\n  }\n\n  /**\n   * Execute the OIDC callback workflow.\n   */\n  async execute(\n    connection: Connection,\n    credentials: MongoCredentials,\n    reauthenticating: boolean,\n    response?: Document\n  ): Promise<Document> {\n    // Get the callbacks with locks from the callback lock cache.\n    const { requestCallback, refreshCallback, callbackHash } = this.callbackCache.getEntry(\n      connection,\n      credentials\n    );\n    // Look for an existing entry in the cache.\n    const entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);\n    let result;\n    if (entry) {\n      // Reauthentication cannot use a token from the cache since the server has\n      // stated it is invalid by the request for reauthentication.\n      if (entry.isValid() && !reauthenticating) {\n        // Presence of a valid cache entry means we can skip to the finishing step.\n        result = await this.finishAuthentication(\n          connection,\n          credentials,\n          entry.tokenResult,\n          response?.speculativeAuthenticate?.conversationId\n        );\n      } else {\n        // Presence of an expired cache entry means we must fetch a new one and\n        // then execute the final step.\n        const tokenResult = await this.fetchAccessToken(\n          connection,\n          credentials,\n          entry.serverInfo,\n          reauthenticating,\n          callbackHash,\n          requestCallback,\n          refreshCallback\n        );\n        try {\n          result = await this.finishAuthentication(\n            connection,\n            credentials,\n            tokenResult,\n            reauthenticating ? undefined : response?.speculativeAuthenticate?.conversationId\n          );\n        } catch (error) {\n          // If we are reauthenticating and this errors with reauthentication\n          // required, we need to do the entire process over again and clear\n          // the cache entry.\n          if (\n            reauthenticating &&\n            error instanceof MongoError &&\n            error.code === MONGODB_ERROR_CODES.Reauthenticate\n          ) {\n            this.cache.deleteEntry(connection.address, credentials.username, callbackHash);\n            result = await this.execute(connection, credentials, reauthenticating);\n          } else {\n            throw error;\n          }\n        }\n      }\n    } else {\n      // No entry in the cache requires us to do all authentication steps\n      // from start to finish, including getting a fresh token for the cache.\n      const startDocument = await this.startAuthentication(\n        connection,\n        credentials,\n        reauthenticating,\n        response\n      );\n      const conversationId = startDocument.conversationId;\n      const serverResult = BSON.deserialize(startDocument.payload.buffer) as IdPServerInfo;\n      const tokenResult = await this.fetchAccessToken(\n        connection,\n        credentials,\n        serverResult,\n        reauthenticating,\n        callbackHash,\n        requestCallback,\n        refreshCallback\n      );\n      result = await this.finishAuthentication(\n        connection,\n        credentials,\n        tokenResult,\n        conversationId\n      );\n    }\n    return result;\n  }\n\n  /**\n   * Starts the callback authentication process. If there is a speculative\n   * authentication document from the initial handshake, then we will use that\n   * value to get the issuer, otherwise we will send the saslStart command.\n   */\n  private async startAuthentication(\n    connection: Connection,\n    credentials: MongoCredentials,\n    reauthenticating: boolean,\n    response?: Document\n  ): Promise<Document> {\n    let result;\n    if (!reauthenticating && response?.speculativeAuthenticate) {\n      result = response.speculativeAuthenticate;\n    } else {\n      result = await connection.commandAsync(\n        ns(credentials.source),\n        startCommandDocument(credentials),\n        undefined\n      );\n    }\n    return result;\n  }\n\n  /**\n   * Finishes the callback authentication process.\n   */\n  private async finishAuthentication(\n    connection: Connection,\n    credentials: MongoCredentials,\n    tokenResult: IdPServerResponse,\n    conversationId?: number\n  ): Promise<Document> {\n    const result = await connection.commandAsync(\n      ns(credentials.source),\n      finishCommandDocument(tokenResult.accessToken, conversationId),\n      undefined\n    );\n    return result;\n  }\n\n  /**\n   * Fetches an access token using either the request or refresh callbacks and\n   * puts it in the cache.\n   */\n  private async fetchAccessToken(\n    connection: Connection,\n    credentials: MongoCredentials,\n    serverInfo: IdPServerInfo,\n    reauthenticating: boolean,\n    callbackHash: string,\n    requestCallback: OIDCRequestFunction,\n    refreshCallback?: OIDCRefreshFunction\n  ): Promise<IdPServerResponse> {\n    // Get the token from the cache.\n    const entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);\n    let result;\n    const context: OIDCCallbackContext = { timeoutSeconds: TIMEOUT_S, version: OIDC_VERSION };\n    // Check if there's a token in the cache.\n    if (entry) {\n      // If the cache entry is valid, return the token result.\n      if (entry.isValid() && !reauthenticating) {\n        return entry.tokenResult;\n      }\n      // If the cache entry is not valid, remove it from the cache and first attempt\n      // to use the refresh callback to get a new token. If no refresh callback\n      // exists, then fallback to the request callback.\n      if (refreshCallback) {\n        context.refreshToken = entry.tokenResult.refreshToken;\n        result = await refreshCallback(serverInfo, context);\n      } else {\n        result = await requestCallback(serverInfo, context);\n      }\n    } else {\n      // With no token in the cache we use the request callback.\n      result = await requestCallback(serverInfo, context);\n    }\n    // Validate that the result returned by the callback is acceptable. If it is not\n    // we must clear the token result from the cache.\n    if (isCallbackResultInvalid(result)) {\n      this.cache.deleteEntry(connection.address, credentials.username, callbackHash);\n      throw new MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);\n    }\n    // Cleanup the cache.\n    this.cache.deleteExpiredEntries();\n    // Put the new entry into the cache.\n    this.cache.addEntry(\n      connection.address,\n      credentials.username || '',\n      callbackHash,\n      result,\n      serverInfo\n    );\n    return result;\n  }\n}\n\n/**\n * Generate the finishing command document for authentication. Will be a\n * saslStart or saslContinue depending on the presence of a conversation id.\n */\nfunction finishCommandDocument(token: string, conversationId?: number): Document {\n  if (conversationId != null && typeof conversationId === 'number') {\n    return {\n      saslContinue: 1,\n      conversationId: conversationId,\n      payload: new Binary(BSON.serialize({ jwt: token }))\n    };\n  }\n  // saslContinue requires a conversationId in the command to be valid so in this\n  // case the server allows \"step two\" to actually be a saslStart with the token\n  // as the jwt since the use of the cached value has no correlating conversating\n  // on the particular connection.\n  return {\n    saslStart: 1,\n    mechanism: AuthMechanism.MONGODB_OIDC,\n    payload: new Binary(BSON.serialize({ jwt: token }))\n  };\n}\n\n/**\n * Determines if a result returned from a request or refresh callback\n * function is invalid. This means the result is nullish, doesn't contain\n * the accessToken required field, and does not contain extra fields.\n */\nfunction isCallbackResultInvalid(tokenResult: unknown): boolean {\n  if (tokenResult == null || typeof tokenResult !== 'object') return true;\n  if (!('accessToken' in tokenResult)) return true;\n  return !Object.getOwnPropertyNames(tokenResult).every(prop => RESULT_PROPERTIES.includes(prop));\n}\n\n/**\n * Generate the saslStart command document.\n */\nfunction startCommandDocument(credentials: MongoCredentials): Document {\n  const payload: Document = {};\n  if (credentials.username) {\n    payload.n = credentials.username;\n  }\n  return {\n    saslStart: 1,\n    autoAuthorize: 1,\n    mechanism: AuthMechanism.MONGODB_OIDC,\n    payload: new Binary(BSON.serialize(payload))\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}