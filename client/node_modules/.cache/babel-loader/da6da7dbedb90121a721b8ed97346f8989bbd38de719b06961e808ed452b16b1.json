{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _objectSpread = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _assertThisInitialized = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _inherits = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConnectionPool = exports.PoolState = void 0;\nvar timers_1 = require(\"timers\");\nvar constants_1 = require(\"../constants\");\nvar error_1 = require(\"../error\");\nvar mongo_types_1 = require(\"../mongo_types\");\nvar utils_1 = require(\"../utils\");\nvar connect_1 = require(\"./connect\");\nvar connection_1 = require(\"./connection\");\nvar connection_pool_events_1 = require(\"./connection_pool_events\");\nvar errors_1 = require(\"./errors\");\nvar metrics_1 = require(\"./metrics\");\n/** @internal */\nvar kServer = Symbol('server');\n/** @internal */\nvar kConnections = Symbol('connections');\n/** @internal */\nvar kPending = Symbol('pending');\n/** @internal */\nvar kCheckedOut = Symbol('checkedOut');\n/** @internal */\nvar kMinPoolSizeTimer = Symbol('minPoolSizeTimer');\n/** @internal */\nvar kGeneration = Symbol('generation');\n/** @internal */\nvar kServiceGenerations = Symbol('serviceGenerations');\n/** @internal */\nvar kConnectionCounter = Symbol('connectionCounter');\n/** @internal */\nvar kCancellationToken = Symbol('cancellationToken');\n/** @internal */\nvar kWaitQueue = Symbol('waitQueue');\n/** @internal */\nvar kCancelled = Symbol('cancelled');\n/** @internal */\nvar kMetrics = Symbol('metrics');\n/** @internal */\nvar kProcessingWaitQueue = Symbol('processingWaitQueue');\n/** @internal */\nvar kPoolState = Symbol('poolState');\n/** @internal */\nexports.PoolState = Object.freeze({\n  paused: 'paused',\n  ready: 'ready',\n  closed: 'closed'\n});\n/**\n * A pool of connections which dynamically resizes, and emit events related to pool activity\n * @internal\n */\nvar ConnectionPool = /*#__PURE__*/function (_mongo_types_1$TypedE) {\n  _inherits(ConnectionPool, _mongo_types_1$TypedE);\n  var _super = _createSuper(ConnectionPool);\n  function ConnectionPool(server, options) {\n    var _options$maxPoolSize, _options$minPoolSize, _options$maxConnectin, _options$maxIdleTimeM, _options$waitQueueTim, _options$minPoolSizeC;\n    var _this;\n    _classCallCheck(this, ConnectionPool);\n    _this = _super.call(this);\n    _this.options = Object.freeze(_objectSpread(_objectSpread({}, options), {}, {\n      connectionType: connection_1.Connection,\n      maxPoolSize: (_options$maxPoolSize = options.maxPoolSize) !== null && _options$maxPoolSize !== void 0 ? _options$maxPoolSize : 100,\n      minPoolSize: (_options$minPoolSize = options.minPoolSize) !== null && _options$minPoolSize !== void 0 ? _options$minPoolSize : 0,\n      maxConnecting: (_options$maxConnectin = options.maxConnecting) !== null && _options$maxConnectin !== void 0 ? _options$maxConnectin : 2,\n      maxIdleTimeMS: (_options$maxIdleTimeM = options.maxIdleTimeMS) !== null && _options$maxIdleTimeM !== void 0 ? _options$maxIdleTimeM : 0,\n      waitQueueTimeoutMS: (_options$waitQueueTim = options.waitQueueTimeoutMS) !== null && _options$waitQueueTim !== void 0 ? _options$waitQueueTim : 0,\n      minPoolSizeCheckFrequencyMS: (_options$minPoolSizeC = options.minPoolSizeCheckFrequencyMS) !== null && _options$minPoolSizeC !== void 0 ? _options$minPoolSizeC : 100,\n      autoEncrypter: options.autoEncrypter,\n      metadata: options.metadata\n    }));\n    if (_this.options.minPoolSize > _this.options.maxPoolSize) {\n      throw new error_1.MongoInvalidArgumentError('Connection pool minimum size must not be greater than maximum pool size');\n    }\n    _this[kPoolState] = exports.PoolState.paused;\n    _this[kServer] = server;\n    _this[kConnections] = new utils_1.List();\n    _this[kPending] = 0;\n    _this[kCheckedOut] = new Set();\n    _this[kMinPoolSizeTimer] = undefined;\n    _this[kGeneration] = 0;\n    _this[kServiceGenerations] = new Map();\n    _this[kConnectionCounter] = (0, utils_1.makeCounter)(1);\n    _this[kCancellationToken] = new mongo_types_1.CancellationToken();\n    _this[kCancellationToken].setMaxListeners(Infinity);\n    _this[kWaitQueue] = new utils_1.List();\n    _this[kMetrics] = new metrics_1.ConnectionPoolMetrics();\n    _this[kProcessingWaitQueue] = false;\n    _this.mongoLogger = _this[kServer].topology.client.mongoLogger;\n    _this.component = 'connection';\n    process.nextTick(function () {\n      _this.emitAndLog(ConnectionPool.CONNECTION_POOL_CREATED, new connection_pool_events_1.ConnectionPoolCreatedEvent(_assertThisInitialized(_this)));\n    });\n    return _this;\n  }\n  /** The address of the endpoint the pool is connected to */\n  _createClass(ConnectionPool, [{\n    key: \"address\",\n    get: function get() {\n      return this.options.hostAddress.toString();\n    }\n    /**\n     * Check if the pool has been closed\n     *\n     * TODO(NODE-3263): We can remove this property once shell no longer needs it\n     */\n  }, {\n    key: \"closed\",\n    get: function get() {\n      return this[kPoolState] === exports.PoolState.closed;\n    }\n    /** An integer representing the SDAM generation of the pool */\n  }, {\n    key: \"generation\",\n    get: function get() {\n      return this[kGeneration];\n    }\n    /** An integer expressing how many total connections (available + pending + in use) the pool currently has */\n  }, {\n    key: \"totalConnectionCount\",\n    get: function get() {\n      return this.availableConnectionCount + this.pendingConnectionCount + this.currentCheckedOutCount;\n    }\n    /** An integer expressing how many connections are currently available in the pool. */\n  }, {\n    key: \"availableConnectionCount\",\n    get: function get() {\n      return this[kConnections].length;\n    }\n  }, {\n    key: \"pendingConnectionCount\",\n    get: function get() {\n      return this[kPending];\n    }\n  }, {\n    key: \"currentCheckedOutCount\",\n    get: function get() {\n      return this[kCheckedOut].size;\n    }\n  }, {\n    key: \"waitQueueSize\",\n    get: function get() {\n      return this[kWaitQueue].length;\n    }\n  }, {\n    key: \"loadBalanced\",\n    get: function get() {\n      return this.options.loadBalanced;\n    }\n  }, {\n    key: \"serviceGenerations\",\n    get: function get() {\n      return this[kServiceGenerations];\n    }\n  }, {\n    key: \"serverError\",\n    get: function get() {\n      return this[kServer].description.error;\n    }\n    /**\n     * This is exposed ONLY for use in mongosh, to enable\n     * killing all connections if a user quits the shell with\n     * operations in progress.\n     *\n     * This property may be removed as a part of NODE-3263.\n     */\n  }, {\n    key: \"checkedOutConnections\",\n    get: function get() {\n      return this[kCheckedOut];\n    }\n    /**\n     * Get the metrics information for the pool when a wait queue timeout occurs.\n     */\n  }, {\n    key: \"waitQueueErrorMetrics\",\n    value: function waitQueueErrorMetrics() {\n      return this[kMetrics].info(this.options.maxPoolSize);\n    }\n    /**\n     * Set the pool state to \"ready\"\n     */\n  }, {\n    key: \"ready\",\n    value: function ready() {\n      if (this[kPoolState] !== exports.PoolState.paused) {\n        return;\n      }\n      this[kPoolState] = exports.PoolState.ready;\n      this.emitAndLog(ConnectionPool.CONNECTION_POOL_READY, new connection_pool_events_1.ConnectionPoolReadyEvent(this));\n      (0, timers_1.clearTimeout)(this[kMinPoolSizeTimer]);\n      this.ensureMinPoolSize();\n    }\n    /**\n     * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it\n     * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or\n     * explicitly destroyed by the new owner.\n     */\n  }, {\n    key: \"checkOut\",\n    value: function checkOut(callback) {\n      var _this2 = this;\n      this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_STARTED, new connection_pool_events_1.ConnectionCheckOutStartedEvent(this));\n      var waitQueueMember = {\n        callback: callback\n      };\n      var waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;\n      if (waitQueueTimeoutMS) {\n        waitQueueMember.timer = (0, timers_1.setTimeout)(function () {\n          waitQueueMember[kCancelled] = true;\n          waitQueueMember.timer = undefined;\n          _this2.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(_this2, 'timeout'));\n          waitQueueMember.callback(new errors_1.WaitQueueTimeoutError(_this2.loadBalanced ? _this2.waitQueueErrorMetrics() : 'Timed out while checking out a connection from connection pool', _this2.address));\n        }, waitQueueTimeoutMS);\n      }\n      this[kWaitQueue].push(waitQueueMember);\n      process.nextTick(function () {\n        return _this2.processWaitQueue();\n      });\n    }\n    /**\n     * Check a connection into the pool.\n     *\n     * @param connection - The connection to check in\n     */\n  }, {\n    key: \"checkIn\",\n    value: function checkIn(connection) {\n      var _this3 = this;\n      if (!this[kCheckedOut].has(connection)) {\n        return;\n      }\n      var poolClosed = this.closed;\n      var stale = this.connectionIsStale(connection);\n      var willDestroy = !!(poolClosed || stale || connection.closed);\n      if (!willDestroy) {\n        connection.markAvailable();\n        this[kConnections].unshift(connection);\n      }\n      this[kCheckedOut].delete(connection);\n      this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_IN, new connection_pool_events_1.ConnectionCheckedInEvent(this, connection));\n      if (willDestroy) {\n        var reason = connection.closed ? 'error' : poolClosed ? 'poolClosed' : 'stale';\n        this.destroyConnection(connection, reason);\n      }\n      process.nextTick(function () {\n        return _this3.processWaitQueue();\n      });\n    }\n    /**\n     * Clear the pool\n     *\n     * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a\n     * previous generation will eventually be pruned during subsequent checkouts.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _options$interruptInU,\n        _this4 = this;\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (this.closed) {\n        return;\n      }\n      // handle load balanced case\n      if (this.loadBalanced) {\n        var serviceId = options.serviceId;\n        if (!serviceId) {\n          throw new error_1.MongoRuntimeError('ConnectionPool.clear() called in load balanced mode with no serviceId.');\n        }\n        var sid = serviceId.toHexString();\n        var generation = this.serviceGenerations.get(sid);\n        // Only need to worry if the generation exists, since it should\n        // always be there but typescript needs the check.\n        if (generation == null) {\n          throw new error_1.MongoRuntimeError('Service generations are required in load balancer mode.');\n        } else {\n          // Increment the generation for the service id.\n          this.serviceGenerations.set(sid, generation + 1);\n        }\n        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, {\n          serviceId: serviceId\n        }));\n        return;\n      }\n      // handle non load-balanced case\n      var interruptInUseConnections = (_options$interruptInU = options.interruptInUseConnections) !== null && _options$interruptInU !== void 0 ? _options$interruptInU : false;\n      var oldGeneration = this[kGeneration];\n      this[kGeneration] += 1;\n      var alreadyPaused = this[kPoolState] === exports.PoolState.paused;\n      this[kPoolState] = exports.PoolState.paused;\n      this.clearMinPoolSizeTimer();\n      if (!alreadyPaused) {\n        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, {\n          interruptInUseConnections: interruptInUseConnections\n        }));\n      }\n      if (interruptInUseConnections) {\n        process.nextTick(function () {\n          return _this4.interruptInUseConnections(oldGeneration);\n        });\n      }\n      this.processWaitQueue();\n    }\n    /**\n     * Closes all stale in-use connections in the pool with a resumable PoolClearedOnNetworkError.\n     *\n     * Only connections where `connection.generation <= minGeneration` are killed.\n     */\n  }, {\n    key: \"interruptInUseConnections\",\n    value: function interruptInUseConnections(minGeneration) {\n      var _iterator = _createForOfIteratorHelper(this[kCheckedOut]),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var connection = _step.value;\n          if (connection.generation <= minGeneration) {\n            this.checkIn(connection);\n            connection.onError(new errors_1.PoolClearedOnNetworkError(this));\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close(_options, _cb) {\n      var _this5 = this;\n      var options = _options;\n      var callback = _cb !== null && _cb !== void 0 ? _cb : _options;\n      if (typeof options === 'function') {\n        options = {};\n      }\n      options = Object.assign({\n        force: false\n      }, options);\n      if (this.closed) {\n        return callback();\n      }\n      // immediately cancel any in-flight connections\n      this[kCancellationToken].emit('cancel');\n      // end the connection counter\n      if (typeof this[kConnectionCounter].return === 'function') {\n        this[kConnectionCounter].return(undefined);\n      }\n      this[kPoolState] = exports.PoolState.closed;\n      this.clearMinPoolSizeTimer();\n      this.processWaitQueue();\n      (0, utils_1.eachAsync)(this[kConnections].toArray(), function (conn, cb) {\n        _this5.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(_this5, conn, 'poolClosed'));\n        conn.destroy({\n          force: !!options.force\n        }, cb);\n      }, function (err) {\n        _this5[kConnections].clear();\n        _this5.emitAndLog(ConnectionPool.CONNECTION_POOL_CLOSED, new connection_pool_events_1.ConnectionPoolClosedEvent(_this5));\n        callback(err);\n      });\n    }\n    /**\n     * Runs a lambda with an implicitly checked out connection, checking that connection back in when the lambda\n     * has completed by calling back.\n     *\n     * NOTE: please note the required signature of `fn`\n     *\n     * @remarks When in load balancer mode, connections can be pinned to cursors or transactions.\n     *   In these cases we pass the connection in to this method to ensure it is used and a new\n     *   connection is not checked out.\n     *\n     * @param conn - A pinned connection for use in load balancing mode.\n     * @param fn - A function which operates on a managed connection\n     * @param callback - The original callback\n     */\n  }, {\n    key: \"withConnection\",\n    value: function withConnection(conn, fn, callback) {\n      var _this6 = this;\n      if (conn) {\n        // use the provided connection, and do _not_ check it in after execution\n        fn(undefined, conn, function (fnErr, result) {\n          if (fnErr) {\n            return _this6.withReauthentication(fnErr, conn, fn, callback);\n          }\n          callback(undefined, result);\n        });\n        return;\n      }\n      this.checkOut(function (err, conn) {\n        // don't callback with `err` here, we might want to act upon it inside `fn`\n        fn(err, conn, function (fnErr, result) {\n          if (fnErr) {\n            if (conn) {\n              _this6.withReauthentication(fnErr, conn, fn, callback);\n            } else {\n              callback(fnErr);\n            }\n          } else {\n            callback(undefined, result);\n          }\n          if (conn) {\n            _this6.checkIn(conn);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"withReauthentication\",\n    value: function withReauthentication(fnErr, conn, fn, callback) {\n      if (fnErr instanceof error_1.MongoError && fnErr.code === error_1.MONGODB_ERROR_CODES.Reauthenticate) {\n        this.reauthenticate(conn, fn, function (error, res) {\n          if (error) {\n            return callback(error);\n          }\n          callback(undefined, res);\n        });\n      } else {\n        callback(fnErr);\n      }\n    }\n    /**\n     * Reauthenticate on the same connection and then retry the operation.\n     */\n  }, {\n    key: \"reauthenticate\",\n    value: function reauthenticate(connection, fn, callback) {\n      var authContext = connection.authContext;\n      if (!authContext) {\n        return callback(new error_1.MongoRuntimeError('No auth context found on connection.'));\n      }\n      var credentials = authContext.credentials;\n      if (!credentials) {\n        return callback(new error_1.MongoMissingCredentialsError('Connection is missing credentials when asked to reauthenticate'));\n      }\n      var resolvedCredentials = credentials.resolveAuthMechanism(connection.hello || undefined);\n      var provider = connect_1.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n      if (!provider) {\n        return callback(new error_1.MongoMissingCredentialsError(\"Reauthenticate failed due to no auth provider for \".concat(credentials.mechanism)));\n      }\n      provider.reauth(authContext).then(function () {\n        fn(undefined, connection, function (fnErr, fnResult) {\n          if (fnErr) {\n            return callback(fnErr);\n          }\n          callback(undefined, fnResult);\n        });\n      }, function (error) {\n        return callback(error);\n      });\n    }\n    /** Clear the min pool size timer */\n  }, {\n    key: \"clearMinPoolSizeTimer\",\n    value: function clearMinPoolSizeTimer() {\n      var minPoolSizeTimer = this[kMinPoolSizeTimer];\n      if (minPoolSizeTimer) {\n        (0, timers_1.clearTimeout)(minPoolSizeTimer);\n      }\n    }\n  }, {\n    key: \"destroyConnection\",\n    value: function destroyConnection(connection, reason) {\n      this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, connection, reason));\n      // destroy the connection\n      process.nextTick(function () {\n        return connection.destroy({\n          force: false\n        });\n      });\n    }\n  }, {\n    key: \"connectionIsStale\",\n    value: function connectionIsStale(connection) {\n      var serviceId = connection.serviceId;\n      if (this.loadBalanced && serviceId) {\n        var sid = serviceId.toHexString();\n        var generation = this.serviceGenerations.get(sid);\n        return connection.generation !== generation;\n      }\n      return connection.generation !== this[kGeneration];\n    }\n  }, {\n    key: \"connectionIsIdle\",\n    value: function connectionIsIdle(connection) {\n      return !!(this.options.maxIdleTimeMS && connection.idleTime > this.options.maxIdleTimeMS);\n    }\n    /**\n     * Destroys a connection if the connection is perished.\n     *\n     * @returns `true` if the connection was destroyed, `false` otherwise.\n     */\n  }, {\n    key: \"destroyConnectionIfPerished\",\n    value: function destroyConnectionIfPerished(connection) {\n      var isStale = this.connectionIsStale(connection);\n      var isIdle = this.connectionIsIdle(connection);\n      if (!isStale && !isIdle && !connection.closed) {\n        return false;\n      }\n      var reason = connection.closed ? 'error' : isStale ? 'stale' : 'idle';\n      this.destroyConnection(connection, reason);\n      return true;\n    }\n  }, {\n    key: \"createConnection\",\n    value: function createConnection(callback) {\n      var _this7 = this;\n      var connectOptions = _objectSpread(_objectSpread({}, this.options), {}, {\n        id: this[kConnectionCounter].next().value,\n        generation: this[kGeneration],\n        cancellationToken: this[kCancellationToken]\n      });\n      this[kPending]++;\n      // This is our version of a \"virtual\" no-I/O connection as the spec requires\n      this.emitAndLog(ConnectionPool.CONNECTION_CREATED, new connection_pool_events_1.ConnectionCreatedEvent(this, {\n        id: connectOptions.id\n      }));\n      (0, connect_1.connect)(connectOptions, function (err, connection) {\n        if (err || !connection) {\n          _this7[kPending]--;\n          _this7.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(_this7, {\n            id: connectOptions.id,\n            serviceId: undefined\n          }, 'error',\n          // TODO(NODE-5192): Remove this cast\n          err));\n          if (err instanceof error_1.MongoNetworkError || err instanceof error_1.MongoServerError) {\n            err.connectionGeneration = connectOptions.generation;\n          }\n          callback(err !== null && err !== void 0 ? err : new error_1.MongoRuntimeError('Connection creation failed without error'));\n          return;\n        }\n        // The pool might have closed since we started trying to create a connection\n        if (_this7[kPoolState] !== exports.PoolState.ready) {\n          _this7[kPending]--;\n          connection.destroy({\n            force: true\n          });\n          callback(_this7.closed ? new errors_1.PoolClosedError(_this7) : new errors_1.PoolClearedError(_this7));\n          return;\n        }\n        // forward all events from the connection to the pool\n        var _loop = function _loop() {\n          var event = _arr[_i];\n          connection.on(event, function (e) {\n            return _this7.emit(event, e);\n          });\n        };\n        for (var _i = 0, _arr = [].concat(_toConsumableArray(constants_1.APM_EVENTS), [connection_1.Connection.CLUSTER_TIME_RECEIVED]); _i < _arr.length; _i++) {\n          _loop();\n        }\n        if (_this7.loadBalanced) {\n          connection.on(connection_1.Connection.PINNED, function (pinType) {\n            return _this7[kMetrics].markPinned(pinType);\n          });\n          connection.on(connection_1.Connection.UNPINNED, function (pinType) {\n            return _this7[kMetrics].markUnpinned(pinType);\n          });\n          var serviceId = connection.serviceId;\n          if (serviceId) {\n            var generation;\n            var sid = serviceId.toHexString();\n            if (generation = _this7.serviceGenerations.get(sid)) {\n              connection.generation = generation;\n            } else {\n              _this7.serviceGenerations.set(sid, 0);\n              connection.generation = 0;\n            }\n          }\n        }\n        connection.markAvailable();\n        _this7.emitAndLog(ConnectionPool.CONNECTION_READY, new connection_pool_events_1.ConnectionReadyEvent(_this7, connection));\n        _this7[kPending]--;\n        callback(undefined, connection);\n        return;\n      });\n    }\n  }, {\n    key: \"ensureMinPoolSize\",\n    value: function ensureMinPoolSize() {\n      var _this8 = this;\n      var minPoolSize = this.options.minPoolSize;\n      if (this[kPoolState] !== exports.PoolState.ready || minPoolSize === 0) {\n        return;\n      }\n      this[kConnections].prune(function (connection) {\n        return _this8.destroyConnectionIfPerished(connection);\n      });\n      if (this.totalConnectionCount < minPoolSize && this.pendingConnectionCount < this.options.maxConnecting) {\n        // NOTE: ensureMinPoolSize should not try to get all the pending\n        // connection permits because that potentially delays the availability of\n        // the connection to a checkout request\n        this.createConnection(function (err, connection) {\n          if (err) {\n            _this8[kServer].handleError(err);\n          }\n          if (!err && connection) {\n            _this8[kConnections].push(connection);\n            process.nextTick(function () {\n              return _this8.processWaitQueue();\n            });\n          }\n          if (_this8[kPoolState] === exports.PoolState.ready) {\n            (0, timers_1.clearTimeout)(_this8[kMinPoolSizeTimer]);\n            _this8[kMinPoolSizeTimer] = (0, timers_1.setTimeout)(function () {\n              return _this8.ensureMinPoolSize();\n            }, _this8.options.minPoolSizeCheckFrequencyMS);\n          }\n        });\n      } else {\n        (0, timers_1.clearTimeout)(this[kMinPoolSizeTimer]);\n        this[kMinPoolSizeTimer] = (0, timers_1.setTimeout)(function () {\n          return _this8.ensureMinPoolSize();\n        }, this.options.minPoolSizeCheckFrequencyMS);\n      }\n    }\n  }, {\n    key: \"processWaitQueue\",\n    value: function processWaitQueue() {\n      var _this9 = this;\n      if (this[kProcessingWaitQueue]) {\n        return;\n      }\n      this[kProcessingWaitQueue] = true;\n      while (this.waitQueueSize) {\n        var waitQueueMember = this[kWaitQueue].first();\n        if (!waitQueueMember) {\n          this[kWaitQueue].shift();\n          continue;\n        }\n        if (waitQueueMember[kCancelled]) {\n          this[kWaitQueue].shift();\n          continue;\n        }\n        if (this[kPoolState] !== exports.PoolState.ready) {\n          var reason = this.closed ? 'poolClosed' : 'connectionError';\n          var error = this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this);\n          this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, reason, error));\n          if (waitQueueMember.timer) {\n            (0, timers_1.clearTimeout)(waitQueueMember.timer);\n          }\n          this[kWaitQueue].shift();\n          waitQueueMember.callback(error);\n          continue;\n        }\n        if (!this.availableConnectionCount) {\n          break;\n        }\n        var connection = this[kConnections].shift();\n        if (!connection) {\n          break;\n        }\n        if (!this.destroyConnectionIfPerished(connection)) {\n          this[kCheckedOut].add(connection);\n          this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection));\n          if (waitQueueMember.timer) {\n            (0, timers_1.clearTimeout)(waitQueueMember.timer);\n          }\n          this[kWaitQueue].shift();\n          waitQueueMember.callback(undefined, connection);\n        }\n      }\n      var _this$options = this.options,\n        maxPoolSize = _this$options.maxPoolSize,\n        maxConnecting = _this$options.maxConnecting;\n      var _loop2 = function _loop2() {\n        var waitQueueMember = _this9[kWaitQueue].shift();\n        if (!waitQueueMember || waitQueueMember[kCancelled]) {\n          return \"continue\";\n        }\n        _this9.createConnection(function (err, connection) {\n          if (waitQueueMember[kCancelled]) {\n            if (!err && connection) {\n              _this9[kConnections].push(connection);\n            }\n          } else {\n            if (err) {\n              _this9.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED,\n              // TODO(NODE-5192): Remove this cast\n              new connection_pool_events_1.ConnectionCheckOutFailedEvent(_this9, 'connectionError', err));\n            } else if (connection) {\n              _this9[kCheckedOut].add(connection);\n              _this9.emitAndLog(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(_this9, connection));\n            }\n            if (waitQueueMember.timer) {\n              (0, timers_1.clearTimeout)(waitQueueMember.timer);\n            }\n            waitQueueMember.callback(err, connection);\n          }\n          process.nextTick(function () {\n            return _this9.processWaitQueue();\n          });\n        });\n      };\n      while (this.waitQueueSize > 0 && this.pendingConnectionCount < maxConnecting && (maxPoolSize === 0 || this.totalConnectionCount < maxPoolSize)) {\n        var _ret = _loop2();\n        if (_ret === \"continue\") continue;\n      }\n      this[kProcessingWaitQueue] = false;\n    }\n  }]);\n  return ConnectionPool;\n}(mongo_types_1.TypedEventEmitter);\n/**\n * Emitted when the connection pool is created.\n * @event\n */\nConnectionPool.CONNECTION_POOL_CREATED = constants_1.CONNECTION_POOL_CREATED;\n/**\n * Emitted once when the connection pool is closed\n * @event\n */\nConnectionPool.CONNECTION_POOL_CLOSED = constants_1.CONNECTION_POOL_CLOSED;\n/**\n * Emitted each time the connection pool is cleared and it's generation incremented\n * @event\n */\nConnectionPool.CONNECTION_POOL_CLEARED = constants_1.CONNECTION_POOL_CLEARED;\n/**\n * Emitted each time the connection pool is marked ready\n * @event\n */\nConnectionPool.CONNECTION_POOL_READY = constants_1.CONNECTION_POOL_READY;\n/**\n * Emitted when a connection is created.\n * @event\n */\nConnectionPool.CONNECTION_CREATED = constants_1.CONNECTION_CREATED;\n/**\n * Emitted when a connection becomes established, and is ready to use\n * @event\n */\nConnectionPool.CONNECTION_READY = constants_1.CONNECTION_READY;\n/**\n * Emitted when a connection is closed\n * @event\n */\nConnectionPool.CONNECTION_CLOSED = constants_1.CONNECTION_CLOSED;\n/**\n * Emitted when an attempt to check out a connection begins\n * @event\n */\nConnectionPool.CONNECTION_CHECK_OUT_STARTED = constants_1.CONNECTION_CHECK_OUT_STARTED;\n/**\n * Emitted when an attempt to check out a connection fails\n * @event\n */\nConnectionPool.CONNECTION_CHECK_OUT_FAILED = constants_1.CONNECTION_CHECK_OUT_FAILED;\n/**\n * Emitted each time a connection is successfully checked out of the connection pool\n * @event\n */\nConnectionPool.CONNECTION_CHECKED_OUT = constants_1.CONNECTION_CHECKED_OUT;\n/**\n * Emitted each time a connection is successfully checked into the connection pool\n * @event\n */\nConnectionPool.CONNECTION_CHECKED_IN = constants_1.CONNECTION_CHECKED_IN;\nexports.ConnectionPool = ConnectionPool;","map":{"version":3,"names":["timers_1","require","constants_1","error_1","mongo_types_1","utils_1","connect_1","connection_1","connection_pool_events_1","errors_1","metrics_1","kServer","Symbol","kConnections","kPending","kCheckedOut","kMinPoolSizeTimer","kGeneration","kServiceGenerations","kConnectionCounter","kCancellationToken","kWaitQueue","kCancelled","kMetrics","kProcessingWaitQueue","kPoolState","exports","PoolState","Object","freeze","paused","ready","closed","ConnectionPool","_mongo_types_1$TypedE","_inherits","_super","_createSuper","server","options","_options$maxPoolSize","_options$minPoolSize","_options$maxConnectin","_options$maxIdleTimeM","_options$waitQueueTim","_options$minPoolSizeC","_this","_classCallCheck","call","_objectSpread","connectionType","Connection","maxPoolSize","minPoolSize","maxConnecting","maxIdleTimeMS","waitQueueTimeoutMS","minPoolSizeCheckFrequencyMS","autoEncrypter","metadata","MongoInvalidArgumentError","List","Set","undefined","Map","makeCounter","CancellationToken","setMaxListeners","Infinity","ConnectionPoolMetrics","mongoLogger","topology","client","component","process","nextTick","emitAndLog","CONNECTION_POOL_CREATED","ConnectionPoolCreatedEvent","_assertThisInitialized","_createClass","key","get","hostAddress","toString","availableConnectionCount","pendingConnectionCount","currentCheckedOutCount","length","size","loadBalanced","description","error","value","waitQueueErrorMetrics","info","CONNECTION_POOL_READY","ConnectionPoolReadyEvent","clearTimeout","ensureMinPoolSize","checkOut","callback","_this2","CONNECTION_CHECK_OUT_STARTED","ConnectionCheckOutStartedEvent","waitQueueMember","timer","setTimeout","CONNECTION_CHECK_OUT_FAILED","ConnectionCheckOutFailedEvent","WaitQueueTimeoutError","address","push","processWaitQueue","checkIn","connection","_this3","has","poolClosed","stale","connectionIsStale","willDestroy","markAvailable","unshift","delete","CONNECTION_CHECKED_IN","ConnectionCheckedInEvent","reason","destroyConnection","clear","_options$interruptInU","_this4","arguments","serviceId","MongoRuntimeError","sid","toHexString","generation","serviceGenerations","set","CONNECTION_POOL_CLEARED","ConnectionPoolClearedEvent","interruptInUseConnections","oldGeneration","alreadyPaused","clearMinPoolSizeTimer","minGeneration","_iterator","_createForOfIteratorHelper","_step","s","n","done","onError","PoolClearedOnNetworkError","err","e","f","close","_options","_cb","_this5","assign","force","emit","return","eachAsync","toArray","conn","cb","CONNECTION_CLOSED","ConnectionClosedEvent","destroy","CONNECTION_POOL_CLOSED","ConnectionPoolClosedEvent","withConnection","fn","_this6","fnErr","result","withReauthentication","MongoError","code","MONGODB_ERROR_CODES","Reauthenticate","reauthenticate","res","authContext","credentials","MongoMissingCredentialsError","resolvedCredentials","resolveAuthMechanism","hello","provider","AUTH_PROVIDERS","mechanism","concat","reauth","then","fnResult","minPoolSizeTimer","connectionIsIdle","idleTime","destroyConnectionIfPerished","isStale","isIdle","createConnection","_this7","connectOptions","id","next","cancellationToken","CONNECTION_CREATED","ConnectionCreatedEvent","connect","MongoNetworkError","MongoServerError","connectionGeneration","PoolClosedError","PoolClearedError","_loop","event","_arr","_i","on","_toConsumableArray","APM_EVENTS","CLUSTER_TIME_RECEIVED","PINNED","pinType","markPinned","UNPINNED","markUnpinned","CONNECTION_READY","ConnectionReadyEvent","_this8","prune","totalConnectionCount","handleError","_this9","waitQueueSize","first","shift","add","CONNECTION_CHECKED_OUT","ConnectionCheckedOutEvent","_this$options","_loop2","_ret","TypedEventEmitter"],"sources":["/home/salman/Documents/GitHub/FakeShop/node_modules/mongodb/src/cmap/connection_pool.ts"],"sourcesContent":["import { clearTimeout, setTimeout } from 'timers';\n\nimport type { ObjectId } from '../bson';\nimport {\n  APM_EVENTS,\n  CONNECTION_CHECK_OUT_FAILED,\n  CONNECTION_CHECK_OUT_STARTED,\n  CONNECTION_CHECKED_IN,\n  CONNECTION_CHECKED_OUT,\n  CONNECTION_CLOSED,\n  CONNECTION_CREATED,\n  CONNECTION_POOL_CLEARED,\n  CONNECTION_POOL_CLOSED,\n  CONNECTION_POOL_CREATED,\n  CONNECTION_POOL_READY,\n  CONNECTION_READY\n} from '../constants';\nimport {\n  type AnyError,\n  MONGODB_ERROR_CODES,\n  MongoError,\n  MongoInvalidArgumentError,\n  MongoMissingCredentialsError,\n  MongoNetworkError,\n  MongoRuntimeError,\n  MongoServerError\n} from '../error';\nimport { CancellationToken, TypedEventEmitter } from '../mongo_types';\nimport type { Server } from '../sdam/server';\nimport { type Callback, eachAsync, List, makeCounter } from '../utils';\nimport { AUTH_PROVIDERS, connect } from './connect';\nimport { Connection, type ConnectionEvents, type ConnectionOptions } from './connection';\nimport {\n  ConnectionCheckedInEvent,\n  ConnectionCheckedOutEvent,\n  ConnectionCheckOutFailedEvent,\n  ConnectionCheckOutStartedEvent,\n  ConnectionClosedEvent,\n  ConnectionCreatedEvent,\n  ConnectionPoolClearedEvent,\n  ConnectionPoolClosedEvent,\n  ConnectionPoolCreatedEvent,\n  ConnectionPoolReadyEvent,\n  ConnectionReadyEvent\n} from './connection_pool_events';\nimport {\n  PoolClearedError,\n  PoolClearedOnNetworkError,\n  PoolClosedError,\n  WaitQueueTimeoutError\n} from './errors';\nimport { ConnectionPoolMetrics } from './metrics';\n\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kConnections = Symbol('connections');\n/** @internal */\nconst kPending = Symbol('pending');\n/** @internal */\nconst kCheckedOut = Symbol('checkedOut');\n/** @internal */\nconst kMinPoolSizeTimer = Symbol('minPoolSizeTimer');\n/** @internal */\nconst kGeneration = Symbol('generation');\n/** @internal */\nconst kServiceGenerations = Symbol('serviceGenerations');\n/** @internal */\nconst kConnectionCounter = Symbol('connectionCounter');\n/** @internal */\nconst kCancellationToken = Symbol('cancellationToken');\n/** @internal */\nconst kWaitQueue = Symbol('waitQueue');\n/** @internal */\nconst kCancelled = Symbol('cancelled');\n/** @internal */\nconst kMetrics = Symbol('metrics');\n/** @internal */\nconst kProcessingWaitQueue = Symbol('processingWaitQueue');\n/** @internal */\nconst kPoolState = Symbol('poolState');\n\n/** @public */\nexport interface ConnectionPoolOptions extends Omit<ConnectionOptions, 'id' | 'generation'> {\n  /** The maximum number of connections that may be associated with a pool at a given time. This includes in use and available connections. */\n  maxPoolSize: number;\n  /** The minimum number of connections that MUST exist at any moment in a single connection pool. */\n  minPoolSize: number;\n  /** The maximum number of connections that may be in the process of being established concurrently by the connection pool. */\n  maxConnecting: number;\n  /** The maximum amount of time a connection should remain idle in the connection pool before being marked idle. */\n  maxIdleTimeMS: number;\n  /** The maximum amount of time operation execution should wait for a connection to become available. The default is 0 which means there is no limit. */\n  waitQueueTimeoutMS: number;\n  /** If we are in load balancer mode. */\n  loadBalanced: boolean;\n  /** @internal */\n  minPoolSizeCheckFrequencyMS?: number;\n}\n\n/** @internal */\nexport interface WaitQueueMember {\n  callback: Callback<Connection>;\n  timer?: NodeJS.Timeout;\n  [kCancelled]?: boolean;\n}\n\n/** @internal */\nexport const PoolState = Object.freeze({\n  paused: 'paused',\n  ready: 'ready',\n  closed: 'closed'\n} as const);\n\n/** @public */\nexport interface CloseOptions {\n  force?: boolean;\n}\n\n/** @public */\nexport type ConnectionPoolEvents = {\n  connectionPoolCreated(event: ConnectionPoolCreatedEvent): void;\n  connectionPoolReady(event: ConnectionPoolReadyEvent): void;\n  connectionPoolClosed(event: ConnectionPoolClosedEvent): void;\n  connectionPoolCleared(event: ConnectionPoolClearedEvent): void;\n  connectionCreated(event: ConnectionCreatedEvent): void;\n  connectionReady(event: ConnectionReadyEvent): void;\n  connectionClosed(event: ConnectionClosedEvent): void;\n  connectionCheckOutStarted(event: ConnectionCheckOutStartedEvent): void;\n  connectionCheckOutFailed(event: ConnectionCheckOutFailedEvent): void;\n  connectionCheckedOut(event: ConnectionCheckedOutEvent): void;\n  connectionCheckedIn(event: ConnectionCheckedInEvent): void;\n} & Omit<ConnectionEvents, 'close' | 'message'>;\n\n/**\n * A pool of connections which dynamically resizes, and emit events related to pool activity\n * @internal\n */\nexport class ConnectionPool extends TypedEventEmitter<ConnectionPoolEvents> {\n  options: Readonly<ConnectionPoolOptions>;\n  [kPoolState]: (typeof PoolState)[keyof typeof PoolState];\n  [kServer]: Server;\n  [kConnections]: List<Connection>;\n  [kPending]: number;\n  [kCheckedOut]: Set<Connection>;\n  [kMinPoolSizeTimer]?: NodeJS.Timeout;\n  /**\n   * An integer representing the SDAM generation of the pool\n   */\n  [kGeneration]: number;\n  /**\n   * A map of generations to service ids\n   */\n  [kServiceGenerations]: Map<string, number>;\n  [kConnectionCounter]: Generator<number>;\n  [kCancellationToken]: CancellationToken;\n  [kWaitQueue]: List<WaitQueueMember>;\n  [kMetrics]: ConnectionPoolMetrics;\n  [kProcessingWaitQueue]: boolean;\n\n  /**\n   * Emitted when the connection pool is created.\n   * @event\n   */\n  static readonly CONNECTION_POOL_CREATED = CONNECTION_POOL_CREATED;\n  /**\n   * Emitted once when the connection pool is closed\n   * @event\n   */\n  static readonly CONNECTION_POOL_CLOSED = CONNECTION_POOL_CLOSED;\n  /**\n   * Emitted each time the connection pool is cleared and it's generation incremented\n   * @event\n   */\n  static readonly CONNECTION_POOL_CLEARED = CONNECTION_POOL_CLEARED;\n  /**\n   * Emitted each time the connection pool is marked ready\n   * @event\n   */\n  static readonly CONNECTION_POOL_READY = CONNECTION_POOL_READY;\n  /**\n   * Emitted when a connection is created.\n   * @event\n   */\n  static readonly CONNECTION_CREATED = CONNECTION_CREATED;\n  /**\n   * Emitted when a connection becomes established, and is ready to use\n   * @event\n   */\n  static readonly CONNECTION_READY = CONNECTION_READY;\n  /**\n   * Emitted when a connection is closed\n   * @event\n   */\n  static readonly CONNECTION_CLOSED = CONNECTION_CLOSED;\n  /**\n   * Emitted when an attempt to check out a connection begins\n   * @event\n   */\n  static readonly CONNECTION_CHECK_OUT_STARTED = CONNECTION_CHECK_OUT_STARTED;\n  /**\n   * Emitted when an attempt to check out a connection fails\n   * @event\n   */\n  static readonly CONNECTION_CHECK_OUT_FAILED = CONNECTION_CHECK_OUT_FAILED;\n  /**\n   * Emitted each time a connection is successfully checked out of the connection pool\n   * @event\n   */\n  static readonly CONNECTION_CHECKED_OUT = CONNECTION_CHECKED_OUT;\n  /**\n   * Emitted each time a connection is successfully checked into the connection pool\n   * @event\n   */\n  static readonly CONNECTION_CHECKED_IN = CONNECTION_CHECKED_IN;\n\n  constructor(server: Server, options: ConnectionPoolOptions) {\n    super();\n\n    this.options = Object.freeze({\n      ...options,\n      connectionType: Connection,\n      maxPoolSize: options.maxPoolSize ?? 100,\n      minPoolSize: options.minPoolSize ?? 0,\n      maxConnecting: options.maxConnecting ?? 2,\n      maxIdleTimeMS: options.maxIdleTimeMS ?? 0,\n      waitQueueTimeoutMS: options.waitQueueTimeoutMS ?? 0,\n      minPoolSizeCheckFrequencyMS: options.minPoolSizeCheckFrequencyMS ?? 100,\n      autoEncrypter: options.autoEncrypter,\n      metadata: options.metadata\n    });\n\n    if (this.options.minPoolSize > this.options.maxPoolSize) {\n      throw new MongoInvalidArgumentError(\n        'Connection pool minimum size must not be greater than maximum pool size'\n      );\n    }\n\n    this[kPoolState] = PoolState.paused;\n    this[kServer] = server;\n    this[kConnections] = new List();\n    this[kPending] = 0;\n    this[kCheckedOut] = new Set();\n    this[kMinPoolSizeTimer] = undefined;\n    this[kGeneration] = 0;\n    this[kServiceGenerations] = new Map();\n    this[kConnectionCounter] = makeCounter(1);\n    this[kCancellationToken] = new CancellationToken();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kWaitQueue] = new List();\n    this[kMetrics] = new ConnectionPoolMetrics();\n    this[kProcessingWaitQueue] = false;\n\n    this.mongoLogger = this[kServer].topology.client.mongoLogger;\n    this.component = 'connection';\n\n    process.nextTick(() => {\n      this.emitAndLog(ConnectionPool.CONNECTION_POOL_CREATED, new ConnectionPoolCreatedEvent(this));\n    });\n  }\n\n  /** The address of the endpoint the pool is connected to */\n  get address(): string {\n    return this.options.hostAddress.toString();\n  }\n\n  /**\n   * Check if the pool has been closed\n   *\n   * TODO(NODE-3263): We can remove this property once shell no longer needs it\n   */\n  get closed(): boolean {\n    return this[kPoolState] === PoolState.closed;\n  }\n\n  /** An integer representing the SDAM generation of the pool */\n  get generation(): number {\n    return this[kGeneration];\n  }\n\n  /** An integer expressing how many total connections (available + pending + in use) the pool currently has */\n  get totalConnectionCount(): number {\n    return (\n      this.availableConnectionCount + this.pendingConnectionCount + this.currentCheckedOutCount\n    );\n  }\n\n  /** An integer expressing how many connections are currently available in the pool. */\n  get availableConnectionCount(): number {\n    return this[kConnections].length;\n  }\n\n  get pendingConnectionCount(): number {\n    return this[kPending];\n  }\n\n  get currentCheckedOutCount(): number {\n    return this[kCheckedOut].size;\n  }\n\n  get waitQueueSize(): number {\n    return this[kWaitQueue].length;\n  }\n\n  get loadBalanced(): boolean {\n    return this.options.loadBalanced;\n  }\n\n  get serviceGenerations(): Map<string, number> {\n    return this[kServiceGenerations];\n  }\n\n  get serverError() {\n    return this[kServer].description.error;\n  }\n\n  /**\n   * This is exposed ONLY for use in mongosh, to enable\n   * killing all connections if a user quits the shell with\n   * operations in progress.\n   *\n   * This property may be removed as a part of NODE-3263.\n   */\n  get checkedOutConnections() {\n    return this[kCheckedOut];\n  }\n\n  /**\n   * Get the metrics information for the pool when a wait queue timeout occurs.\n   */\n  private waitQueueErrorMetrics(): string {\n    return this[kMetrics].info(this.options.maxPoolSize);\n  }\n\n  /**\n   * Set the pool state to \"ready\"\n   */\n  ready(): void {\n    if (this[kPoolState] !== PoolState.paused) {\n      return;\n    }\n    this[kPoolState] = PoolState.ready;\n    this.emitAndLog(ConnectionPool.CONNECTION_POOL_READY, new ConnectionPoolReadyEvent(this));\n    clearTimeout(this[kMinPoolSizeTimer]);\n    this.ensureMinPoolSize();\n  }\n\n  /**\n   * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it\n   * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or\n   * explicitly destroyed by the new owner.\n   */\n  checkOut(callback: Callback<Connection>): void {\n    this.emitAndLog(\n      ConnectionPool.CONNECTION_CHECK_OUT_STARTED,\n      new ConnectionCheckOutStartedEvent(this)\n    );\n\n    const waitQueueMember: WaitQueueMember = { callback };\n    const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;\n    if (waitQueueTimeoutMS) {\n      waitQueueMember.timer = setTimeout(() => {\n        waitQueueMember[kCancelled] = true;\n        waitQueueMember.timer = undefined;\n\n        this.emitAndLog(\n          ConnectionPool.CONNECTION_CHECK_OUT_FAILED,\n          new ConnectionCheckOutFailedEvent(this, 'timeout')\n        );\n        waitQueueMember.callback(\n          new WaitQueueTimeoutError(\n            this.loadBalanced\n              ? this.waitQueueErrorMetrics()\n              : 'Timed out while checking out a connection from connection pool',\n            this.address\n          )\n        );\n      }, waitQueueTimeoutMS);\n    }\n\n    this[kWaitQueue].push(waitQueueMember);\n    process.nextTick(() => this.processWaitQueue());\n  }\n\n  /**\n   * Check a connection into the pool.\n   *\n   * @param connection - The connection to check in\n   */\n  checkIn(connection: Connection): void {\n    if (!this[kCheckedOut].has(connection)) {\n      return;\n    }\n    const poolClosed = this.closed;\n    const stale = this.connectionIsStale(connection);\n    const willDestroy = !!(poolClosed || stale || connection.closed);\n\n    if (!willDestroy) {\n      connection.markAvailable();\n      this[kConnections].unshift(connection);\n    }\n\n    this[kCheckedOut].delete(connection);\n    this.emitAndLog(\n      ConnectionPool.CONNECTION_CHECKED_IN,\n      new ConnectionCheckedInEvent(this, connection)\n    );\n\n    if (willDestroy) {\n      const reason = connection.closed ? 'error' : poolClosed ? 'poolClosed' : 'stale';\n      this.destroyConnection(connection, reason);\n    }\n\n    process.nextTick(() => this.processWaitQueue());\n  }\n\n  /**\n   * Clear the pool\n   *\n   * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a\n   * previous generation will eventually be pruned during subsequent checkouts.\n   */\n  clear(options: { serviceId?: ObjectId; interruptInUseConnections?: boolean } = {}): void {\n    if (this.closed) {\n      return;\n    }\n\n    // handle load balanced case\n    if (this.loadBalanced) {\n      const { serviceId } = options;\n      if (!serviceId) {\n        throw new MongoRuntimeError(\n          'ConnectionPool.clear() called in load balanced mode with no serviceId.'\n        );\n      }\n      const sid = serviceId.toHexString();\n      const generation = this.serviceGenerations.get(sid);\n      // Only need to worry if the generation exists, since it should\n      // always be there but typescript needs the check.\n      if (generation == null) {\n        throw new MongoRuntimeError('Service generations are required in load balancer mode.');\n      } else {\n        // Increment the generation for the service id.\n        this.serviceGenerations.set(sid, generation + 1);\n      }\n      this.emitAndLog(\n        ConnectionPool.CONNECTION_POOL_CLEARED,\n        new ConnectionPoolClearedEvent(this, { serviceId })\n      );\n      return;\n    }\n    // handle non load-balanced case\n    const interruptInUseConnections = options.interruptInUseConnections ?? false;\n    const oldGeneration = this[kGeneration];\n    this[kGeneration] += 1;\n    const alreadyPaused = this[kPoolState] === PoolState.paused;\n    this[kPoolState] = PoolState.paused;\n\n    this.clearMinPoolSizeTimer();\n    if (!alreadyPaused) {\n      this.emitAndLog(\n        ConnectionPool.CONNECTION_POOL_CLEARED,\n        new ConnectionPoolClearedEvent(this, {\n          interruptInUseConnections\n        })\n      );\n    }\n\n    if (interruptInUseConnections) {\n      process.nextTick(() => this.interruptInUseConnections(oldGeneration));\n    }\n\n    this.processWaitQueue();\n  }\n\n  /**\n   * Closes all stale in-use connections in the pool with a resumable PoolClearedOnNetworkError.\n   *\n   * Only connections where `connection.generation <= minGeneration` are killed.\n   */\n  private interruptInUseConnections(minGeneration: number) {\n    for (const connection of this[kCheckedOut]) {\n      if (connection.generation <= minGeneration) {\n        this.checkIn(connection);\n        connection.onError(new PoolClearedOnNetworkError(this));\n      }\n    }\n  }\n\n  /** Close the pool */\n  close(callback: Callback<void>): void;\n  close(options: CloseOptions, callback: Callback<void>): void;\n  close(_options?: CloseOptions | Callback<void>, _cb?: Callback<void>): void {\n    let options = _options as CloseOptions;\n    const callback = (_cb ?? _options) as Callback<void>;\n    if (typeof options === 'function') {\n      options = {};\n    }\n\n    options = Object.assign({ force: false }, options);\n    if (this.closed) {\n      return callback();\n    }\n\n    // immediately cancel any in-flight connections\n    this[kCancellationToken].emit('cancel');\n\n    // end the connection counter\n    if (typeof this[kConnectionCounter].return === 'function') {\n      this[kConnectionCounter].return(undefined);\n    }\n\n    this[kPoolState] = PoolState.closed;\n    this.clearMinPoolSizeTimer();\n    this.processWaitQueue();\n\n    eachAsync<Connection>(\n      this[kConnections].toArray(),\n      (conn, cb) => {\n        this.emitAndLog(\n          ConnectionPool.CONNECTION_CLOSED,\n          new ConnectionClosedEvent(this, conn, 'poolClosed')\n        );\n        conn.destroy({ force: !!options.force }, cb);\n      },\n      err => {\n        this[kConnections].clear();\n        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLOSED, new ConnectionPoolClosedEvent(this));\n        callback(err);\n      }\n    );\n  }\n\n  /**\n   * Runs a lambda with an implicitly checked out connection, checking that connection back in when the lambda\n   * has completed by calling back.\n   *\n   * NOTE: please note the required signature of `fn`\n   *\n   * @remarks When in load balancer mode, connections can be pinned to cursors or transactions.\n   *   In these cases we pass the connection in to this method to ensure it is used and a new\n   *   connection is not checked out.\n   *\n   * @param conn - A pinned connection for use in load balancing mode.\n   * @param fn - A function which operates on a managed connection\n   * @param callback - The original callback\n   */\n  withConnection(\n    conn: Connection | undefined,\n    fn: WithConnectionCallback,\n    callback: Callback<Connection>\n  ): void {\n    if (conn) {\n      // use the provided connection, and do _not_ check it in after execution\n      fn(undefined, conn, (fnErr, result) => {\n        if (fnErr) {\n          return this.withReauthentication(fnErr, conn, fn, callback);\n        }\n        callback(undefined, result);\n      });\n      return;\n    }\n\n    this.checkOut((err, conn) => {\n      // don't callback with `err` here, we might want to act upon it inside `fn`\n      fn(err as MongoError, conn, (fnErr, result) => {\n        if (fnErr) {\n          if (conn) {\n            this.withReauthentication(fnErr, conn, fn, callback);\n          } else {\n            callback(fnErr);\n          }\n        } else {\n          callback(undefined, result);\n        }\n\n        if (conn) {\n          this.checkIn(conn);\n        }\n      });\n    });\n  }\n\n  private withReauthentication(\n    fnErr: AnyError,\n    conn: Connection,\n    fn: WithConnectionCallback,\n    callback: Callback<Connection>\n  ) {\n    if (fnErr instanceof MongoError && fnErr.code === MONGODB_ERROR_CODES.Reauthenticate) {\n      this.reauthenticate(conn, fn, (error, res) => {\n        if (error) {\n          return callback(error);\n        }\n        callback(undefined, res);\n      });\n    } else {\n      callback(fnErr);\n    }\n  }\n\n  /**\n   * Reauthenticate on the same connection and then retry the operation.\n   */\n  private reauthenticate(\n    connection: Connection,\n    fn: WithConnectionCallback,\n    callback: Callback\n  ): void {\n    const authContext = connection.authContext;\n    if (!authContext) {\n      return callback(new MongoRuntimeError('No auth context found on connection.'));\n    }\n    const credentials = authContext.credentials;\n    if (!credentials) {\n      return callback(\n        new MongoMissingCredentialsError(\n          'Connection is missing credentials when asked to reauthenticate'\n        )\n      );\n    }\n    const resolvedCredentials = credentials.resolveAuthMechanism(connection.hello || undefined);\n    const provider = AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n    if (!provider) {\n      return callback(\n        new MongoMissingCredentialsError(\n          `Reauthenticate failed due to no auth provider for ${credentials.mechanism}`\n        )\n      );\n    }\n    provider.reauth(authContext).then(\n      () => {\n        fn(undefined, connection, (fnErr, fnResult) => {\n          if (fnErr) {\n            return callback(fnErr);\n          }\n          callback(undefined, fnResult);\n        });\n      },\n      error => callback(error)\n    );\n  }\n\n  /** Clear the min pool size timer */\n  private clearMinPoolSizeTimer(): void {\n    const minPoolSizeTimer = this[kMinPoolSizeTimer];\n    if (minPoolSizeTimer) {\n      clearTimeout(minPoolSizeTimer);\n    }\n  }\n\n  private destroyConnection(\n    connection: Connection,\n    reason: 'error' | 'idle' | 'stale' | 'poolClosed'\n  ) {\n    this.emitAndLog(\n      ConnectionPool.CONNECTION_CLOSED,\n      new ConnectionClosedEvent(this, connection, reason)\n    );\n    // destroy the connection\n    process.nextTick(() => connection.destroy({ force: false }));\n  }\n\n  private connectionIsStale(connection: Connection) {\n    const serviceId = connection.serviceId;\n    if (this.loadBalanced && serviceId) {\n      const sid = serviceId.toHexString();\n      const generation = this.serviceGenerations.get(sid);\n      return connection.generation !== generation;\n    }\n\n    return connection.generation !== this[kGeneration];\n  }\n\n  private connectionIsIdle(connection: Connection) {\n    return !!(this.options.maxIdleTimeMS && connection.idleTime > this.options.maxIdleTimeMS);\n  }\n\n  /**\n   * Destroys a connection if the connection is perished.\n   *\n   * @returns `true` if the connection was destroyed, `false` otherwise.\n   */\n  private destroyConnectionIfPerished(connection: Connection): boolean {\n    const isStale = this.connectionIsStale(connection);\n    const isIdle = this.connectionIsIdle(connection);\n    if (!isStale && !isIdle && !connection.closed) {\n      return false;\n    }\n    const reason = connection.closed ? 'error' : isStale ? 'stale' : 'idle';\n    this.destroyConnection(connection, reason);\n    return true;\n  }\n\n  private createConnection(callback: Callback<Connection>) {\n    const connectOptions: ConnectionOptions = {\n      ...this.options,\n      id: this[kConnectionCounter].next().value,\n      generation: this[kGeneration],\n      cancellationToken: this[kCancellationToken]\n    };\n\n    this[kPending]++;\n    // This is our version of a \"virtual\" no-I/O connection as the spec requires\n    this.emitAndLog(\n      ConnectionPool.CONNECTION_CREATED,\n      new ConnectionCreatedEvent(this, { id: connectOptions.id })\n    );\n\n    connect(connectOptions, (err, connection) => {\n      if (err || !connection) {\n        this[kPending]--;\n        this.emitAndLog(\n          ConnectionPool.CONNECTION_CLOSED,\n          new ConnectionClosedEvent(\n            this,\n            { id: connectOptions.id, serviceId: undefined },\n            'error',\n            // TODO(NODE-5192): Remove this cast\n            err as MongoError\n          )\n        );\n        if (err instanceof MongoNetworkError || err instanceof MongoServerError) {\n          err.connectionGeneration = connectOptions.generation;\n        }\n        callback(err ?? new MongoRuntimeError('Connection creation failed without error'));\n        return;\n      }\n\n      // The pool might have closed since we started trying to create a connection\n      if (this[kPoolState] !== PoolState.ready) {\n        this[kPending]--;\n        connection.destroy({ force: true });\n        callback(this.closed ? new PoolClosedError(this) : new PoolClearedError(this));\n        return;\n      }\n\n      // forward all events from the connection to the pool\n      for (const event of [...APM_EVENTS, Connection.CLUSTER_TIME_RECEIVED]) {\n        connection.on(event, (e: any) => this.emit(event, e));\n      }\n\n      if (this.loadBalanced) {\n        connection.on(Connection.PINNED, pinType => this[kMetrics].markPinned(pinType));\n        connection.on(Connection.UNPINNED, pinType => this[kMetrics].markUnpinned(pinType));\n\n        const serviceId = connection.serviceId;\n        if (serviceId) {\n          let generation;\n          const sid = serviceId.toHexString();\n          if ((generation = this.serviceGenerations.get(sid))) {\n            connection.generation = generation;\n          } else {\n            this.serviceGenerations.set(sid, 0);\n            connection.generation = 0;\n          }\n        }\n      }\n\n      connection.markAvailable();\n      this.emitAndLog(ConnectionPool.CONNECTION_READY, new ConnectionReadyEvent(this, connection));\n\n      this[kPending]--;\n      callback(undefined, connection);\n      return;\n    });\n  }\n\n  private ensureMinPoolSize() {\n    const minPoolSize = this.options.minPoolSize;\n    if (this[kPoolState] !== PoolState.ready || minPoolSize === 0) {\n      return;\n    }\n\n    this[kConnections].prune(connection => this.destroyConnectionIfPerished(connection));\n\n    if (\n      this.totalConnectionCount < minPoolSize &&\n      this.pendingConnectionCount < this.options.maxConnecting\n    ) {\n      // NOTE: ensureMinPoolSize should not try to get all the pending\n      // connection permits because that potentially delays the availability of\n      // the connection to a checkout request\n      this.createConnection((err, connection) => {\n        if (err) {\n          this[kServer].handleError(err);\n        }\n        if (!err && connection) {\n          this[kConnections].push(connection);\n          process.nextTick(() => this.processWaitQueue());\n        }\n        if (this[kPoolState] === PoolState.ready) {\n          clearTimeout(this[kMinPoolSizeTimer]);\n          this[kMinPoolSizeTimer] = setTimeout(\n            () => this.ensureMinPoolSize(),\n            this.options.minPoolSizeCheckFrequencyMS\n          );\n        }\n      });\n    } else {\n      clearTimeout(this[kMinPoolSizeTimer]);\n      this[kMinPoolSizeTimer] = setTimeout(\n        () => this.ensureMinPoolSize(),\n        this.options.minPoolSizeCheckFrequencyMS\n      );\n    }\n  }\n\n  private processWaitQueue() {\n    if (this[kProcessingWaitQueue]) {\n      return;\n    }\n    this[kProcessingWaitQueue] = true;\n\n    while (this.waitQueueSize) {\n      const waitQueueMember = this[kWaitQueue].first();\n      if (!waitQueueMember) {\n        this[kWaitQueue].shift();\n        continue;\n      }\n\n      if (waitQueueMember[kCancelled]) {\n        this[kWaitQueue].shift();\n        continue;\n      }\n\n      if (this[kPoolState] !== PoolState.ready) {\n        const reason = this.closed ? 'poolClosed' : 'connectionError';\n        const error = this.closed ? new PoolClosedError(this) : new PoolClearedError(this);\n        this.emitAndLog(\n          ConnectionPool.CONNECTION_CHECK_OUT_FAILED,\n          new ConnectionCheckOutFailedEvent(this, reason, error)\n        );\n        if (waitQueueMember.timer) {\n          clearTimeout(waitQueueMember.timer);\n        }\n        this[kWaitQueue].shift();\n        waitQueueMember.callback(error);\n        continue;\n      }\n\n      if (!this.availableConnectionCount) {\n        break;\n      }\n\n      const connection = this[kConnections].shift();\n      if (!connection) {\n        break;\n      }\n\n      if (!this.destroyConnectionIfPerished(connection)) {\n        this[kCheckedOut].add(connection);\n        this.emitAndLog(\n          ConnectionPool.CONNECTION_CHECKED_OUT,\n          new ConnectionCheckedOutEvent(this, connection)\n        );\n        if (waitQueueMember.timer) {\n          clearTimeout(waitQueueMember.timer);\n        }\n\n        this[kWaitQueue].shift();\n        waitQueueMember.callback(undefined, connection);\n      }\n    }\n\n    const { maxPoolSize, maxConnecting } = this.options;\n    while (\n      this.waitQueueSize > 0 &&\n      this.pendingConnectionCount < maxConnecting &&\n      (maxPoolSize === 0 || this.totalConnectionCount < maxPoolSize)\n    ) {\n      const waitQueueMember = this[kWaitQueue].shift();\n      if (!waitQueueMember || waitQueueMember[kCancelled]) {\n        continue;\n      }\n      this.createConnection((err, connection) => {\n        if (waitQueueMember[kCancelled]) {\n          if (!err && connection) {\n            this[kConnections].push(connection);\n          }\n        } else {\n          if (err) {\n            this.emitAndLog(\n              ConnectionPool.CONNECTION_CHECK_OUT_FAILED,\n              // TODO(NODE-5192): Remove this cast\n              new ConnectionCheckOutFailedEvent(this, 'connectionError', err as MongoError)\n            );\n          } else if (connection) {\n            this[kCheckedOut].add(connection);\n            this.emitAndLog(\n              ConnectionPool.CONNECTION_CHECKED_OUT,\n              new ConnectionCheckedOutEvent(this, connection)\n            );\n          }\n\n          if (waitQueueMember.timer) {\n            clearTimeout(waitQueueMember.timer);\n          }\n          waitQueueMember.callback(err, connection);\n        }\n        process.nextTick(() => this.processWaitQueue());\n      });\n    }\n    this[kProcessingWaitQueue] = false;\n  }\n}\n\n/**\n * A callback provided to `withConnection`\n * @internal\n *\n * @param error - An error instance representing the error during the execution.\n * @param connection - The managed connection which was checked out of the pool.\n * @param callback - A function to call back after connection management is complete\n */\nexport type WithConnectionCallback = (\n  error: MongoError | undefined,\n  connection: Connection | undefined,\n  callback: Callback<Connection>\n) => void;\n"],"mappings":";;;;;;;;;;;;;;AAAA,IAAAA,QAAA,GAAAC,OAAA;AAGA,IAAAC,WAAA,GAAAD,OAAA;AAcA,IAAAE,OAAA,GAAAF,OAAA;AAUA,IAAAG,aAAA,GAAAH,OAAA;AAEA,IAAAI,OAAA,GAAAJ,OAAA;AACA,IAAAK,SAAA,GAAAL,OAAA;AACA,IAAAM,YAAA,GAAAN,OAAA;AACA,IAAAO,wBAAA,GAAAP,OAAA;AAaA,IAAAQ,QAAA,GAAAR,OAAA;AAMA,IAAAS,SAAA,GAAAT,OAAA;AAEA;AACA,IAAMU,OAAO,GAAGC,MAAM,CAAC,QAAQ,CAAC;AAChC;AACA,IAAMC,YAAY,GAAGD,MAAM,CAAC,aAAa,CAAC;AAC1C;AACA,IAAME,QAAQ,GAAGF,MAAM,CAAC,SAAS,CAAC;AAClC;AACA,IAAMG,WAAW,GAAGH,MAAM,CAAC,YAAY,CAAC;AACxC;AACA,IAAMI,iBAAiB,GAAGJ,MAAM,CAAC,kBAAkB,CAAC;AACpD;AACA,IAAMK,WAAW,GAAGL,MAAM,CAAC,YAAY,CAAC;AACxC;AACA,IAAMM,mBAAmB,GAAGN,MAAM,CAAC,oBAAoB,CAAC;AACxD;AACA,IAAMO,kBAAkB,GAAGP,MAAM,CAAC,mBAAmB,CAAC;AACtD;AACA,IAAMQ,kBAAkB,GAAGR,MAAM,CAAC,mBAAmB,CAAC;AACtD;AACA,IAAMS,UAAU,GAAGT,MAAM,CAAC,WAAW,CAAC;AACtC;AACA,IAAMU,UAAU,GAAGV,MAAM,CAAC,WAAW,CAAC;AACtC;AACA,IAAMW,QAAQ,GAAGX,MAAM,CAAC,SAAS,CAAC;AAClC;AACA,IAAMY,oBAAoB,GAAGZ,MAAM,CAAC,qBAAqB,CAAC;AAC1D;AACA,IAAMa,UAAU,GAAGb,MAAM,CAAC,WAAW,CAAC;AA2BtC;AACac,OAAA,CAAAC,SAAS,GAAGC,MAAM,CAACC,MAAM,CAAC;EACrCC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,OAAO;EACdC,MAAM,EAAE;CACA,CAAC;AAsBX;;;;AAAA,IAIaC,cAAe,0BAAAC,qBAAA;EAAAC,SAAA,CAAAF,cAAA,EAAAC,qBAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,cAAA;EA8E1B,SAAAA,eAAYK,MAAc,EAAEC,OAA8B;IAAA,IAAAC,oBAAA,EAAAC,oBAAA,EAAAC,qBAAA,EAAAC,qBAAA,EAAAC,qBAAA,EAAAC,qBAAA;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAd,cAAA;IACxDa,KAAA,GAAAV,MAAA,CAAAY,IAAA;IAEAF,KAAA,CAAKP,OAAO,GAAGX,MAAM,CAACC,MAAM,CAAAoB,aAAA,CAAAA,aAAA,KACvBV,OAAO;MACVW,cAAc,EAAE3C,YAAA,CAAA4C,UAAU;MAC1BC,WAAW,GAAAZ,oBAAA,GAAED,OAAO,CAACa,WAAW,cAAAZ,oBAAA,cAAAA,oBAAA,GAAI,GAAG;MACvCa,WAAW,GAAAZ,oBAAA,GAAEF,OAAO,CAACc,WAAW,cAAAZ,oBAAA,cAAAA,oBAAA,GAAI,CAAC;MACrCa,aAAa,GAAAZ,qBAAA,GAAEH,OAAO,CAACe,aAAa,cAAAZ,qBAAA,cAAAA,qBAAA,GAAI,CAAC;MACzCa,aAAa,GAAAZ,qBAAA,GAAEJ,OAAO,CAACgB,aAAa,cAAAZ,qBAAA,cAAAA,qBAAA,GAAI,CAAC;MACzCa,kBAAkB,GAAAZ,qBAAA,GAAEL,OAAO,CAACiB,kBAAkB,cAAAZ,qBAAA,cAAAA,qBAAA,GAAI,CAAC;MACnDa,2BAA2B,GAAAZ,qBAAA,GAAEN,OAAO,CAACkB,2BAA2B,cAAAZ,qBAAA,cAAAA,qBAAA,GAAI,GAAG;MACvEa,aAAa,EAAEnB,OAAO,CAACmB,aAAa;MACpCC,QAAQ,EAAEpB,OAAO,CAACoB;IAAQ,EAC3B,CAAC;IAEF,IAAIb,KAAA,CAAKP,OAAO,CAACc,WAAW,GAAGP,KAAA,CAAKP,OAAO,CAACa,WAAW,EAAE;MACvD,MAAM,IAAIjD,OAAA,CAAAyD,yBAAyB,CACjC,yEAAyE,CAC1E;;IAGHd,KAAA,CAAKrB,UAAU,CAAC,GAAGC,OAAA,CAAAC,SAAS,CAACG,MAAM;IACnCgB,KAAA,CAAKnC,OAAO,CAAC,GAAG2B,MAAM;IACtBQ,KAAA,CAAKjC,YAAY,CAAC,GAAG,IAAIR,OAAA,CAAAwD,IAAI,EAAE;IAC/Bf,KAAA,CAAKhC,QAAQ,CAAC,GAAG,CAAC;IAClBgC,KAAA,CAAK/B,WAAW,CAAC,GAAG,IAAI+C,GAAG,EAAE;IAC7BhB,KAAA,CAAK9B,iBAAiB,CAAC,GAAG+C,SAAS;IACnCjB,KAAA,CAAK7B,WAAW,CAAC,GAAG,CAAC;IACrB6B,KAAA,CAAK5B,mBAAmB,CAAC,GAAG,IAAI8C,GAAG,EAAE;IACrClB,KAAA,CAAK3B,kBAAkB,CAAC,GAAG,IAAAd,OAAA,CAAA4D,WAAW,EAAC,CAAC,CAAC;IACzCnB,KAAA,CAAK1B,kBAAkB,CAAC,GAAG,IAAIhB,aAAA,CAAA8D,iBAAiB,EAAE;IAClDpB,KAAA,CAAK1B,kBAAkB,CAAC,CAAC+C,eAAe,CAACC,QAAQ,CAAC;IAClDtB,KAAA,CAAKzB,UAAU,CAAC,GAAG,IAAIhB,OAAA,CAAAwD,IAAI,EAAE;IAC7Bf,KAAA,CAAKvB,QAAQ,CAAC,GAAG,IAAIb,SAAA,CAAA2D,qBAAqB,EAAE;IAC5CvB,KAAA,CAAKtB,oBAAoB,CAAC,GAAG,KAAK;IAElCsB,KAAA,CAAKwB,WAAW,GAAGxB,KAAA,CAAKnC,OAAO,CAAC,CAAC4D,QAAQ,CAACC,MAAM,CAACF,WAAW;IAC5DxB,KAAA,CAAK2B,SAAS,GAAG,YAAY;IAE7BC,OAAO,CAACC,QAAQ,CAAC,YAAK;MACpB7B,KAAA,CAAK8B,UAAU,CAAC3C,cAAc,CAAC4C,uBAAuB,EAAE,IAAIrE,wBAAA,CAAAsE,0BAA0B,CAAAC,sBAAA,CAAAjC,KAAA,CAAK,CAAC,CAAC;IAC/F,CAAC,CAAC;IAAC,OAAAA,KAAA;EACL;EAEA;EAAAkC,YAAA,CAAA/C,cAAA;IAAAgD,GAAA;IAAAC,GAAA,EACA,SAAAA,IAAA,EAAW;MACT,OAAO,IAAI,CAAC3C,OAAO,CAAC4C,WAAW,CAACC,QAAQ,EAAE;IAC5C;IAEA;;;;;EAAA;IAAAH,GAAA;IAAAC,GAAA,EAKA,SAAAA,IAAA,EAAU;MACR,OAAO,IAAI,CAACzD,UAAU,CAAC,KAAKC,OAAA,CAAAC,SAAS,CAACK,MAAM;IAC9C;IAEA;EAAA;IAAAiD,GAAA;IAAAC,GAAA,EACA,SAAAA,IAAA,EAAc;MACZ,OAAO,IAAI,CAACjE,WAAW,CAAC;IAC1B;IAEA;EAAA;IAAAgE,GAAA;IAAAC,GAAA,EACA,SAAAA,IAAA,EAAwB;MACtB,OACE,IAAI,CAACG,wBAAwB,GAAG,IAAI,CAACC,sBAAsB,GAAG,IAAI,CAACC,sBAAsB;IAE7F;IAEA;EAAA;IAAAN,GAAA;IAAAC,GAAA,EACA,SAAAA,IAAA,EAA4B;MAC1B,OAAO,IAAI,CAACrE,YAAY,CAAC,CAAC2E,MAAM;IAClC;EAAC;IAAAP,GAAA;IAAAC,GAAA,EAED,SAAAA,IAAA,EAA0B;MACxB,OAAO,IAAI,CAACpE,QAAQ,CAAC;IACvB;EAAC;IAAAmE,GAAA;IAAAC,GAAA,EAED,SAAAA,IAAA,EAA0B;MACxB,OAAO,IAAI,CAACnE,WAAW,CAAC,CAAC0E,IAAI;IAC/B;EAAC;IAAAR,GAAA;IAAAC,GAAA,EAED,SAAAA,IAAA,EAAiB;MACf,OAAO,IAAI,CAAC7D,UAAU,CAAC,CAACmE,MAAM;IAChC;EAAC;IAAAP,GAAA;IAAAC,GAAA,EAED,SAAAA,IAAA,EAAgB;MACd,OAAO,IAAI,CAAC3C,OAAO,CAACmD,YAAY;IAClC;EAAC;IAAAT,GAAA;IAAAC,GAAA,EAED,SAAAA,IAAA,EAAsB;MACpB,OAAO,IAAI,CAAChE,mBAAmB,CAAC;IAClC;EAAC;IAAA+D,GAAA;IAAAC,GAAA,EAED,SAAAA,IAAA,EAAe;MACb,OAAO,IAAI,CAACvE,OAAO,CAAC,CAACgF,WAAW,CAACC,KAAK;IACxC;IAEA;;;;;;;EAAA;IAAAX,GAAA;IAAAC,GAAA,EAOA,SAAAA,IAAA,EAAyB;MACvB,OAAO,IAAI,CAACnE,WAAW,CAAC;IAC1B;IAEA;;;EAAA;IAAAkE,GAAA;IAAAY,KAAA,EAGQ,SAAAC,sBAAA,EAAqB;MAC3B,OAAO,IAAI,CAACvE,QAAQ,CAAC,CAACwE,IAAI,CAAC,IAAI,CAACxD,OAAO,CAACa,WAAW,CAAC;IACtD;IAEA;;;EAAA;IAAA6B,GAAA;IAAAY,KAAA,EAGA,SAAA9D,MAAA,EAAK;MACH,IAAI,IAAI,CAACN,UAAU,CAAC,KAAKC,OAAA,CAAAC,SAAS,CAACG,MAAM,EAAE;QACzC;;MAEF,IAAI,CAACL,UAAU,CAAC,GAAGC,OAAA,CAAAC,SAAS,CAACI,KAAK;MAClC,IAAI,CAAC6C,UAAU,CAAC3C,cAAc,CAAC+D,qBAAqB,EAAE,IAAIxF,wBAAA,CAAAyF,wBAAwB,CAAC,IAAI,CAAC,CAAC;MACzF,IAAAjG,QAAA,CAAAkG,YAAY,EAAC,IAAI,CAAClF,iBAAiB,CAAC,CAAC;MACrC,IAAI,CAACmF,iBAAiB,EAAE;IAC1B;IAEA;;;;;EAAA;IAAAlB,GAAA;IAAAY,KAAA,EAKA,SAAAO,SAASC,QAA8B;MAAA,IAAAC,MAAA;MACrC,IAAI,CAAC1B,UAAU,CACb3C,cAAc,CAACsE,4BAA4B,EAC3C,IAAI/F,wBAAA,CAAAgG,8BAA8B,CAAC,IAAI,CAAC,CACzC;MAED,IAAMC,eAAe,GAAoB;QAAEJ,QAAQ,EAARA;MAAQ,CAAE;MACrD,IAAM7C,kBAAkB,GAAG,IAAI,CAACjB,OAAO,CAACiB,kBAAkB;MAC1D,IAAIA,kBAAkB,EAAE;QACtBiD,eAAe,CAACC,KAAK,GAAG,IAAA1G,QAAA,CAAA2G,UAAU,EAAC,YAAK;UACtCF,eAAe,CAACnF,UAAU,CAAC,GAAG,IAAI;UAClCmF,eAAe,CAACC,KAAK,GAAG3C,SAAS;UAEjCuC,MAAI,CAAC1B,UAAU,CACb3C,cAAc,CAAC2E,2BAA2B,EAC1C,IAAIpG,wBAAA,CAAAqG,6BAA6B,CAACP,MAAI,EAAE,SAAS,CAAC,CACnD;UACDG,eAAe,CAACJ,QAAQ,CACtB,IAAI5F,QAAA,CAAAqG,qBAAqB,CACvBR,MAAI,CAACZ,YAAY,GACbY,MAAI,CAACR,qBAAqB,EAAE,GAC5B,gEAAgE,EACpEQ,MAAI,CAACS,OAAO,CACb,CACF;QACH,CAAC,EAAEvD,kBAAkB,CAAC;;MAGxB,IAAI,CAACnC,UAAU,CAAC,CAAC2F,IAAI,CAACP,eAAe,CAAC;MACtC/B,OAAO,CAACC,QAAQ,CAAC;QAAA,OAAM2B,MAAI,CAACW,gBAAgB,EAAE;MAAA,EAAC;IACjD;IAEA;;;;;EAAA;IAAAhC,GAAA;IAAAY,KAAA,EAKA,SAAAqB,QAAQC,UAAsB;MAAA,IAAAC,MAAA;MAC5B,IAAI,CAAC,IAAI,CAACrG,WAAW,CAAC,CAACsG,GAAG,CAACF,UAAU,CAAC,EAAE;QACtC;;MAEF,IAAMG,UAAU,GAAG,IAAI,CAACtF,MAAM;MAC9B,IAAMuF,KAAK,GAAG,IAAI,CAACC,iBAAiB,CAACL,UAAU,CAAC;MAChD,IAAMM,WAAW,GAAG,CAAC,EAAEH,UAAU,IAAIC,KAAK,IAAIJ,UAAU,CAACnF,MAAM,CAAC;MAEhE,IAAI,CAACyF,WAAW,EAAE;QAChBN,UAAU,CAACO,aAAa,EAAE;QAC1B,IAAI,CAAC7G,YAAY,CAAC,CAAC8G,OAAO,CAACR,UAAU,CAAC;;MAGxC,IAAI,CAACpG,WAAW,CAAC,CAAC6G,MAAM,CAACT,UAAU,CAAC;MACpC,IAAI,CAACvC,UAAU,CACb3C,cAAc,CAAC4F,qBAAqB,EACpC,IAAIrH,wBAAA,CAAAsH,wBAAwB,CAAC,IAAI,EAAEX,UAAU,CAAC,CAC/C;MAED,IAAIM,WAAW,EAAE;QACf,IAAMM,MAAM,GAAGZ,UAAU,CAACnF,MAAM,GAAG,OAAO,GAAGsF,UAAU,GAAG,YAAY,GAAG,OAAO;QAChF,IAAI,CAACU,iBAAiB,CAACb,UAAU,EAAEY,MAAM,CAAC;;MAG5CrD,OAAO,CAACC,QAAQ,CAAC;QAAA,OAAMyC,MAAI,CAACH,gBAAgB,EAAE;MAAA,EAAC;IACjD;IAEA;;;;;;EAAA;IAAAhC,GAAA;IAAAY,KAAA,EAMA,SAAAoC,MAAA,EAAiF;MAAA,IAAAC,qBAAA;QAAAC,MAAA;MAAA,IAA3E5F,OAAA,GAAA6F,SAAA,CAAA5C,MAAA,QAAA4C,SAAA,QAAArE,SAAA,GAAAqE,SAAA,MAAyE,EAAE;MAC/E,IAAI,IAAI,CAACpG,MAAM,EAAE;QACf;;MAGF;MACA,IAAI,IAAI,CAAC0D,YAAY,EAAE;QACrB,IAAQ2C,SAAS,GAAK9F,OAAO,CAArB8F,SAAS;QACjB,IAAI,CAACA,SAAS,EAAE;UACd,MAAM,IAAIlI,OAAA,CAAAmI,iBAAiB,CACzB,wEAAwE,CACzE;;QAEH,IAAMC,GAAG,GAAGF,SAAS,CAACG,WAAW,EAAE;QACnC,IAAMC,UAAU,GAAG,IAAI,CAACC,kBAAkB,CAACxD,GAAG,CAACqD,GAAG,CAAC;QACnD;QACA;QACA,IAAIE,UAAU,IAAI,IAAI,EAAE;UACtB,MAAM,IAAItI,OAAA,CAAAmI,iBAAiB,CAAC,yDAAyD,CAAC;SACvF,MAAM;UACL;UACA,IAAI,CAACI,kBAAkB,CAACC,GAAG,CAACJ,GAAG,EAAEE,UAAU,GAAG,CAAC,CAAC;;QAElD,IAAI,CAAC7D,UAAU,CACb3C,cAAc,CAAC2G,uBAAuB,EACtC,IAAIpI,wBAAA,CAAAqI,0BAA0B,CAAC,IAAI,EAAE;UAAER,SAAS,EAATA;QAAS,CAAE,CAAC,CACpD;QACD;;MAEF;MACA,IAAMS,yBAAyB,IAAAZ,qBAAA,GAAG3F,OAAO,CAACuG,yBAAyB,cAAAZ,qBAAA,cAAAA,qBAAA,GAAI,KAAK;MAC5E,IAAMa,aAAa,GAAG,IAAI,CAAC9H,WAAW,CAAC;MACvC,IAAI,CAACA,WAAW,CAAC,IAAI,CAAC;MACtB,IAAM+H,aAAa,GAAG,IAAI,CAACvH,UAAU,CAAC,KAAKC,OAAA,CAAAC,SAAS,CAACG,MAAM;MAC3D,IAAI,CAACL,UAAU,CAAC,GAAGC,OAAA,CAAAC,SAAS,CAACG,MAAM;MAEnC,IAAI,CAACmH,qBAAqB,EAAE;MAC5B,IAAI,CAACD,aAAa,EAAE;QAClB,IAAI,CAACpE,UAAU,CACb3C,cAAc,CAAC2G,uBAAuB,EACtC,IAAIpI,wBAAA,CAAAqI,0BAA0B,CAAC,IAAI,EAAE;UACnCC,yBAAyB,EAAzBA;SACD,CAAC,CACH;;MAGH,IAAIA,yBAAyB,EAAE;QAC7BpE,OAAO,CAACC,QAAQ,CAAC;UAAA,OAAMwD,MAAI,CAACW,yBAAyB,CAACC,aAAa,CAAC;QAAA,EAAC;;MAGvE,IAAI,CAAC9B,gBAAgB,EAAE;IACzB;IAEA;;;;;EAAA;IAAAhC,GAAA;IAAAY,KAAA,EAKQ,SAAAiD,0BAA0BI,aAAqB;MAAA,IAAAC,SAAA,GAAAC,0BAAA,CAC5B,IAAI,CAACrI,WAAW,CAAC;QAAAsI,KAAA;MAAA;QAA1C,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAA4C;UAAA,IAAjCrC,UAAU,GAAAkC,KAAA,CAAAxD,KAAA;UACnB,IAAIsB,UAAU,CAACsB,UAAU,IAAIS,aAAa,EAAE;YAC1C,IAAI,CAAChC,OAAO,CAACC,UAAU,CAAC;YACxBA,UAAU,CAACsC,OAAO,CAAC,IAAIhJ,QAAA,CAAAiJ,yBAAyB,CAAC,IAAI,CAAC,CAAC;;;MAE1D,SAAAC,GAAA;QAAAR,SAAA,CAAAS,CAAA,CAAAD,GAAA;MAAA;QAAAR,SAAA,CAAAU,CAAA;MAAA;IACH;EAAC;IAAA5E,GAAA;IAAAY,KAAA,EAKD,SAAAiE,MAAMC,QAAwC,EAAEC,GAAoB;MAAA,IAAAC,MAAA;MAClE,IAAI1H,OAAO,GAAGwH,QAAwB;MACtC,IAAM1D,QAAQ,GAAI2D,GAAG,aAAHA,GAAG,cAAHA,GAAG,GAAID,QAA2B;MACpD,IAAI,OAAOxH,OAAO,KAAK,UAAU,EAAE;QACjCA,OAAO,GAAG,EAAE;;MAGdA,OAAO,GAAGX,MAAM,CAACsI,MAAM,CAAC;QAAEC,KAAK,EAAE;MAAK,CAAE,EAAE5H,OAAO,CAAC;MAClD,IAAI,IAAI,CAACP,MAAM,EAAE;QACf,OAAOqE,QAAQ,EAAE;;MAGnB;MACA,IAAI,CAACjF,kBAAkB,CAAC,CAACgJ,IAAI,CAAC,QAAQ,CAAC;MAEvC;MACA,IAAI,OAAO,IAAI,CAACjJ,kBAAkB,CAAC,CAACkJ,MAAM,KAAK,UAAU,EAAE;QACzD,IAAI,CAAClJ,kBAAkB,CAAC,CAACkJ,MAAM,CAACtG,SAAS,CAAC;;MAG5C,IAAI,CAACtC,UAAU,CAAC,GAAGC,OAAA,CAAAC,SAAS,CAACK,MAAM;MACnC,IAAI,CAACiH,qBAAqB,EAAE;MAC5B,IAAI,CAAChC,gBAAgB,EAAE;MAEvB,IAAA5G,OAAA,CAAAiK,SAAS,EACP,IAAI,CAACzJ,YAAY,CAAC,CAAC0J,OAAO,EAAE,EAC5B,UAACC,IAAI,EAAEC,EAAE,EAAI;QACXR,MAAI,CAACrF,UAAU,CACb3C,cAAc,CAACyI,iBAAiB,EAChC,IAAIlK,wBAAA,CAAAmK,qBAAqB,CAACV,MAAI,EAAEO,IAAI,EAAE,YAAY,CAAC,CACpD;QACDA,IAAI,CAACI,OAAO,CAAC;UAAET,KAAK,EAAE,CAAC,CAAC5H,OAAO,CAAC4H;QAAK,CAAE,EAAEM,EAAE,CAAC;MAC9C,CAAC,EACD,UAAAd,GAAG,EAAG;QACJM,MAAI,CAACpJ,YAAY,CAAC,CAACoH,KAAK,EAAE;QAC1BgC,MAAI,CAACrF,UAAU,CAAC3C,cAAc,CAAC4I,sBAAsB,EAAE,IAAIrK,wBAAA,CAAAsK,yBAAyB,CAACb,MAAI,CAAC,CAAC;QAC3F5D,QAAQ,CAACsD,GAAG,CAAC;MACf,CAAC,CACF;IACH;IAEA;;;;;;;;;;;;;;EAAA;IAAA1E,GAAA;IAAAY,KAAA,EAcA,SAAAkF,eACEP,IAA4B,EAC5BQ,EAA0B,EAC1B3E,QAA8B;MAAA,IAAA4E,MAAA;MAE9B,IAAIT,IAAI,EAAE;QACR;QACAQ,EAAE,CAACjH,SAAS,EAAEyG,IAAI,EAAE,UAACU,KAAK,EAAEC,MAAM,EAAI;UACpC,IAAID,KAAK,EAAE;YACT,OAAOD,MAAI,CAACG,oBAAoB,CAACF,KAAK,EAAEV,IAAI,EAAEQ,EAAE,EAAE3E,QAAQ,CAAC;;UAE7DA,QAAQ,CAACtC,SAAS,EAAEoH,MAAM,CAAC;QAC7B,CAAC,CAAC;QACF;;MAGF,IAAI,CAAC/E,QAAQ,CAAC,UAACuD,GAAG,EAAEa,IAAI,EAAI;QAC1B;QACAQ,EAAE,CAACrB,GAAiB,EAAEa,IAAI,EAAE,UAACU,KAAK,EAAEC,MAAM,EAAI;UAC5C,IAAID,KAAK,EAAE;YACT,IAAIV,IAAI,EAAE;cACRS,MAAI,CAACG,oBAAoB,CAACF,KAAK,EAAEV,IAAI,EAAEQ,EAAE,EAAE3E,QAAQ,CAAC;aACrD,MAAM;cACLA,QAAQ,CAAC6E,KAAK,CAAC;;WAElB,MAAM;YACL7E,QAAQ,CAACtC,SAAS,EAAEoH,MAAM,CAAC;;UAG7B,IAAIX,IAAI,EAAE;YACRS,MAAI,CAAC/D,OAAO,CAACsD,IAAI,CAAC;;QAEtB,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ;EAAC;IAAAvF,GAAA;IAAAY,KAAA,EAEO,SAAAuF,qBACNF,KAAe,EACfV,IAAgB,EAChBQ,EAA0B,EAC1B3E,QAA8B;MAE9B,IAAI6E,KAAK,YAAY/K,OAAA,CAAAkL,UAAU,IAAIH,KAAK,CAACI,IAAI,KAAKnL,OAAA,CAAAoL,mBAAmB,CAACC,cAAc,EAAE;QACpF,IAAI,CAACC,cAAc,CAACjB,IAAI,EAAEQ,EAAE,EAAE,UAACpF,KAAK,EAAE8F,GAAG,EAAI;UAC3C,IAAI9F,KAAK,EAAE;YACT,OAAOS,QAAQ,CAACT,KAAK,CAAC;;UAExBS,QAAQ,CAACtC,SAAS,EAAE2H,GAAG,CAAC;QAC1B,CAAC,CAAC;OACH,MAAM;QACLrF,QAAQ,CAAC6E,KAAK,CAAC;;IAEnB;IAEA;;;EAAA;IAAAjG,GAAA;IAAAY,KAAA,EAGQ,SAAA4F,eACNtE,UAAsB,EACtB6D,EAA0B,EAC1B3E,QAAkB;MAElB,IAAMsF,WAAW,GAAGxE,UAAU,CAACwE,WAAW;MAC1C,IAAI,CAACA,WAAW,EAAE;QAChB,OAAOtF,QAAQ,CAAC,IAAIlG,OAAA,CAAAmI,iBAAiB,CAAC,sCAAsC,CAAC,CAAC;;MAEhF,IAAMsD,WAAW,GAAGD,WAAW,CAACC,WAAW;MAC3C,IAAI,CAACA,WAAW,EAAE;QAChB,OAAOvF,QAAQ,CACb,IAAIlG,OAAA,CAAA0L,4BAA4B,CAC9B,gEAAgE,CACjE,CACF;;MAEH,IAAMC,mBAAmB,GAAGF,WAAW,CAACG,oBAAoB,CAAC5E,UAAU,CAAC6E,KAAK,IAAIjI,SAAS,CAAC;MAC3F,IAAMkI,QAAQ,GAAG3L,SAAA,CAAA4L,cAAc,CAAChH,GAAG,CAAC4G,mBAAmB,CAACK,SAAS,CAAC;MAClE,IAAI,CAACF,QAAQ,EAAE;QACb,OAAO5F,QAAQ,CACb,IAAIlG,OAAA,CAAA0L,4BAA4B,sDAAAO,MAAA,CACuBR,WAAW,CAACO,SAAS,CAAE,CAC7E,CACF;;MAEHF,QAAQ,CAACI,MAAM,CAACV,WAAW,CAAC,CAACW,IAAI,CAC/B,YAAK;QACHtB,EAAE,CAACjH,SAAS,EAAEoD,UAAU,EAAE,UAAC+D,KAAK,EAAEqB,QAAQ,EAAI;UAC5C,IAAIrB,KAAK,EAAE;YACT,OAAO7E,QAAQ,CAAC6E,KAAK,CAAC;;UAExB7E,QAAQ,CAACtC,SAAS,EAAEwI,QAAQ,CAAC;QAC/B,CAAC,CAAC;MACJ,CAAC,EACD,UAAA3G,KAAK;QAAA,OAAIS,QAAQ,CAACT,KAAK,CAAC;MAAA,EACzB;IACH;IAEA;EAAA;IAAAX,GAAA;IAAAY,KAAA,EACQ,SAAAoD,sBAAA,EAAqB;MAC3B,IAAMuD,gBAAgB,GAAG,IAAI,CAACxL,iBAAiB,CAAC;MAChD,IAAIwL,gBAAgB,EAAE;QACpB,IAAAxM,QAAA,CAAAkG,YAAY,EAACsG,gBAAgB,CAAC;;IAElC;EAAC;IAAAvH,GAAA;IAAAY,KAAA,EAEO,SAAAmC,kBACNb,UAAsB,EACtBY,MAAiD;MAEjD,IAAI,CAACnD,UAAU,CACb3C,cAAc,CAACyI,iBAAiB,EAChC,IAAIlK,wBAAA,CAAAmK,qBAAqB,CAAC,IAAI,EAAExD,UAAU,EAAEY,MAAM,CAAC,CACpD;MACD;MACArD,OAAO,CAACC,QAAQ,CAAC;QAAA,OAAMwC,UAAU,CAACyD,OAAO,CAAC;UAAET,KAAK,EAAE;QAAK,CAAE,CAAC;MAAA,EAAC;IAC9D;EAAC;IAAAlF,GAAA;IAAAY,KAAA,EAEO,SAAA2B,kBAAkBL,UAAsB;MAC9C,IAAMkB,SAAS,GAAGlB,UAAU,CAACkB,SAAS;MACtC,IAAI,IAAI,CAAC3C,YAAY,IAAI2C,SAAS,EAAE;QAClC,IAAME,GAAG,GAAGF,SAAS,CAACG,WAAW,EAAE;QACnC,IAAMC,UAAU,GAAG,IAAI,CAACC,kBAAkB,CAACxD,GAAG,CAACqD,GAAG,CAAC;QACnD,OAAOpB,UAAU,CAACsB,UAAU,KAAKA,UAAU;;MAG7C,OAAOtB,UAAU,CAACsB,UAAU,KAAK,IAAI,CAACxH,WAAW,CAAC;IACpD;EAAC;IAAAgE,GAAA;IAAAY,KAAA,EAEO,SAAA4G,iBAAiBtF,UAAsB;MAC7C,OAAO,CAAC,EAAE,IAAI,CAAC5E,OAAO,CAACgB,aAAa,IAAI4D,UAAU,CAACuF,QAAQ,GAAG,IAAI,CAACnK,OAAO,CAACgB,aAAa,CAAC;IAC3F;IAEA;;;;;EAAA;IAAA0B,GAAA;IAAAY,KAAA,EAKQ,SAAA8G,4BAA4BxF,UAAsB;MACxD,IAAMyF,OAAO,GAAG,IAAI,CAACpF,iBAAiB,CAACL,UAAU,CAAC;MAClD,IAAM0F,MAAM,GAAG,IAAI,CAACJ,gBAAgB,CAACtF,UAAU,CAAC;MAChD,IAAI,CAACyF,OAAO,IAAI,CAACC,MAAM,IAAI,CAAC1F,UAAU,CAACnF,MAAM,EAAE;QAC7C,OAAO,KAAK;;MAEd,IAAM+F,MAAM,GAAGZ,UAAU,CAACnF,MAAM,GAAG,OAAO,GAAG4K,OAAO,GAAG,OAAO,GAAG,MAAM;MACvE,IAAI,CAAC5E,iBAAiB,CAACb,UAAU,EAAEY,MAAM,CAAC;MAC1C,OAAO,IAAI;IACb;EAAC;IAAA9C,GAAA;IAAAY,KAAA,EAEO,SAAAiH,iBAAiBzG,QAA8B;MAAA,IAAA0G,MAAA;MACrD,IAAMC,cAAc,GAAA/J,aAAA,CAAAA,aAAA,KACf,IAAI,CAACV,OAAO;QACf0K,EAAE,EAAE,IAAI,CAAC9L,kBAAkB,CAAC,CAAC+L,IAAI,EAAE,CAACrH,KAAK;QACzC4C,UAAU,EAAE,IAAI,CAACxH,WAAW,CAAC;QAC7BkM,iBAAiB,EAAE,IAAI,CAAC/L,kBAAkB;MAAC,EAC5C;MAED,IAAI,CAACN,QAAQ,CAAC,EAAE;MAChB;MACA,IAAI,CAAC8D,UAAU,CACb3C,cAAc,CAACmL,kBAAkB,EACjC,IAAI5M,wBAAA,CAAA6M,sBAAsB,CAAC,IAAI,EAAE;QAAEJ,EAAE,EAAED,cAAc,CAACC;MAAE,CAAE,CAAC,CAC5D;MAED,IAAA3M,SAAA,CAAAgN,OAAO,EAACN,cAAc,EAAE,UAACrD,GAAG,EAAExC,UAAU,EAAI;QAC1C,IAAIwC,GAAG,IAAI,CAACxC,UAAU,EAAE;UACtB4F,MAAI,CAACjM,QAAQ,CAAC,EAAE;UAChBiM,MAAI,CAACnI,UAAU,CACb3C,cAAc,CAACyI,iBAAiB,EAChC,IAAIlK,wBAAA,CAAAmK,qBAAqB,CACvBoC,MAAI,EACJ;YAAEE,EAAE,EAAED,cAAc,CAACC,EAAE;YAAE5E,SAAS,EAAEtE;UAAS,CAAE,EAC/C,OAAO;UACP;UACA4F,GAAiB,CAClB,CACF;UACD,IAAIA,GAAG,YAAYxJ,OAAA,CAAAoN,iBAAiB,IAAI5D,GAAG,YAAYxJ,OAAA,CAAAqN,gBAAgB,EAAE;YACvE7D,GAAG,CAAC8D,oBAAoB,GAAGT,cAAc,CAACvE,UAAU;;UAEtDpC,QAAQ,CAACsD,GAAG,aAAHA,GAAG,cAAHA,GAAG,GAAI,IAAIxJ,OAAA,CAAAmI,iBAAiB,CAAC,0CAA0C,CAAC,CAAC;UAClF;;QAGF;QACA,IAAIyE,MAAI,CAACtL,UAAU,CAAC,KAAKC,OAAA,CAAAC,SAAS,CAACI,KAAK,EAAE;UACxCgL,MAAI,CAACjM,QAAQ,CAAC,EAAE;UAChBqG,UAAU,CAACyD,OAAO,CAAC;YAAET,KAAK,EAAE;UAAI,CAAE,CAAC;UACnC9D,QAAQ,CAAC0G,MAAI,CAAC/K,MAAM,GAAG,IAAIvB,QAAA,CAAAiN,eAAe,CAACX,MAAI,CAAC,GAAG,IAAItM,QAAA,CAAAkN,gBAAgB,CAACZ,MAAI,CAAC,CAAC;UAC9E;;QAGF;QAAA,IAAAa,KAAA,YAAAA,MAAA,EACuE;UAAlE,IAAMC,KAAK,GAAAC,IAAA,CAAAC,EAAA;UACd5G,UAAU,CAAC6G,EAAE,CAACH,KAAK,EAAE,UAACjE,CAAM;YAAA,OAAKmD,MAAI,CAAC3C,IAAI,CAACyD,KAAK,EAAEjE,CAAC,CAAC;UAAA,EAAC;SACtD;QAFD,SAAAmE,EAAA,MAAAD,IAAA,MAAA1B,MAAA,CAAA6B,kBAAA,CAAwB/N,WAAA,CAAAgO,UAAU,IAAE3N,YAAA,CAAA4C,UAAU,CAACgL,qBAAqB,IAAAJ,EAAA,GAAAD,IAAA,CAAAtI,MAAA,EAAAuI,EAAA;UAAAH,KAAA;QAAA;QAIpE,IAAIb,MAAI,CAACrH,YAAY,EAAE;UACrByB,UAAU,CAAC6G,EAAE,CAACzN,YAAA,CAAA4C,UAAU,CAACiL,MAAM,EAAE,UAAAC,OAAO;YAAA,OAAItB,MAAI,CAACxL,QAAQ,CAAC,CAAC+M,UAAU,CAACD,OAAO,CAAC;UAAA,EAAC;UAC/ElH,UAAU,CAAC6G,EAAE,CAACzN,YAAA,CAAA4C,UAAU,CAACoL,QAAQ,EAAE,UAAAF,OAAO;YAAA,OAAItB,MAAI,CAACxL,QAAQ,CAAC,CAACiN,YAAY,CAACH,OAAO,CAAC;UAAA,EAAC;UAEnF,IAAMhG,SAAS,GAAGlB,UAAU,CAACkB,SAAS;UACtC,IAAIA,SAAS,EAAE;YACb,IAAII,UAAU;YACd,IAAMF,GAAG,GAAGF,SAAS,CAACG,WAAW,EAAE;YACnC,IAAKC,UAAU,GAAGsE,MAAI,CAACrE,kBAAkB,CAACxD,GAAG,CAACqD,GAAG,CAAC,EAAG;cACnDpB,UAAU,CAACsB,UAAU,GAAGA,UAAU;aACnC,MAAM;cACLsE,MAAI,CAACrE,kBAAkB,CAACC,GAAG,CAACJ,GAAG,EAAE,CAAC,CAAC;cACnCpB,UAAU,CAACsB,UAAU,GAAG,CAAC;;;;QAK/BtB,UAAU,CAACO,aAAa,EAAE;QAC1BqF,MAAI,CAACnI,UAAU,CAAC3C,cAAc,CAACwM,gBAAgB,EAAE,IAAIjO,wBAAA,CAAAkO,oBAAoB,CAAC3B,MAAI,EAAE5F,UAAU,CAAC,CAAC;QAE5F4F,MAAI,CAACjM,QAAQ,CAAC,EAAE;QAChBuF,QAAQ,CAACtC,SAAS,EAAEoD,UAAU,CAAC;QAC/B;MACF,CAAC,CAAC;IACJ;EAAC;IAAAlC,GAAA;IAAAY,KAAA,EAEO,SAAAM,kBAAA,EAAiB;MAAA,IAAAwI,MAAA;MACvB,IAAMtL,WAAW,GAAG,IAAI,CAACd,OAAO,CAACc,WAAW;MAC5C,IAAI,IAAI,CAAC5B,UAAU,CAAC,KAAKC,OAAA,CAAAC,SAAS,CAACI,KAAK,IAAIsB,WAAW,KAAK,CAAC,EAAE;QAC7D;;MAGF,IAAI,CAACxC,YAAY,CAAC,CAAC+N,KAAK,CAAC,UAAAzH,UAAU;QAAA,OAAIwH,MAAI,CAAChC,2BAA2B,CAACxF,UAAU,CAAC;MAAA,EAAC;MAEpF,IACE,IAAI,CAAC0H,oBAAoB,GAAGxL,WAAW,IACvC,IAAI,CAACiC,sBAAsB,GAAG,IAAI,CAAC/C,OAAO,CAACe,aAAa,EACxD;QACA;QACA;QACA;QACA,IAAI,CAACwJ,gBAAgB,CAAC,UAACnD,GAAG,EAAExC,UAAU,EAAI;UACxC,IAAIwC,GAAG,EAAE;YACPgF,MAAI,CAAChO,OAAO,CAAC,CAACmO,WAAW,CAACnF,GAAG,CAAC;;UAEhC,IAAI,CAACA,GAAG,IAAIxC,UAAU,EAAE;YACtBwH,MAAI,CAAC9N,YAAY,CAAC,CAACmG,IAAI,CAACG,UAAU,CAAC;YACnCzC,OAAO,CAACC,QAAQ,CAAC;cAAA,OAAMgK,MAAI,CAAC1H,gBAAgB,EAAE;YAAA,EAAC;;UAEjD,IAAI0H,MAAI,CAAClN,UAAU,CAAC,KAAKC,OAAA,CAAAC,SAAS,CAACI,KAAK,EAAE;YACxC,IAAA/B,QAAA,CAAAkG,YAAY,EAACyI,MAAI,CAAC3N,iBAAiB,CAAC,CAAC;YACrC2N,MAAI,CAAC3N,iBAAiB,CAAC,GAAG,IAAAhB,QAAA,CAAA2G,UAAU,EAClC;cAAA,OAAMgI,MAAI,CAACxI,iBAAiB,EAAE;YAAA,GAC9BwI,MAAI,CAACpM,OAAO,CAACkB,2BAA2B,CACzC;;QAEL,CAAC,CAAC;OACH,MAAM;QACL,IAAAzD,QAAA,CAAAkG,YAAY,EAAC,IAAI,CAAClF,iBAAiB,CAAC,CAAC;QACrC,IAAI,CAACA,iBAAiB,CAAC,GAAG,IAAAhB,QAAA,CAAA2G,UAAU,EAClC;UAAA,OAAMgI,MAAI,CAACxI,iBAAiB,EAAE;QAAA,GAC9B,IAAI,CAAC5D,OAAO,CAACkB,2BAA2B,CACzC;;IAEL;EAAC;IAAAwB,GAAA;IAAAY,KAAA,EAEO,SAAAoB,iBAAA,EAAgB;MAAA,IAAA8H,MAAA;MACtB,IAAI,IAAI,CAACvN,oBAAoB,CAAC,EAAE;QAC9B;;MAEF,IAAI,CAACA,oBAAoB,CAAC,GAAG,IAAI;MAEjC,OAAO,IAAI,CAACwN,aAAa,EAAE;QACzB,IAAMvI,eAAe,GAAG,IAAI,CAACpF,UAAU,CAAC,CAAC4N,KAAK,EAAE;QAChD,IAAI,CAACxI,eAAe,EAAE;UACpB,IAAI,CAACpF,UAAU,CAAC,CAAC6N,KAAK,EAAE;UACxB;;QAGF,IAAIzI,eAAe,CAACnF,UAAU,CAAC,EAAE;UAC/B,IAAI,CAACD,UAAU,CAAC,CAAC6N,KAAK,EAAE;UACxB;;QAGF,IAAI,IAAI,CAACzN,UAAU,CAAC,KAAKC,OAAA,CAAAC,SAAS,CAACI,KAAK,EAAE;UACxC,IAAMgG,MAAM,GAAG,IAAI,CAAC/F,MAAM,GAAG,YAAY,GAAG,iBAAiB;UAC7D,IAAM4D,KAAK,GAAG,IAAI,CAAC5D,MAAM,GAAG,IAAIvB,QAAA,CAAAiN,eAAe,CAAC,IAAI,CAAC,GAAG,IAAIjN,QAAA,CAAAkN,gBAAgB,CAAC,IAAI,CAAC;UAClF,IAAI,CAAC/I,UAAU,CACb3C,cAAc,CAAC2E,2BAA2B,EAC1C,IAAIpG,wBAAA,CAAAqG,6BAA6B,CAAC,IAAI,EAAEkB,MAAM,EAAEnC,KAAK,CAAC,CACvD;UACD,IAAIa,eAAe,CAACC,KAAK,EAAE;YACzB,IAAA1G,QAAA,CAAAkG,YAAY,EAACO,eAAe,CAACC,KAAK,CAAC;;UAErC,IAAI,CAACrF,UAAU,CAAC,CAAC6N,KAAK,EAAE;UACxBzI,eAAe,CAACJ,QAAQ,CAACT,KAAK,CAAC;UAC/B;;QAGF,IAAI,CAAC,IAAI,CAACP,wBAAwB,EAAE;UAClC;;QAGF,IAAM8B,UAAU,GAAG,IAAI,CAACtG,YAAY,CAAC,CAACqO,KAAK,EAAE;QAC7C,IAAI,CAAC/H,UAAU,EAAE;UACf;;QAGF,IAAI,CAAC,IAAI,CAACwF,2BAA2B,CAACxF,UAAU,CAAC,EAAE;UACjD,IAAI,CAACpG,WAAW,CAAC,CAACoO,GAAG,CAAChI,UAAU,CAAC;UACjC,IAAI,CAACvC,UAAU,CACb3C,cAAc,CAACmN,sBAAsB,EACrC,IAAI5O,wBAAA,CAAA6O,yBAAyB,CAAC,IAAI,EAAElI,UAAU,CAAC,CAChD;UACD,IAAIV,eAAe,CAACC,KAAK,EAAE;YACzB,IAAA1G,QAAA,CAAAkG,YAAY,EAACO,eAAe,CAACC,KAAK,CAAC;;UAGrC,IAAI,CAACrF,UAAU,CAAC,CAAC6N,KAAK,EAAE;UACxBzI,eAAe,CAACJ,QAAQ,CAACtC,SAAS,EAAEoD,UAAU,CAAC;;;MAInD,IAAAmI,aAAA,GAAuC,IAAI,CAAC/M,OAAO;QAA3Ca,WAAW,GAAAkM,aAAA,CAAXlM,WAAW;QAAEE,aAAa,GAAAgM,aAAA,CAAbhM,aAAa;MAAkB,IAAAiM,MAAA,YAAAA,OAAA,EAKlD;QACA,IAAM9I,eAAe,GAAGsI,MAAI,CAAC1N,UAAU,CAAC,CAAC6N,KAAK,EAAE;QAChD,IAAI,CAACzI,eAAe,IAAIA,eAAe,CAACnF,UAAU,CAAC,EAAE;UAAA;;QAGrDyN,MAAI,CAACjC,gBAAgB,CAAC,UAACnD,GAAG,EAAExC,UAAU,EAAI;UACxC,IAAIV,eAAe,CAACnF,UAAU,CAAC,EAAE;YAC/B,IAAI,CAACqI,GAAG,IAAIxC,UAAU,EAAE;cACtB4H,MAAI,CAAClO,YAAY,CAAC,CAACmG,IAAI,CAACG,UAAU,CAAC;;WAEtC,MAAM;YACL,IAAIwC,GAAG,EAAE;cACPoF,MAAI,CAACnK,UAAU,CACb3C,cAAc,CAAC2E,2BAA2B;cAC1C;cACA,IAAIpG,wBAAA,CAAAqG,6BAA6B,CAACkI,MAAI,EAAE,iBAAiB,EAAEpF,GAAiB,CAAC,CAC9E;aACF,MAAM,IAAIxC,UAAU,EAAE;cACrB4H,MAAI,CAAChO,WAAW,CAAC,CAACoO,GAAG,CAAChI,UAAU,CAAC;cACjC4H,MAAI,CAACnK,UAAU,CACb3C,cAAc,CAACmN,sBAAsB,EACrC,IAAI5O,wBAAA,CAAA6O,yBAAyB,CAACN,MAAI,EAAE5H,UAAU,CAAC,CAChD;;YAGH,IAAIV,eAAe,CAACC,KAAK,EAAE;cACzB,IAAA1G,QAAA,CAAAkG,YAAY,EAACO,eAAe,CAACC,KAAK,CAAC;;YAErCD,eAAe,CAACJ,QAAQ,CAACsD,GAAG,EAAExC,UAAU,CAAC;;UAE3CzC,OAAO,CAACC,QAAQ,CAAC;YAAA,OAAMoK,MAAI,CAAC9H,gBAAgB,EAAE;UAAA,EAAC;QACjD,CAAC,CAAC;OACH;MApCD,OACE,IAAI,CAAC+H,aAAa,GAAG,CAAC,IACtB,IAAI,CAAC1J,sBAAsB,GAAGhC,aAAa,KAC1CF,WAAW,KAAK,CAAC,IAAI,IAAI,CAACyL,oBAAoB,GAAGzL,WAAW,CAAC;QAAA,IAAAoM,IAAA,GAAAD,MAAA;QAAA,IAAAC,IAAA,iBAI5D;MAAS;MA8Bb,IAAI,CAAChO,oBAAoB,CAAC,GAAG,KAAK;IACpC;EAAC;EAAA,OAAAS,cAAA;AAAA,EA9vBiC7B,aAAA,CAAAqP,iBAAuC;AAsBzE;;;;AAIgBxN,cAAA,CAAA4C,uBAAuB,GAAG3E,WAAA,CAAA2E,uBAAuB;AACjE;;;;AAIgB5C,cAAA,CAAA4I,sBAAsB,GAAG3K,WAAA,CAAA2K,sBAAsB;AAC/D;;;;AAIgB5I,cAAA,CAAA2G,uBAAuB,GAAG1I,WAAA,CAAA0I,uBAAuB;AACjE;;;;AAIgB3G,cAAA,CAAA+D,qBAAqB,GAAG9F,WAAA,CAAA8F,qBAAqB;AAC7D;;;;AAIgB/D,cAAA,CAAAmL,kBAAkB,GAAGlN,WAAA,CAAAkN,kBAAkB;AACvD;;;;AAIgBnL,cAAA,CAAAwM,gBAAgB,GAAGvO,WAAA,CAAAuO,gBAAgB;AACnD;;;;AAIgBxM,cAAA,CAAAyI,iBAAiB,GAAGxK,WAAA,CAAAwK,iBAAiB;AACrD;;;;AAIgBzI,cAAA,CAAAsE,4BAA4B,GAAGrG,WAAA,CAAAqG,4BAA4B;AAC3E;;;;AAIgBtE,cAAA,CAAA2E,2BAA2B,GAAG1G,WAAA,CAAA0G,2BAA2B;AACzE;;;;AAIgB3E,cAAA,CAAAmN,sBAAsB,GAAGlP,WAAA,CAAAkP,sBAAsB;AAC/D;;;;AAIgBnN,cAAA,CAAA4F,qBAAqB,GAAG3H,WAAA,CAAA2H,qBAAqB;AA5ElDnG,OAAA,CAAAO,cAAA,GAAAA,cAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}