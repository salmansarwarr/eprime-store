{"ast":null,"code":"\"use strict\";\n\nvar _get = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _createForOfIteratorHelper = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _slicedToArray = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _objectSpread = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasSessionSupport = exports.CryptoConnection = exports.Connection = void 0;\nvar timers_1 = require(\"timers\");\nvar util_1 = require(\"util\");\nvar constants_1 = require(\"../constants\");\nvar error_1 = require(\"../error\");\nvar mongo_types_1 = require(\"../mongo_types\");\nvar sessions_1 = require(\"../sessions\");\nvar utils_1 = require(\"../utils\");\nvar command_monitoring_events_1 = require(\"./command_monitoring_events\");\nvar commands_1 = require(\"./commands\");\nvar message_stream_1 = require(\"./message_stream\");\nvar stream_description_1 = require(\"./stream_description\");\nvar shared_1 = require(\"./wire_protocol/shared\");\n/** @internal */\nvar kStream = Symbol('stream');\n/** @internal */\nvar kQueue = Symbol('queue');\n/** @internal */\nvar kMessageStream = Symbol('messageStream');\n/** @internal */\nvar kGeneration = Symbol('generation');\n/** @internal */\nvar kLastUseTime = Symbol('lastUseTime');\n/** @internal */\nvar kClusterTime = Symbol('clusterTime');\n/** @internal */\nvar kDescription = Symbol('description');\n/** @internal */\nvar kHello = Symbol('hello');\n/** @internal */\nvar kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\nvar kDelayedTimeoutId = Symbol('delayedTimeoutId');\nvar INVALID_QUEUE_SIZE = 'Connection internal queue contains more than 1 operation description';\n/** @internal */\nvar Connection = /*#__PURE__*/function (_mongo_types_1$TypedE) {\n  _inherits(Connection, _mongo_types_1$TypedE);\n  var _super = _createSuper(Connection);\n  function Connection(stream, options) {\n    var _options$socketTimeou, _this$hello;\n    var _this;\n    _classCallCheck(this, Connection);\n    _this = _super.call(this);\n    _this.commandAsync = (0, util_1.promisify)(function (ns, cmd, options, callback) {\n      return _this.command(ns, cmd, options, callback);\n    });\n    _this.id = options.id;\n    _this.address = streamIdentifier(stream, options);\n    _this.socketTimeoutMS = (_options$socketTimeou = options.socketTimeoutMS) !== null && _options$socketTimeou !== void 0 ? _options$socketTimeou : 0;\n    _this.monitorCommands = options.monitorCommands;\n    _this.serverApi = options.serverApi;\n    _this.closed = false;\n    _this[kHello] = null;\n    _this[kClusterTime] = null;\n    _this[kDescription] = new stream_description_1.StreamDescription(_this.address, options);\n    _this[kGeneration] = options.generation;\n    _this[kLastUseTime] = (0, utils_1.now)();\n    // setup parser stream and message handling\n    _this[kQueue] = new Map();\n    _this[kMessageStream] = new message_stream_1.MessageStream(_objectSpread(_objectSpread({}, options), {}, {\n      maxBsonMessageSize: (_this$hello = _this.hello) === null || _this$hello === void 0 ? void 0 : _this$hello.maxBsonMessageSize\n    }));\n    _this[kStream] = stream;\n    _this[kDelayedTimeoutId] = null;\n    _this[kMessageStream].on('message', function (message) {\n      return _this.onMessage(message);\n    });\n    _this[kMessageStream].on('error', function (error) {\n      return _this.onError(error);\n    });\n    _this[kStream].on('close', function () {\n      return _this.onClose();\n    });\n    _this[kStream].on('timeout', function () {\n      return _this.onTimeout();\n    });\n    _this[kStream].on('error', function () {\n      /* ignore errors, listen to `close` instead */\n    });\n    // hook the message stream up to the passed in stream\n    _this[kStream].pipe(_this[kMessageStream]);\n    _this[kMessageStream].pipe(_this[kStream]);\n    return _this;\n  }\n  _createClass(Connection, [{\n    key: \"description\",\n    get: function get() {\n      return this[kDescription];\n    }\n  }, {\n    key: \"hello\",\n    get: function get() {\n      return this[kHello];\n    }\n    // the `connect` method stores the result of the handshake hello on the connection\n    ,\n    set: function set(response) {\n      this[kDescription].receiveResponse(response);\n      this[kDescription] = Object.freeze(this[kDescription]);\n      // TODO: remove this, and only use the `StreamDescription` in the future\n      this[kHello] = response;\n    }\n    // Set the whether the message stream is for a monitoring connection.\n  }, {\n    key: \"isMonitoringConnection\",\n    get: function get() {\n      return this[kMessageStream].isMonitoringConnection;\n    },\n    set: function set(value) {\n      this[kMessageStream].isMonitoringConnection = value;\n    }\n  }, {\n    key: \"serviceId\",\n    get: function get() {\n      var _this$hello2;\n      return (_this$hello2 = this.hello) === null || _this$hello2 === void 0 ? void 0 : _this$hello2.serviceId;\n    }\n  }, {\n    key: \"loadBalanced\",\n    get: function get() {\n      return this.description.loadBalanced;\n    }\n  }, {\n    key: \"generation\",\n    get: function get() {\n      return this[kGeneration] || 0;\n    },\n    set: function set(generation) {\n      this[kGeneration] = generation;\n    }\n  }, {\n    key: \"idleTime\",\n    get: function get() {\n      return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);\n    }\n  }, {\n    key: \"clusterTime\",\n    get: function get() {\n      return this[kClusterTime];\n    }\n  }, {\n    key: \"stream\",\n    get: function get() {\n      return this[kStream];\n    }\n  }, {\n    key: \"markAvailable\",\n    value: function markAvailable() {\n      this[kLastUseTime] = (0, utils_1.now)();\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(error) {\n      this.cleanup(true, error);\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose() {\n      var message = \"connection \".concat(this.id, \" to \").concat(this.address, \" closed\");\n      this.cleanup(true, new error_1.MongoNetworkError(message));\n    }\n  }, {\n    key: \"onTimeout\",\n    value: function onTimeout() {\n      var _this2 = this;\n      this[kDelayedTimeoutId] = (0, timers_1.setTimeout)(function () {\n        var message = \"connection \".concat(_this2.id, \" to \").concat(_this2.address, \" timed out\");\n        var beforeHandshake = _this2.hello == null;\n        _this2.cleanup(true, new error_1.MongoNetworkTimeoutError(message, {\n          beforeHandshake: beforeHandshake\n        }));\n      }, 1).unref(); // No need for this timer to hold the event loop open\n    }\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(message) {\n      var _this$kStream$timeout;\n      var delayedTimeoutId = this[kDelayedTimeoutId];\n      if (delayedTimeoutId != null) {\n        (0, timers_1.clearTimeout)(delayedTimeoutId);\n        this[kDelayedTimeoutId] = null;\n      }\n      var socketTimeoutMS = (_this$kStream$timeout = this[kStream].timeout) !== null && _this$kStream$timeout !== void 0 ? _this$kStream$timeout : 0;\n      this[kStream].setTimeout(0);\n      // always emit the message, in case we are streaming\n      this.emit('message', message);\n      var operationDescription = this[kQueue].get(message.responseTo);\n      if (!operationDescription && this.isMonitoringConnection) {\n        // This is how we recover when the initial hello's requestId is not\n        // the responseTo when hello responses have been skipped:\n        // First check if the map is of invalid size\n        if (this[kQueue].size > 1) {\n          this.cleanup(true, new error_1.MongoRuntimeError(INVALID_QUEUE_SIZE));\n        } else {\n          // Get the first orphaned operation description.\n          var entry = this[kQueue].entries().next();\n          if (entry.value != null) {\n            var _entry$value = _slicedToArray(entry.value, 2),\n              requestId = _entry$value[0],\n              orphaned = _entry$value[1];\n            // If the orphaned operation description exists then set it.\n            operationDescription = orphaned;\n            // Remove the entry with the bad request id from the queue.\n            this[kQueue].delete(requestId);\n          }\n        }\n      }\n      if (!operationDescription) {\n        return;\n      }\n      var callback = operationDescription.cb;\n      // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n      // track response, however the server currently synthetically produces remote requests\n      // making the `responseTo` change on each response\n      this[kQueue].delete(message.responseTo);\n      if ('moreToCome' in message && message.moreToCome) {\n        // If the operation description check above does find an orphaned\n        // description and sets the operationDescription then this line will put one\n        // back in the queue with the correct requestId and will resolve not being able\n        // to find the next one via the responseTo of the next streaming hello.\n        this[kQueue].set(message.requestId, operationDescription);\n        this[kStream].setTimeout(socketTimeoutMS);\n      }\n      try {\n        // Pass in the entire description because it has BSON parsing options\n        message.parse(operationDescription);\n      } catch (err) {\n        // If this error is generated by our own code, it will already have the correct class applied\n        // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n        // in either case, it should not be wrapped\n        callback(err);\n        return;\n      }\n      if (message.documents[0]) {\n        var document = message.documents[0];\n        var session = operationDescription.session;\n        if (session) {\n          (0, sessions_1.updateSessionFromResponse)(session, document);\n        }\n        if (document.$clusterTime) {\n          this[kClusterTime] = document.$clusterTime;\n          this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n        }\n        if (document.writeConcernError) {\n          callback(new error_1.MongoWriteConcernError(document.writeConcernError, document), document);\n          return;\n        }\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      }\n      callback(undefined, message.documents[0]);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options, callback) {\n      if (this.closed) {\n        process.nextTick(function () {\n          return callback === null || callback === void 0 ? void 0 : callback();\n        });\n        return;\n      }\n      if (typeof callback === 'function') {\n        this.once('close', function () {\n          return process.nextTick(function () {\n            return callback();\n          });\n        });\n      }\n      // load balanced mode requires that these listeners remain on the connection\n      // after cleanup on timeouts, errors or close so we remove them before calling\n      // cleanup.\n      this.removeAllListeners(Connection.PINNED);\n      this.removeAllListeners(Connection.UNPINNED);\n      var message = \"connection \".concat(this.id, \" to \").concat(this.address, \" closed\");\n      this.cleanup(options.force, new error_1.MongoNetworkError(message));\n    }\n    /**\n     * A method that cleans up the connection.  When `force` is true, this method\n     * forcibly destroys the socket.\n     *\n     * If an error is provided, any in-flight operations will be closed with the error.\n     *\n     * This method does nothing if the connection is already closed.\n     */\n  }, {\n    key: \"cleanup\",\n    value: function cleanup(force, error) {\n      var _this3 = this;\n      if (this.closed) {\n        return;\n      }\n      this.closed = true;\n      var completeCleanup = function completeCleanup() {\n        var _iterator = _createForOfIteratorHelper(_this3[kQueue].values()),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var op = _step.value;\n            op.cb(error);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        _this3[kQueue].clear();\n        _this3.emit(Connection.CLOSE);\n      };\n      this[kStream].removeAllListeners();\n      this[kMessageStream].removeAllListeners();\n      this[kMessageStream].destroy();\n      if (force) {\n        this[kStream].destroy();\n        completeCleanup();\n        return;\n      }\n      if (!this[kStream].writableEnded) {\n        this[kStream].end(function () {\n          _this3[kStream].destroy();\n          completeCleanup();\n        });\n      } else {\n        completeCleanup();\n      }\n    }\n  }, {\n    key: \"command\",\n    value: function command(ns, _command, options, callback) {\n      var cmd = _objectSpread({}, _command);\n      var readPreference = (0, shared_1.getReadPreference)(options);\n      var shouldUseOpMsg = supportsOpMsg(this);\n      var session = options === null || options === void 0 ? void 0 : options.session;\n      var clusterTime = this.clusterTime;\n      if (this.serverApi) {\n        var _this$serverApi = this.serverApi,\n          version = _this$serverApi.version,\n          strict = _this$serverApi.strict,\n          deprecationErrors = _this$serverApi.deprecationErrors;\n        cmd.apiVersion = version;\n        if (strict != null) cmd.apiStrict = strict;\n        if (deprecationErrors != null) cmd.apiDeprecationErrors = deprecationErrors;\n      }\n      if (hasSessionSupport(this) && session) {\n        if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n          clusterTime = session.clusterTime;\n        }\n        var err = (0, sessions_1.applySession)(session, cmd, options);\n        if (err) {\n          return callback(err);\n        }\n      } else if (session !== null && session !== void 0 && session.explicit) {\n        return callback(new error_1.MongoCompatibilityError('Current topology does not support sessions'));\n      }\n      // if we have a known cluster time, gossip it\n      if (clusterTime) {\n        cmd.$clusterTime = clusterTime;\n      }\n      if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n        cmd = {\n          $query: cmd,\n          $readPreference: readPreference.toJSON()\n        };\n      }\n      var commandOptions = Object.assign({\n        numberToSkip: 0,\n        numberToReturn: -1,\n        checkKeys: false,\n        // This value is not overridable\n        secondaryOk: readPreference.secondaryOk()\n      }, options);\n      var cmdNs = \"\".concat(ns.db, \".$cmd\");\n      var message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, cmd, commandOptions) : new commands_1.Query(cmdNs, cmd, commandOptions);\n      try {\n        write(this, message, commandOptions, callback);\n      } catch (err) {\n        callback(err);\n      }\n    }\n  }]);\n  return Connection;\n}(mongo_types_1.TypedEventEmitter);\n/** @event */\nConnection.COMMAND_STARTED = constants_1.COMMAND_STARTED;\n/** @event */\nConnection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;\n/** @event */\nConnection.COMMAND_FAILED = constants_1.COMMAND_FAILED;\n/** @event */\nConnection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;\n/** @event */\nConnection.CLOSE = constants_1.CLOSE;\n/** @event */\nConnection.MESSAGE = constants_1.MESSAGE;\n/** @event */\nConnection.PINNED = constants_1.PINNED;\n/** @event */\nConnection.UNPINNED = constants_1.UNPINNED;\nexports.Connection = Connection;\n/** @internal */\nvar CryptoConnection = /*#__PURE__*/function (_Connection) {\n  _inherits(CryptoConnection, _Connection);\n  var _super2 = _createSuper(CryptoConnection);\n  function CryptoConnection(stream, options) {\n    var _this4;\n    _classCallCheck(this, CryptoConnection);\n    _this4 = _super2.call(this, stream, options);\n    _this4[kAutoEncrypter] = options.autoEncrypter;\n    return _this4;\n  }\n  /** @internal @override */\n  _createClass(CryptoConnection, [{\n    key: \"command\",\n    value: function command(ns, cmd, options, callback) {\n      var _this5 = this;\n      var autoEncrypter = this[kAutoEncrypter];\n      if (!autoEncrypter) {\n        return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n      }\n      var serverWireVersion = (0, utils_1.maxWireVersion)(this);\n      if (serverWireVersion === 0) {\n        // This means the initial handshake hasn't happened yet\n        return _get(_getPrototypeOf(CryptoConnection.prototype), \"command\", this).call(this, ns, cmd, options, callback);\n      }\n      if (serverWireVersion < 8) {\n        callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n        return;\n      }\n      // Save sort or indexKeys based on the command being run\n      // the encrypt API serializes our JS objects to BSON to pass to the native code layer\n      // and then deserializes the encrypted result, the protocol level components\n      // of the command (ex. sort) are then converted to JS objects potentially losing\n      // import key order information. These fields are never encrypted so we can save the values\n      // from before the encryption and replace them after encryption has been performed\n      var sort = cmd.find || cmd.findAndModify ? cmd.sort : null;\n      var indexKeys = cmd.createIndexes ? cmd.indexes.map(function (index) {\n        return index.key;\n      }) : null;\n      autoEncrypter.encrypt(ns.toString(), cmd, options, function (err, encrypted) {\n        if (err || encrypted == null) {\n          callback(err, null);\n          return;\n        }\n        // Replace the saved values\n        if (sort != null && (cmd.find || cmd.findAndModify)) {\n          encrypted.sort = sort;\n        }\n        if (indexKeys != null && cmd.createIndexes) {\n          var _iterator2 = _createForOfIteratorHelper(indexKeys.entries()),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                offset = _step2$value[0],\n                index = _step2$value[1];\n              encrypted.indexes[offset].key = index;\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n        _get(_getPrototypeOf(CryptoConnection.prototype), \"command\", _this5).call(_this5, ns, encrypted, options, function (err, response) {\n          if (err || response == null) {\n            callback(err, response);\n            return;\n          }\n          autoEncrypter.decrypt(response, options, callback);\n        });\n      });\n    }\n  }]);\n  return CryptoConnection;\n}(Connection);\nexports.CryptoConnection = CryptoConnection;\n/** @internal */\nfunction hasSessionSupport(conn) {\n  var description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null;\n}\nexports.hasSessionSupport = hasSessionSupport;\nfunction supportsOpMsg(conn) {\n  var description = conn.description;\n  if (description == null) {\n    return false;\n  }\n  return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;\n}\nfunction streamIdentifier(stream, options) {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n  var remoteAddress = stream.remoteAddress,\n    remotePort = stream.remotePort;\n  if (typeof remoteAddress === 'string' && typeof remotePort === 'number') {\n    return utils_1.HostAddress.fromHostPort(remoteAddress, remotePort).toString();\n  }\n  return (0, utils_1.uuidV4)().toString('hex');\n}\nfunction write(conn, command, options, callback) {\n  var _options;\n  options = (_options = options) !== null && _options !== void 0 ? _options : {};\n  var operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    // for BSON parsing\n    useBigInt64: typeof options.useBigInt64 === 'boolean' ? options.useBigInt64 : false,\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n  if (typeof options.socketTimeoutMS === 'number') {\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  } else if (conn.socketTimeoutMS !== 0) {\n    conn[kStream].setTimeout(conn.socketTimeoutMS);\n  }\n  // if command monitoring is enabled we need to modify the callback here\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n    operationDescription.started = (0, utils_1.now)();\n    operationDescription.cb = function (err, reply) {\n      // Command monitoring spec states that if ok is 1, then we must always emit\n      // a command succeeded event, even if there's an error. Write concern errors\n      // will have an ok: 1 in their reply.\n      if (err && (reply === null || reply === void 0 ? void 0 : reply.ok) !== 1) {\n        conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n        } else {\n          conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n        }\n      }\n      if (typeof callback === 'function') {\n        // Since we're passing through the reply with the write concern error now, we\n        // need it not to be provided to the original callback in this case so\n        // retryability does not get tricked into thinking the command actually\n        // succeeded.\n        callback(err, err instanceof error_1.MongoWriteConcernError ? undefined : reply);\n      }\n    };\n  }\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}","map":{"version":3,"names":["timers_1","require","util_1","constants_1","error_1","mongo_types_1","sessions_1","utils_1","command_monitoring_events_1","commands_1","message_stream_1","stream_description_1","shared_1","kStream","Symbol","kQueue","kMessageStream","kGeneration","kLastUseTime","kClusterTime","kDescription","kHello","kAutoEncrypter","kDelayedTimeoutId","INVALID_QUEUE_SIZE","Connection","_mongo_types_1$TypedE","_inherits","_super","_createSuper","stream","options","_options$socketTimeou","_this$hello","_this","_classCallCheck","call","commandAsync","promisify","ns","cmd","callback","command","id","address","streamIdentifier","socketTimeoutMS","monitorCommands","serverApi","closed","StreamDescription","generation","now","Map","MessageStream","_objectSpread","maxBsonMessageSize","hello","on","message","onMessage","error","onError","onClose","onTimeout","pipe","_createClass","key","get","set","response","receiveResponse","Object","freeze","isMonitoringConnection","value","_this$hello2","serviceId","description","loadBalanced","calculateDurationInMs","markAvailable","cleanup","concat","MongoNetworkError","_this2","setTimeout","beforeHandshake","MongoNetworkTimeoutError","unref","_this$kStream$timeout","delayedTimeoutId","clearTimeout","timeout","emit","operationDescription","responseTo","size","MongoRuntimeError","entry","entries","next","_entry$value","_slicedToArray","requestId","orphaned","delete","cb","moreToCome","parse","err","documents","document","session","updateSessionFromResponse","$clusterTime","CLUSTER_TIME_RECEIVED","writeConcernError","MongoWriteConcernError","ok","$err","errmsg","code","MongoServerError","undefined","destroy","process","nextTick","once","removeAllListeners","PINNED","UNPINNED","force","_this3","completeCleanup","_iterator","_createForOfIteratorHelper","values","_step","s","n","done","op","e","f","clear","CLOSE","writableEnded","end","readPreference","getReadPreference","shouldUseOpMsg","supportsOpMsg","clusterTime","_this$serverApi","version","strict","deprecationErrors","apiVersion","apiStrict","apiDeprecationErrors","hasSessionSupport","greaterThan","applySession","explicit","MongoCompatibilityError","isSharded","mode","$query","$readPreference","toJSON","commandOptions","assign","numberToSkip","numberToReturn","checkKeys","secondaryOk","cmdNs","db","Msg","Query","write","TypedEventEmitter","COMMAND_STARTED","COMMAND_SUCCEEDED","COMMAND_FAILED","MESSAGE","exports","CryptoConnection","_Connection","_super2","_this4","autoEncrypter","_this5","MongoMissingDependencyError","serverWireVersion","maxWireVersion","_get","_getPrototypeOf","prototype","sort","find","findAndModify","indexKeys","createIndexes","indexes","map","index","encrypt","toString","encrypted","_iterator2","_step2","_step2$value","offset","decrypt","conn","logicalSessionTimeoutMinutes","__nodejs_mock_server__","proxyHost","hostAddress","remoteAddress","remotePort","HostAddress","fromHostPort","uuidV4","_options","noResponse","documentsReturnedIn","useBigInt64","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","enableUtf8Validation","raw","started","compressor","agreedCompressor","zlibCompressionLevel","CommandStartedEvent","reply","CommandFailedEvent","CommandSucceededEvent","writeCommand"],"sources":["/home/salman/Documents/GitHub/FakeShop/node_modules/mongodb/src/cmap/connection.ts"],"sourcesContent":["import { clearTimeout, setTimeout } from 'timers';\nimport { promisify } from 'util';\n\nimport type { BSONSerializeOptions, Document, ObjectId } from '../bson';\nimport {\n  CLOSE,\n  CLUSTER_TIME_RECEIVED,\n  COMMAND_FAILED,\n  COMMAND_STARTED,\n  COMMAND_SUCCEEDED,\n  MESSAGE,\n  PINNED,\n  UNPINNED\n} from '../constants';\nimport type { AutoEncrypter } from '../deps';\nimport {\n  MongoCompatibilityError,\n  MongoMissingDependencyError,\n  MongoNetworkError,\n  MongoNetworkTimeoutError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoWriteConcernError\n} from '../error';\nimport type { ServerApi, SupportedNodeConnectionOptions } from '../mongo_client';\nimport { type CancellationToken, TypedEventEmitter } from '../mongo_types';\nimport type { ReadPreferenceLike } from '../read_preference';\nimport { applySession, type ClientSession, updateSessionFromResponse } from '../sessions';\nimport {\n  calculateDurationInMs,\n  type Callback,\n  HostAddress,\n  maxWireVersion,\n  type MongoDBNamespace,\n  now,\n  uuidV4\n} from '../utils';\nimport type { WriteConcern } from '../write_concern';\nimport type { AuthContext } from './auth/auth_provider';\nimport type { MongoCredentials } from './auth/mongo_credentials';\nimport {\n  CommandFailedEvent,\n  CommandStartedEvent,\n  CommandSucceededEvent\n} from './command_monitoring_events';\nimport { type BinMsg, Msg, Query, type Response, type WriteProtocolMessageType } from './commands';\nimport type { Stream } from './connect';\nimport type { ClientMetadata } from './handshake/client_metadata';\nimport { MessageStream, type OperationDescription } from './message_stream';\nimport { StreamDescription, type StreamDescriptionOptions } from './stream_description';\nimport { getReadPreference, isSharded } from './wire_protocol/shared';\n\n/** @internal */\nconst kStream = Symbol('stream');\n/** @internal */\nconst kQueue = Symbol('queue');\n/** @internal */\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\nconst kGeneration = Symbol('generation');\n/** @internal */\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\nconst kDescription = Symbol('description');\n/** @internal */\nconst kHello = Symbol('hello');\n/** @internal */\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\nconst kDelayedTimeoutId = Symbol('delayedTimeoutId');\n\nconst INVALID_QUEUE_SIZE = 'Connection internal queue contains more than 1 operation description';\n\n/** @internal */\nexport interface CommandOptions extends BSONSerializeOptions {\n  secondaryOk?: boolean;\n  /** Specify read preference if command supports it */\n  readPreference?: ReadPreferenceLike;\n  monitoring?: boolean;\n  socketTimeoutMS?: number;\n  /** Session to use for the operation */\n  session?: ClientSession;\n  documentsReturnedIn?: string;\n  noResponse?: boolean;\n  omitReadPreference?: boolean;\n\n  // TODO(NODE-2802): Currently the CommandOptions take a property willRetryWrite which is a hint\n  // from executeOperation that the txnNum should be applied to this command.\n  // Applying a session to a command should happen as part of command construction,\n  // most likely in the CommandOperation#executeCommand method, where we have access to\n  // the details we need to determine if a txnNum should also be applied.\n  willRetryWrite?: boolean;\n\n  writeConcern?: WriteConcern;\n}\n\n/** @public */\nexport interface ProxyOptions {\n  proxyHost?: string;\n  proxyPort?: number;\n  proxyUsername?: string;\n  proxyPassword?: string;\n}\n\n/** @public */\nexport interface ConnectionOptions\n  extends SupportedNodeConnectionOptions,\n    StreamDescriptionOptions,\n    ProxyOptions {\n  // Internal creation info\n  id: number | '<monitor>';\n  generation: number;\n  hostAddress: HostAddress;\n  // Settings\n  autoEncrypter?: AutoEncrypter;\n  serverApi?: ServerApi;\n  monitorCommands: boolean;\n  /** @internal */\n  connectionType?: typeof Connection;\n  credentials?: MongoCredentials;\n  connectTimeoutMS?: number;\n  tls: boolean;\n  /** @deprecated - Will not be able to turn off in the future. */\n  keepAlive?: boolean;\n  /** @deprecated - Will not be configurable in the future. */\n  keepAliveInitialDelay?: number;\n  noDelay?: boolean;\n  socketTimeoutMS?: number;\n  cancellationToken?: CancellationToken;\n  metadata: ClientMetadata;\n}\n\n/** @internal */\nexport interface DestroyOptions {\n  /** Force the destruction. */\n  force: boolean;\n}\n\n/** @public */\nexport type ConnectionEvents = {\n  commandStarted(event: CommandStartedEvent): void;\n  commandSucceeded(event: CommandSucceededEvent): void;\n  commandFailed(event: CommandFailedEvent): void;\n  clusterTimeReceived(clusterTime: Document): void;\n  close(): void;\n  message(message: any): void;\n  pinned(pinType: string): void;\n  unpinned(pinType: string): void;\n};\n\n/** @internal */\nexport class Connection extends TypedEventEmitter<ConnectionEvents> {\n  id: number | '<monitor>';\n  address: string;\n  socketTimeoutMS: number;\n  monitorCommands: boolean;\n  /** Indicates that the connection (including underlying TCP socket) has been closed. */\n  closed: boolean;\n  lastHelloMS?: number;\n  serverApi?: ServerApi;\n  helloOk?: boolean;\n  commandAsync: (\n    ns: MongoDBNamespace,\n    cmd: Document,\n    options: CommandOptions | undefined\n  ) => Promise<Document>;\n  /** @internal */\n  authContext?: AuthContext;\n\n  /**@internal */\n  [kDelayedTimeoutId]: NodeJS.Timeout | null;\n  /** @internal */\n  [kDescription]: StreamDescription;\n  /** @internal */\n  [kGeneration]: number;\n  /** @internal */\n  [kLastUseTime]: number;\n  /** @internal */\n  [kQueue]: Map<number, OperationDescription>;\n  /** @internal */\n  [kMessageStream]: MessageStream;\n  /** @internal */\n  [kStream]: Stream;\n  /** @internal */\n  [kHello]: Document | null;\n  /** @internal */\n  [kClusterTime]: Document | null;\n\n  /** @event */\n  static readonly COMMAND_STARTED = COMMAND_STARTED;\n  /** @event */\n  static readonly COMMAND_SUCCEEDED = COMMAND_SUCCEEDED;\n  /** @event */\n  static readonly COMMAND_FAILED = COMMAND_FAILED;\n  /** @event */\n  static readonly CLUSTER_TIME_RECEIVED = CLUSTER_TIME_RECEIVED;\n  /** @event */\n  static readonly CLOSE = CLOSE;\n  /** @event */\n  static readonly MESSAGE = MESSAGE;\n  /** @event */\n  static readonly PINNED = PINNED;\n  /** @event */\n  static readonly UNPINNED = UNPINNED;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super();\n\n    this.commandAsync = promisify(\n      (\n        ns: MongoDBNamespace,\n        cmd: Document,\n        options: CommandOptions | undefined,\n        callback: Callback\n      ) => this.command(ns, cmd, options, callback as any)\n    );\n\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = options.socketTimeoutMS ?? 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this[kHello] = null;\n    this[kClusterTime] = null;\n\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = now();\n\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream({\n      ...options,\n      maxBsonMessageSize: this.hello?.maxBsonMessageSize\n    });\n    this[kStream] = stream;\n\n    this[kDelayedTimeoutId] = null;\n\n    this[kMessageStream].on('message', message => this.onMessage(message));\n    this[kMessageStream].on('error', error => this.onError(error));\n    this[kStream].on('close', () => this.onClose());\n    this[kStream].on('timeout', () => this.onTimeout());\n    this[kStream].on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n\n    // hook the message stream up to the passed in stream\n    this[kStream].pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(this[kStream]);\n  }\n\n  get description(): StreamDescription {\n    return this[kDescription];\n  }\n\n  get hello(): Document | null {\n    return this[kHello];\n  }\n\n  // the `connect` method stores the result of the handshake hello on the connection\n  set hello(response: Document | null) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]);\n\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kHello] = response;\n  }\n\n  // Set the whether the message stream is for a monitoring connection.\n  set isMonitoringConnection(value: boolean) {\n    this[kMessageStream].isMonitoringConnection = value;\n  }\n\n  get isMonitoringConnection(): boolean {\n    return this[kMessageStream].isMonitoringConnection;\n  }\n\n  get serviceId(): ObjectId | undefined {\n    return this.hello?.serviceId;\n  }\n\n  get loadBalanced(): boolean {\n    return this.description.loadBalanced;\n  }\n\n  get generation(): number {\n    return this[kGeneration] || 0;\n  }\n\n  set generation(generation: number) {\n    this[kGeneration] = generation;\n  }\n\n  get idleTime(): number {\n    return calculateDurationInMs(this[kLastUseTime]);\n  }\n\n  get clusterTime(): Document | null {\n    return this[kClusterTime];\n  }\n\n  get stream(): Stream {\n    return this[kStream];\n  }\n\n  markAvailable(): void {\n    this[kLastUseTime] = now();\n  }\n\n  onError(error: Error) {\n    this.cleanup(true, error);\n  }\n\n  onClose() {\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(true, new MongoNetworkError(message));\n  }\n\n  onTimeout() {\n    this[kDelayedTimeoutId] = setTimeout(() => {\n      const message = `connection ${this.id} to ${this.address} timed out`;\n      const beforeHandshake = this.hello == null;\n      this.cleanup(true, new MongoNetworkTimeoutError(message, { beforeHandshake }));\n    }, 1).unref(); // No need for this timer to hold the event loop open\n  }\n\n  onMessage(message: BinMsg | Response) {\n    const delayedTimeoutId = this[kDelayedTimeoutId];\n    if (delayedTimeoutId != null) {\n      clearTimeout(delayedTimeoutId);\n      this[kDelayedTimeoutId] = null;\n    }\n\n    const socketTimeoutMS = this[kStream].timeout ?? 0;\n    this[kStream].setTimeout(0);\n\n    // always emit the message, in case we are streaming\n    this.emit('message', message);\n    let operationDescription = this[kQueue].get(message.responseTo);\n\n    if (!operationDescription && this.isMonitoringConnection) {\n      // This is how we recover when the initial hello's requestId is not\n      // the responseTo when hello responses have been skipped:\n\n      // First check if the map is of invalid size\n      if (this[kQueue].size > 1) {\n        this.cleanup(true, new MongoRuntimeError(INVALID_QUEUE_SIZE));\n      } else {\n        // Get the first orphaned operation description.\n        const entry = this[kQueue].entries().next();\n        if (entry.value != null) {\n          const [requestId, orphaned]: [number, OperationDescription] = entry.value;\n          // If the orphaned operation description exists then set it.\n          operationDescription = orphaned;\n          // Remove the entry with the bad request id from the queue.\n          this[kQueue].delete(requestId);\n        }\n      }\n    }\n\n    if (!operationDescription) {\n      return;\n    }\n\n    const callback = operationDescription.cb;\n\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    this[kQueue].delete(message.responseTo);\n    if ('moreToCome' in message && message.moreToCome) {\n      // If the operation description check above does find an orphaned\n      // description and sets the operationDescription then this line will put one\n      // back in the queue with the correct requestId and will resolve not being able\n      // to find the next one via the responseTo of the next streaming hello.\n      this[kQueue].set(message.requestId, operationDescription);\n      this[kStream].setTimeout(socketTimeoutMS);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document: Document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        this[kClusterTime] = document.$clusterTime;\n        this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n\n      if (document.writeConcernError) {\n        callback(new MongoWriteConcernError(document.writeConcernError, document), document);\n        return;\n      }\n\n      if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n        callback(new MongoServerError(document));\n        return;\n      }\n    }\n\n    callback(undefined, message.documents[0]);\n  }\n\n  destroy(options: DestroyOptions, callback?: Callback): void {\n    if (this.closed) {\n      process.nextTick(() => callback?.());\n      return;\n    }\n    if (typeof callback === 'function') {\n      this.once('close', () => process.nextTick(() => callback()));\n    }\n\n    // load balanced mode requires that these listeners remain on the connection\n    // after cleanup on timeouts, errors or close so we remove them before calling\n    // cleanup.\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(options.force, new MongoNetworkError(message));\n  }\n\n  /**\n   * A method that cleans up the connection.  When `force` is true, this method\n   * forcibly destroys the socket.\n   *\n   * If an error is provided, any in-flight operations will be closed with the error.\n   *\n   * This method does nothing if the connection is already closed.\n   */\n  private cleanup(force: boolean, error?: Error): void {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const completeCleanup = () => {\n      for (const op of this[kQueue].values()) {\n        op.cb(error);\n      }\n\n      this[kQueue].clear();\n\n      this.emit(Connection.CLOSE);\n    };\n\n    this[kStream].removeAllListeners();\n    this[kMessageStream].removeAllListeners();\n\n    this[kMessageStream].destroy();\n\n    if (force) {\n      this[kStream].destroy();\n      completeCleanup();\n      return;\n    }\n\n    if (!this[kStream].writableEnded) {\n      this[kStream].end(() => {\n        this[kStream].destroy();\n        completeCleanup();\n      });\n    } else {\n      completeCleanup();\n    }\n  }\n\n  command(\n    ns: MongoDBNamespace,\n    command: Document,\n    options: CommandOptions | undefined,\n    callback: Callback\n  ): void {\n    let cmd = { ...command };\n\n    const readPreference = getReadPreference(options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options?.session;\n\n    let clusterTime = this.clusterTime;\n\n    if (this.serverApi) {\n      const { version, strict, deprecationErrors } = this.serverApi;\n      cmd.apiVersion = version;\n      if (strict != null) cmd.apiStrict = strict;\n      if (deprecationErrors != null) cmd.apiDeprecationErrors = deprecationErrors;\n    }\n\n    if (hasSessionSupport(this) && session) {\n      if (\n        session.clusterTime &&\n        clusterTime &&\n        session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)\n      ) {\n        clusterTime = session.clusterTime;\n      }\n\n      const err = applySession(session, cmd, options);\n      if (err) {\n        return callback(err);\n      }\n    } else if (session?.explicit) {\n      return callback(new MongoCompatibilityError('Current topology does not support sessions'));\n    }\n\n    // if we have a known cluster time, gossip it\n    if (clusterTime) {\n      cmd.$clusterTime = clusterTime;\n    }\n\n    if (isSharded(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      cmd = {\n        $query: cmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n\n    const commandOptions: Document = Object.assign(\n      {\n        numberToSkip: 0,\n        numberToReturn: -1,\n        checkKeys: false,\n        // This value is not overridable\n        secondaryOk: readPreference.secondaryOk()\n      },\n      options\n    );\n\n    const cmdNs = `${ns.db}.$cmd`;\n    const message = shouldUseOpMsg\n      ? new Msg(cmdNs, cmd, commandOptions)\n      : new Query(cmdNs, cmd, commandOptions);\n\n    try {\n      write(this, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n}\n\n/** @internal */\nexport class CryptoConnection extends Connection {\n  /** @internal */\n  [kAutoEncrypter]?: AutoEncrypter;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n\n  /** @internal @override */\n  override command(\n    ns: MongoDBNamespace,\n    cmd: Document,\n    options: CommandOptions,\n    callback: Callback\n  ): void {\n    const autoEncrypter = this[kAutoEncrypter];\n    if (!autoEncrypter) {\n      return callback(new MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n    }\n\n    const serverWireVersion = maxWireVersion(this);\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n\n    if (serverWireVersion < 8) {\n      callback(\n        new MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2')\n      );\n      return;\n    }\n\n    // Save sort or indexKeys based on the command being run\n    // the encrypt API serializes our JS objects to BSON to pass to the native code layer\n    // and then deserializes the encrypted result, the protocol level components\n    // of the command (ex. sort) are then converted to JS objects potentially losing\n    // import key order information. These fields are never encrypted so we can save the values\n    // from before the encryption and replace them after encryption has been performed\n    const sort: Map<string, number> | null = cmd.find || cmd.findAndModify ? cmd.sort : null;\n    const indexKeys: Map<string, number>[] | null = cmd.createIndexes\n      ? cmd.indexes.map((index: { key: Map<string, number> }) => index.key)\n      : null;\n\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n      if (err || encrypted == null) {\n        callback(err, null);\n        return;\n      }\n\n      // Replace the saved values\n      if (sort != null && (cmd.find || cmd.findAndModify)) {\n        encrypted.sort = sort;\n      }\n      if (indexKeys != null && cmd.createIndexes) {\n        for (const [offset, index] of indexKeys.entries()) {\n          encrypted.indexes[offset].key = index;\n        }\n      }\n\n      super.command(ns, encrypted, options, (err, response) => {\n        if (err || response == null) {\n          callback(err, response);\n          return;\n        }\n\n        autoEncrypter.decrypt(response, options, callback);\n      });\n    });\n  }\n}\n\n/** @internal */\nexport function hasSessionSupport(conn: Connection): boolean {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null;\n}\n\nfunction supportsOpMsg(conn: Connection) {\n  const description = conn.description;\n  if (description == null) {\n    return false;\n  }\n\n  return maxWireVersion(conn) >= 6 && !description.__nodejs_mock_server__;\n}\n\nfunction streamIdentifier(stream: Stream, options: ConnectionOptions): string {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n\n  const { remoteAddress, remotePort } = stream;\n  if (typeof remoteAddress === 'string' && typeof remotePort === 'number') {\n    return HostAddress.fromHostPort(remoteAddress, remotePort).toString();\n  }\n\n  return uuidV4().toString('hex');\n}\n\nfunction write(\n  conn: Connection,\n  command: WriteProtocolMessageType,\n  options: CommandOptions,\n  callback: Callback\n) {\n  options = options ?? {};\n  const operationDescription: OperationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n\n    // for BSON parsing\n    useBigInt64: typeof options.useBigInt64 === 'boolean' ? options.useBigInt64 : false,\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation:\n      typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeoutMS === 'number') {\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  } else if (conn.socketTimeoutMS !== 0) {\n    conn[kStream].setTimeout(conn.socketTimeoutMS);\n  }\n\n  // if command monitoring is enabled we need to modify the callback here\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new CommandStartedEvent(conn, command));\n\n    operationDescription.started = now();\n    operationDescription.cb = (err, reply) => {\n      // Command monitoring spec states that if ok is 1, then we must always emit\n      // a command succeeded event, even if there's an error. Write concern errors\n      // will have an ok: 1 in their reply.\n      if (err && reply?.ok !== 1) {\n        conn.emit(\n          Connection.COMMAND_FAILED,\n          new CommandFailedEvent(conn, command, err, operationDescription.started)\n        );\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(\n            Connection.COMMAND_FAILED,\n            new CommandFailedEvent(conn, command, reply, operationDescription.started)\n          );\n        } else {\n          conn.emit(\n            Connection.COMMAND_SUCCEEDED,\n            new CommandSucceededEvent(conn, command, reply, operationDescription.started)\n          );\n        }\n      }\n\n      if (typeof callback === 'function') {\n        // Since we're passing through the reply with the write concern error now, we\n        // need it not to be provided to the original callback in this case so\n        // retryability does not get tricked into thinking the command actually\n        // succeeded.\n        callback(err, err instanceof MongoWriteConcernError ? undefined : reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}