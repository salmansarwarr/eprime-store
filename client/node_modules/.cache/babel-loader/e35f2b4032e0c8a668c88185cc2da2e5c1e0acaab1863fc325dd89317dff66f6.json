{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _regeneratorRuntime = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallbackLockCache = void 0;\nvar error_1 = require(\"../../../error\");\nvar cache_1 = require(\"./cache\");\n/** Error message for when request callback is missing. */\nvar REQUEST_CALLBACK_REQUIRED_ERROR = 'Auth mechanism property REQUEST_TOKEN_CALLBACK is required.';\n/* Counter for function \"hashes\".*/\nvar FN_HASH_COUNTER = 0;\n/* No function present function */\nvar NO_FUNCTION = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", {\n            accessToken: 'test'\n          });\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function NO_FUNCTION() {\n    return _ref.apply(this, arguments);\n  };\n}();\n/* The map of function hashes */\nvar FN_HASHES = new WeakMap();\n/* Put the no function hash in the map. */\nFN_HASHES.set(NO_FUNCTION, FN_HASH_COUNTER);\n/**\n * A cache of request and refresh callbacks per server/user.\n */\nvar CallbackLockCache = /*#__PURE__*/function (_cache_1$Cache) {\n  _inherits(CallbackLockCache, _cache_1$Cache);\n  var _super = _createSuper(CallbackLockCache);\n  function CallbackLockCache() {\n    _classCallCheck(this, CallbackLockCache);\n    return _super.apply(this, arguments);\n  }\n  _createClass(CallbackLockCache, [{\n    key: \"getEntry\",\n    value:\n    /**\n     * Get the callbacks for the connection and credentials. If an entry does not\n     * exist a new one will get set.\n     */\n    function getEntry(connection, credentials) {\n      var requestCallback = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n      var refreshCallback = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;\n      if (!requestCallback) {\n        throw new error_1.MongoInvalidArgumentError(REQUEST_CALLBACK_REQUIRED_ERROR);\n      }\n      var callbackHash = hashFunctions(requestCallback, refreshCallback);\n      var key = this.cacheKey(connection.address, credentials.username, callbackHash);\n      var entry = this.entries.get(key);\n      if (entry) {\n        return entry;\n      }\n      return this.addEntry(key, callbackHash, requestCallback, refreshCallback);\n    }\n    /**\n     * Set locked callbacks on for connection and credentials.\n     */\n  }, {\n    key: \"addEntry\",\n    value: function addEntry(key, callbackHash, requestCallback, refreshCallback) {\n      var entry = {\n        requestCallback: withLock(requestCallback),\n        refreshCallback: refreshCallback ? withLock(refreshCallback) : undefined,\n        callbackHash: callbackHash\n      };\n      this.entries.set(key, entry);\n      return entry;\n    }\n    /**\n     * Create a cache key from the address and username.\n     */\n  }, {\n    key: \"cacheKey\",\n    value: function cacheKey(address, username, callbackHash) {\n      return this.hashedCacheKey(address, username, callbackHash);\n    }\n  }]);\n  return CallbackLockCache;\n}(cache_1.Cache);\nexports.CallbackLockCache = CallbackLockCache;\n/**\n * Ensure the callback is only executed one at a time.\n */\nfunction withLock(callback) {\n  var lock = Promise.resolve();\n  return /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(info, context) {\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return lock;\n          case 2:\n            lock = lock.then(function () {\n              return callback(info, context);\n            });\n            return _context2.abrupt(\"return\", lock);\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    return function (_x, _x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n}\n/**\n * Get the hash string for the request and refresh functions.\n */\nfunction hashFunctions(requestFn, refreshFn) {\n  var requestHash = FN_HASHES.get(requestFn);\n  var refreshHash = FN_HASHES.get(refreshFn !== null && refreshFn !== void 0 ? refreshFn : NO_FUNCTION);\n  if (requestHash == null) {\n    // Create a new one for the function and put it in the map.\n    FN_HASH_COUNTER++;\n    requestHash = FN_HASH_COUNTER;\n    FN_HASHES.set(requestFn, FN_HASH_COUNTER);\n  }\n  if (refreshHash == null && refreshFn) {\n    // Create a new one for the function and put it in the map.\n    FN_HASH_COUNTER++;\n    refreshHash = FN_HASH_COUNTER;\n    FN_HASHES.set(refreshFn, FN_HASH_COUNTER);\n  }\n  return \"\".concat(requestHash, \"-\").concat(refreshHash);\n}","map":{"version":3,"names":["error_1","require","cache_1","REQUEST_CALLBACK_REQUIRED_ERROR","FN_HASH_COUNTER","NO_FUNCTION","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","abrupt","accessToken","stop","apply","arguments","FN_HASHES","WeakMap","set","CallbackLockCache","_cache_1$Cache","_inherits","_super","_createSuper","_classCallCheck","_createClass","key","value","getEntry","connection","credentials","requestCallback","mechanismProperties","REQUEST_TOKEN_CALLBACK","refreshCallback","REFRESH_TOKEN_CALLBACK","MongoInvalidArgumentError","callbackHash","hashFunctions","cacheKey","address","username","entry","entries","get","addEntry","withLock","undefined","hashedCacheKey","Cache","exports","callback","lock","Promise","resolve","_ref2","_callee2","info","context","_callee2$","_context2","then","_x","_x2","requestFn","refreshFn","requestHash","refreshHash","concat"],"sources":["/home/salman/Documents/GitHub/FakeShop/node_modules/mongodb/src/cmap/auth/mongodb_oidc/callback_lock_cache.ts"],"sourcesContent":["import { MongoInvalidArgumentError } from '../../../error';\nimport type { Connection } from '../../connection';\nimport type { MongoCredentials } from '../mongo_credentials';\nimport type {\n  IdPServerInfo,\n  IdPServerResponse,\n  OIDCCallbackContext,\n  OIDCRefreshFunction,\n  OIDCRequestFunction\n} from '../mongodb_oidc';\nimport { Cache } from './cache';\n\n/** Error message for when request callback is missing. */\nconst REQUEST_CALLBACK_REQUIRED_ERROR =\n  'Auth mechanism property REQUEST_TOKEN_CALLBACK is required.';\n/* Counter for function \"hashes\".*/\nlet FN_HASH_COUNTER = 0;\n/* No function present function */\nconst NO_FUNCTION: OIDCRequestFunction = async () => ({ accessToken: 'test' });\n/* The map of function hashes */\nconst FN_HASHES = new WeakMap<OIDCRequestFunction | OIDCRefreshFunction, number>();\n/* Put the no function hash in the map. */\nFN_HASHES.set(NO_FUNCTION, FN_HASH_COUNTER);\n\n/**\n * An entry of callbacks in the cache.\n */\ninterface CallbacksEntry {\n  requestCallback: OIDCRequestFunction;\n  refreshCallback?: OIDCRefreshFunction;\n  callbackHash: string;\n}\n\n/**\n * A cache of request and refresh callbacks per server/user.\n */\nexport class CallbackLockCache extends Cache<CallbacksEntry> {\n  /**\n   * Get the callbacks for the connection and credentials. If an entry does not\n   * exist a new one will get set.\n   */\n  getEntry(connection: Connection, credentials: MongoCredentials): CallbacksEntry {\n    const requestCallback = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n    const refreshCallback = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;\n    if (!requestCallback) {\n      throw new MongoInvalidArgumentError(REQUEST_CALLBACK_REQUIRED_ERROR);\n    }\n    const callbackHash = hashFunctions(requestCallback, refreshCallback);\n    const key = this.cacheKey(connection.address, credentials.username, callbackHash);\n    const entry = this.entries.get(key);\n    if (entry) {\n      return entry;\n    }\n    return this.addEntry(key, callbackHash, requestCallback, refreshCallback);\n  }\n\n  /**\n   * Set locked callbacks on for connection and credentials.\n   */\n  private addEntry(\n    key: string,\n    callbackHash: string,\n    requestCallback: OIDCRequestFunction,\n    refreshCallback?: OIDCRefreshFunction\n  ): CallbacksEntry {\n    const entry = {\n      requestCallback: withLock(requestCallback),\n      refreshCallback: refreshCallback ? withLock(refreshCallback) : undefined,\n      callbackHash: callbackHash\n    };\n    this.entries.set(key, entry);\n    return entry;\n  }\n\n  /**\n   * Create a cache key from the address and username.\n   */\n  cacheKey(address: string, username: string, callbackHash: string): string {\n    return this.hashedCacheKey(address, username, callbackHash);\n  }\n}\n\n/**\n * Ensure the callback is only executed one at a time.\n */\nfunction withLock(callback: OIDCRequestFunction | OIDCRefreshFunction) {\n  let lock: Promise<any> = Promise.resolve();\n  return async (info: IdPServerInfo, context: OIDCCallbackContext): Promise<IdPServerResponse> => {\n    await lock;\n    lock = lock.then(() => callback(info, context));\n    return lock;\n  };\n}\n\n/**\n * Get the hash string for the request and refresh functions.\n */\nfunction hashFunctions(requestFn: OIDCRequestFunction, refreshFn?: OIDCRefreshFunction): string {\n  let requestHash = FN_HASHES.get(requestFn);\n  let refreshHash = FN_HASHES.get(refreshFn ?? NO_FUNCTION);\n  if (requestHash == null) {\n    // Create a new one for the function and put it in the map.\n    FN_HASH_COUNTER++;\n    requestHash = FN_HASH_COUNTER;\n    FN_HASHES.set(requestFn, FN_HASH_COUNTER);\n  }\n  if (refreshHash == null && refreshFn) {\n    // Create a new one for the function and put it in the map.\n    FN_HASH_COUNTER++;\n    refreshHash = FN_HASH_COUNTER;\n    FN_HASHES.set(refreshFn, FN_HASH_COUNTER);\n  }\n  return `${requestHash}-${refreshHash}`;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}