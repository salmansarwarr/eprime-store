{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _objectSpread = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _asyncToGenerator = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScramSHA256 = exports.ScramSHA1 = void 0;\nvar crypto = require(\"crypto\");\nvar util_1 = require(\"util\");\nvar bson_1 = require(\"../../bson\");\nvar deps_1 = require(\"../../deps\");\nvar error_1 = require(\"../../error\");\nvar utils_1 = require(\"../../utils\");\nvar auth_provider_1 = require(\"./auth_provider\");\nvar providers_1 = require(\"./providers\");\nvar ScramSHA = /*#__PURE__*/function (_auth_provider_1$Auth) {\n  _inherits(ScramSHA, _auth_provider_1$Auth);\n  var _super = _createSuper(ScramSHA);\n  function ScramSHA(cryptoMethod) {\n    var _this;\n    _classCallCheck(this, ScramSHA);\n    _this = _super.call(this);\n    _this.cryptoMethod = cryptoMethod || 'sha1';\n    _this.randomBytesAsync = (0, util_1.promisify)(crypto.randomBytes);\n    return _this;\n  }\n  _createClass(ScramSHA, [{\n    key: \"prepare\",\n    value: function () {\n      var _prepare = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(handshakeDoc, authContext) {\n        var cryptoMethod, credentials, nonce, request;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              cryptoMethod = this.cryptoMethod;\n              credentials = authContext.credentials;\n              if (credentials) {\n                _context.next = 4;\n                break;\n              }\n              throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');\n            case 4:\n              if (cryptoMethod === 'sha256' && ('kModuleError' in deps_1.saslprep || typeof deps_1.saslprep !== 'function')) {\n                (0, utils_1.emitWarning)('Warning: no saslprep library specified. Passwords will not be sanitized');\n              }\n              _context.next = 7;\n              return this.randomBytesAsync(24);\n            case 7:\n              nonce = _context.sent;\n              // store the nonce for later use\n              authContext.nonce = nonce;\n              request = _objectSpread(_objectSpread({}, handshakeDoc), {}, {\n                speculativeAuthenticate: _objectSpread(_objectSpread({}, makeFirstMessage(cryptoMethod, credentials, nonce)), {}, {\n                  db: credentials.source\n                })\n              });\n              return _context.abrupt(\"return\", request);\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function prepare(_x, _x2) {\n        return _prepare.apply(this, arguments);\n      }\n      return prepare;\n    }()\n  }, {\n    key: \"auth\",\n    value: function () {\n      var _auth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(authContext) {\n        var reauthenticating, response;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              reauthenticating = authContext.reauthenticating, response = authContext.response;\n              if (!(response !== null && response !== void 0 && response.speculativeAuthenticate && !reauthenticating)) {\n                _context2.next = 3;\n                break;\n              }\n              return _context2.abrupt(\"return\", continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext));\n            case 3:\n              return _context2.abrupt(\"return\", executeScram(this.cryptoMethod, authContext));\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function auth(_x3) {\n        return _auth.apply(this, arguments);\n      }\n      return auth;\n    }()\n  }]);\n  return ScramSHA;\n}(auth_provider_1.AuthProvider);\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);\n}\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  var username = cleanUsername(credentials.username);\n  var mechanism = cryptoMethod === 'sha1' ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return {\n    saslStart: 1,\n    mechanism: mechanism,\n    payload: new bson_1.Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n    autoAuthorize: 1,\n    options: {\n      skipEmptyExchange: true\n    }\n  };\n}\nfunction executeScram(_x4, _x5) {\n  return _executeScram.apply(this, arguments);\n}\nfunction _executeScram() {\n  _executeScram = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(cryptoMethod, authContext) {\n    var connection, credentials, nonce, db, saslStartCmd, response;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          connection = authContext.connection, credentials = authContext.credentials;\n          if (credentials) {\n            _context3.next = 3;\n            break;\n          }\n          throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');\n        case 3:\n          if (authContext.nonce) {\n            _context3.next = 5;\n            break;\n          }\n          throw new error_1.MongoInvalidArgumentError('AuthContext must contain a valid nonce property');\n        case 5:\n          nonce = authContext.nonce;\n          db = credentials.source;\n          saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n          _context3.next = 10;\n          return connection.commandAsync((0, utils_1.ns)(\"\".concat(db, \".$cmd\")), saslStartCmd, undefined);\n        case 10:\n          response = _context3.sent;\n          _context3.next = 13;\n          return continueScramConversation(cryptoMethod, response, authContext);\n        case 13:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _executeScram.apply(this, arguments);\n}\nfunction continueScramConversation(_x6, _x7, _x8) {\n  return _continueScramConversation.apply(this, arguments);\n}\nfunction _continueScramConversation() {\n  _continueScramConversation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(cryptoMethod, response, authContext) {\n    var connection, credentials, nonce, db, username, password, processedPassword, payload, dict, iterations, salt, rnonce, withoutProof, saltedPassword, clientKey, serverKey, storedKey, authMessage, clientSignature, clientProof, clientFinal, serverSignature, saslContinueCmd, r, parsedResponse, retrySaslContinueCmd;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          connection = authContext.connection;\n          credentials = authContext.credentials;\n          if (credentials) {\n            _context4.next = 4;\n            break;\n          }\n          throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');\n        case 4:\n          if (authContext.nonce) {\n            _context4.next = 6;\n            break;\n          }\n          throw new error_1.MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce');\n        case 6:\n          nonce = authContext.nonce;\n          db = credentials.source;\n          username = cleanUsername(credentials.username);\n          password = credentials.password;\n          if (cryptoMethod === 'sha256') {\n            processedPassword = 'kModuleError' in deps_1.saslprep || typeof deps_1.saslprep !== 'function' ? password : (0, deps_1.saslprep)(password);\n          } else {\n            processedPassword = passwordDigest(username, password);\n          }\n          payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;\n          dict = parsePayload(payload.value());\n          iterations = parseInt(dict.i, 10);\n          if (!(iterations && iterations < 4096)) {\n            _context4.next = 16;\n            break;\n          }\n          throw new error_1.MongoRuntimeError(\"Server returned an invalid iteration count \".concat(iterations));\n        case 16:\n          salt = dict.s;\n          rnonce = dict.r;\n          if (!rnonce.startsWith('nonce')) {\n            _context4.next = 20;\n            break;\n          }\n          throw new error_1.MongoRuntimeError(\"Server returned an invalid nonce: \".concat(rnonce));\n        case 20:\n          // Set up start of proof\n          withoutProof = \"c=biws,r=\".concat(rnonce);\n          saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n          clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n          serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n          storedKey = H(cryptoMethod, clientKey);\n          authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(',');\n          clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n          clientProof = \"p=\".concat(xor(clientKey, clientSignature));\n          clientFinal = [withoutProof, clientProof].join(',');\n          serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n          saslContinueCmd = {\n            saslContinue: 1,\n            conversationId: response.conversationId,\n            payload: new bson_1.Binary(Buffer.from(clientFinal))\n          };\n          _context4.next = 33;\n          return connection.commandAsync((0, utils_1.ns)(\"\".concat(db, \".$cmd\")), saslContinueCmd, undefined);\n        case 33:\n          r = _context4.sent;\n          parsedResponse = parsePayload(r.payload.value());\n          if (compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n            _context4.next = 37;\n            break;\n          }\n          throw new error_1.MongoRuntimeError('Server returned an invalid signature');\n        case 37:\n          if (!(r.done !== false)) {\n            _context4.next = 39;\n            break;\n          }\n          return _context4.abrupt(\"return\");\n        case 39:\n          retrySaslContinueCmd = {\n            saslContinue: 1,\n            conversationId: r.conversationId,\n            payload: Buffer.alloc(0)\n          };\n          _context4.next = 42;\n          return connection.commandAsync((0, utils_1.ns)(\"\".concat(db, \".$cmd\")), retrySaslContinueCmd, undefined);\n        case 42:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _continueScramConversation.apply(this, arguments);\n}\nfunction parsePayload(payload) {\n  var dict = {};\n  var parts = payload.split(',');\n  for (var i = 0; i < parts.length; i++) {\n    var valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n  return dict;\n}\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new error_1.MongoInvalidArgumentError('Username must be a string');\n  }\n  if (typeof password !== 'string') {\n    throw new error_1.MongoInvalidArgumentError('Password must be a string');\n  }\n  if (password.length === 0) {\n    throw new error_1.MongoInvalidArgumentError('Password cannot be empty');\n  }\n  var md5;\n  try {\n    md5 = crypto.createHash('md5');\n  } catch (err) {\n    if (crypto.getFips()) {\n      // This error is (slightly) more helpful than what comes from OpenSSL directly, e.g.\n      // 'Error: error:060800C8:digital envelope routines:EVP_DigestInit_ex:disabled for FIPS'\n      throw new Error('Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode');\n    }\n    throw err;\n  }\n  md5.update(\"\".concat(username, \":mongo:\").concat(password), 'utf8');\n  return md5.digest('hex');\n}\n// XOR two buffers\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n  var length = Math.max(a.length, b.length);\n  var res = [];\n  for (var i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n  return Buffer.from(res).toString('base64');\n}\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\nvar _hiCache = {};\nvar _hiCacheCount = 0;\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\nvar hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  var key = [data, salt.toString('base64'), iterations].join('_');\n  if (_hiCache[key] != null) {\n    return _hiCache[key];\n  }\n  // generate the salt\n  var saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n  var result = 0;\n  for (var i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n  return result === 0;\n}\nvar ScramSHA1 = /*#__PURE__*/function (_ScramSHA) {\n  _inherits(ScramSHA1, _ScramSHA);\n  var _super2 = _createSuper(ScramSHA1);\n  function ScramSHA1() {\n    _classCallCheck(this, ScramSHA1);\n    return _super2.call(this, 'sha1');\n  }\n  return _createClass(ScramSHA1);\n}(ScramSHA);\nexports.ScramSHA1 = ScramSHA1;\nvar ScramSHA256 = /*#__PURE__*/function (_ScramSHA2) {\n  _inherits(ScramSHA256, _ScramSHA2);\n  var _super3 = _createSuper(ScramSHA256);\n  function ScramSHA256() {\n    _classCallCheck(this, ScramSHA256);\n    return _super3.call(this, 'sha256');\n  }\n  return _createClass(ScramSHA256);\n}(ScramSHA);\nexports.ScramSHA256 = ScramSHA256;","map":{"version":3,"names":["crypto","require","util_1","bson_1","deps_1","error_1","utils_1","auth_provider_1","providers_1","ScramSHA","_auth_provider_1$Auth","_inherits","_super","_createSuper","cryptoMethod","_this","_classCallCheck","call","randomBytesAsync","promisify","randomBytes","_createClass","key","value","_prepare","_asyncToGenerator","_regeneratorRuntime","mark","_callee","handshakeDoc","authContext","credentials","nonce","request","wrap","_callee$","_context","prev","next","MongoMissingCredentialsError","saslprep","emitWarning","sent","_objectSpread","speculativeAuthenticate","makeFirstMessage","db","source","abrupt","stop","prepare","_x","_x2","apply","arguments","_auth","_callee2","reauthenticating","response","_callee2$","_context2","continueScramConversation","executeScram","auth","_x3","AuthProvider","cleanUsername","username","replace","clientFirstMessageBare","Buffer","concat","from","toString","mechanism","AuthMechanism","MONGODB_SCRAM_SHA1","MONGODB_SCRAM_SHA256","saslStart","payload","Binary","autoAuthorize","options","skipEmptyExchange","_x4","_x5","_executeScram","_callee3","connection","saslStartCmd","_callee3$","_context3","MongoInvalidArgumentError","commandAsync","ns","undefined","_x6","_x7","_x8","_continueScramConversation","_callee4","password","processedPassword","dict","iterations","salt","rnonce","withoutProof","saltedPassword","clientKey","serverKey","storedKey","authMessage","clientSignature","clientProof","clientFinal","serverSignature","saslContinueCmd","r","parsedResponse","retrySaslContinueCmd","_callee4$","_context4","passwordDigest","isBuffer","parsePayload","parseInt","i","MongoRuntimeError","s","startsWith","HI","HMAC","H","join","xor","saslContinue","conversationId","compareDigest","v","done","alloc","parts","split","length","valueParts","md5","createHash","err","getFips","Error","update","digest","a","b","Math","max","res","push","method","text","createHmac","_hiCache","_hiCacheCount","_hiCachePurge","hiLengthMap","sha256","sha1","data","saltedData","pbkdf2Sync","lhs","rhs","timingSafeEqual","result","ScramSHA1","_ScramSHA","_super2","exports","ScramSHA256","_ScramSHA2","_super3"],"sources":["/home/salman/Documents/GitHub/FakeShop/node_modules/mongodb/src/cmap/auth/scram.ts"],"sourcesContent":["import * as crypto from 'crypto';\nimport { promisify } from 'util';\n\nimport { Binary, type Document } from '../../bson';\nimport { saslprep } from '../../deps';\nimport {\n  MongoInvalidArgumentError,\n  MongoMissingCredentialsError,\n  MongoRuntimeError\n} from '../../error';\nimport { emitWarning, ns } from '../../utils';\nimport type { HandshakeDocument } from '../connect';\nimport { type AuthContext, AuthProvider } from './auth_provider';\nimport type { MongoCredentials } from './mongo_credentials';\nimport { AuthMechanism } from './providers';\n\ntype CryptoMethod = 'sha1' | 'sha256';\n\nclass ScramSHA extends AuthProvider {\n  cryptoMethod: CryptoMethod;\n  randomBytesAsync: (size: number) => Promise<Buffer>;\n  constructor(cryptoMethod: CryptoMethod) {\n    super();\n    this.cryptoMethod = cryptoMethod || 'sha1';\n    this.randomBytesAsync = promisify(crypto.randomBytes);\n  }\n\n  override async prepare(\n    handshakeDoc: HandshakeDocument,\n    authContext: AuthContext\n  ): Promise<HandshakeDocument> {\n    const cryptoMethod = this.cryptoMethod;\n    const credentials = authContext.credentials;\n    if (!credentials) {\n      throw new MongoMissingCredentialsError('AuthContext must provide credentials.');\n    }\n    if (\n      cryptoMethod === 'sha256' &&\n      ('kModuleError' in saslprep || typeof saslprep !== 'function')\n    ) {\n      emitWarning('Warning: no saslprep library specified. Passwords will not be sanitized');\n    }\n\n    const nonce = await this.randomBytesAsync(24);\n    // store the nonce for later use\n    authContext.nonce = nonce;\n\n    const request = {\n      ...handshakeDoc,\n      speculativeAuthenticate: {\n        ...makeFirstMessage(cryptoMethod, credentials, nonce),\n        db: credentials.source\n      }\n    };\n\n    return request;\n  }\n\n  override async auth(authContext: AuthContext) {\n    const { reauthenticating, response } = authContext;\n    if (response?.speculativeAuthenticate && !reauthenticating) {\n      return continueScramConversation(\n        this.cryptoMethod,\n        response.speculativeAuthenticate,\n        authContext\n      );\n    }\n    return executeScram(this.cryptoMethod, authContext);\n  }\n}\n\nfunction cleanUsername(username: string) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\n\nfunction clientFirstMessageBare(username: string, nonce: Buffer) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([\n    Buffer.from('n=', 'utf8'),\n    Buffer.from(username, 'utf8'),\n    Buffer.from(',r=', 'utf8'),\n    Buffer.from(nonce.toString('base64'), 'utf8')\n  ]);\n}\n\nfunction makeFirstMessage(\n  cryptoMethod: CryptoMethod,\n  credentials: MongoCredentials,\n  nonce: Buffer\n) {\n  const username = cleanUsername(credentials.username);\n  const mechanism =\n    cryptoMethod === 'sha1' ? AuthMechanism.MONGODB_SCRAM_SHA1 : AuthMechanism.MONGODB_SCRAM_SHA256;\n\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new Binary(\n      Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])\n    ),\n    autoAuthorize: 1,\n    options: { skipEmptyExchange: true }\n  };\n}\n\nasync function executeScram(cryptoMethod: CryptoMethod, authContext: AuthContext): Promise<void> {\n  const { connection, credentials } = authContext;\n  if (!credentials) {\n    throw new MongoMissingCredentialsError('AuthContext must provide credentials.');\n  }\n  if (!authContext.nonce) {\n    throw new MongoInvalidArgumentError('AuthContext must contain a valid nonce property');\n  }\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  const response = await connection.commandAsync(ns(`${db}.$cmd`), saslStartCmd, undefined);\n  await continueScramConversation(cryptoMethod, response, authContext);\n}\n\nasync function continueScramConversation(\n  cryptoMethod: CryptoMethod,\n  response: Document,\n  authContext: AuthContext\n): Promise<void> {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  if (!credentials) {\n    throw new MongoMissingCredentialsError('AuthContext must provide credentials.');\n  }\n  if (!authContext.nonce) {\n    throw new MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce');\n  }\n  const nonce = authContext.nonce;\n\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n\n  let processedPassword;\n  if (cryptoMethod === 'sha256') {\n    processedPassword =\n      'kModuleError' in saslprep || typeof saslprep !== 'function' ? password : saslprep(password);\n  } else {\n    processedPassword = passwordDigest(username, password);\n  }\n\n  const payload = Buffer.isBuffer(response.payload)\n    ? new Binary(response.payload)\n    : response.payload;\n  const dict = parsePayload(payload.value());\n\n  const iterations = parseInt(dict.i, 10);\n  if (iterations && iterations < 4096) {\n    // TODO(NODE-3483)\n    throw new MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`);\n  }\n\n  const salt = dict.s;\n  const rnonce = dict.r;\n  if (rnonce.startsWith('nonce')) {\n    // TODO(NODE-3483)\n    throw new MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`);\n  }\n\n  // Set up start of proof\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(\n    processedPassword,\n    Buffer.from(salt, 'base64'),\n    iterations,\n    cryptoMethod\n  );\n\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(\n    ','\n  );\n\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new Binary(Buffer.from(clientFinal))\n  };\n\n  const r = await connection.commandAsync(ns(`${db}.$cmd`), saslContinueCmd, undefined);\n  const parsedResponse = parsePayload(r.payload.value());\n\n  if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n    throw new MongoRuntimeError('Server returned an invalid signature');\n  }\n\n  if (r.done !== false) {\n    // If the server sends r.done === true we can save one RTT\n    return;\n  }\n\n  const retrySaslContinueCmd = {\n    saslContinue: 1,\n    conversationId: r.conversationId,\n    payload: Buffer.alloc(0)\n  };\n\n  await connection.commandAsync(ns(`${db}.$cmd`), retrySaslContinueCmd, undefined);\n}\n\nfunction parsePayload(payload: string) {\n  const dict: Document = {};\n  const parts = payload.split(',');\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n}\n\nfunction passwordDigest(username: string, password: string) {\n  if (typeof username !== 'string') {\n    throw new MongoInvalidArgumentError('Username must be a string');\n  }\n\n  if (typeof password !== 'string') {\n    throw new MongoInvalidArgumentError('Password must be a string');\n  }\n\n  if (password.length === 0) {\n    throw new MongoInvalidArgumentError('Password cannot be empty');\n  }\n\n  let md5: crypto.Hash;\n  try {\n    md5 = crypto.createHash('md5');\n  } catch (err) {\n    if (crypto.getFips()) {\n      // This error is (slightly) more helpful than what comes from OpenSSL directly, e.g.\n      // 'Error: error:060800C8:digital envelope routines:EVP_DigestInit_ex:disabled for FIPS'\n      throw new Error('Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode');\n    }\n    throw err;\n  }\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n}\n\n// XOR two buffers\nfunction xor(a: Buffer, b: Buffer) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method: CryptoMethod, text: Buffer) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method: CryptoMethod, key: Buffer, text: Buffer | string) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\ninterface HICache {\n  [key: string]: Buffer;\n}\n\nlet _hiCache: HICache = {};\nlet _hiCacheCount = 0;\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data: string, salt: Buffer, iterations: number, cryptoMethod: CryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n  if (_hiCache[key] != null) {\n    return _hiCache[key];\n  }\n\n  // generate the salt\n  const saltedData = crypto.pbkdf2Sync(\n    data,\n    salt,\n    iterations,\n    hiLengthMap[cryptoMethod],\n    cryptoMethod\n  );\n\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs: Buffer, rhs: Uint8Array) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\nexport class ScramSHA1 extends ScramSHA {\n  constructor() {\n    super('sha1');\n  }\n}\n\nexport class ScramSHA256 extends ScramSHA {\n  constructor() {\n    super('sha256');\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}