{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/home/salman/Documents/GitHub/FakeShop/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = void 0;\nvar error_1 = require(\"../error\");\nvar read_preference_1 = require(\"../read_preference\");\nvar server_selection_1 = require(\"../sdam/server_selection\");\nvar utils_1 = require(\"../utils\");\nvar operation_1 = require(\"./operation\");\nvar MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nvar MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\nfunction executeOperation(client, operation, callback) {\n  return (0, utils_1.maybeCallback)(function () {\n    return executeOperationAsync(client, operation);\n  }, callback);\n}\nexports.executeOperation = executeOperation;\nfunction executeOperationAsync(_x, _x2) {\n  return _executeOperationAsync.apply(this, arguments);\n}\nfunction _executeOperationAsync() {\n  _executeOperationAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(client, operation) {\n    var _operation$readPrefer, _session, _session2;\n    var topology, session, owner, readPreference, inTransaction, selector, _operation$server, server, _session3, willRetryRead, willRetryWrite, hasReadAspect, hasWriteAspect, willRetry, _session4;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (operation instanceof operation_1.AbstractCallbackOperation) {\n            _context.next = 2;\n            break;\n          }\n          throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n        case 2:\n          if (!(client.topology == null)) {\n            _context.next = 12;\n            break;\n          }\n          if (!client.s.hasBeenClosed) {\n            _context.next = 5;\n            break;\n          }\n          throw new error_1.MongoNotConnectedError('Client must be connected before running operations');\n        case 5:\n          client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n          _context.prev = 6;\n          _context.next = 9;\n          return client.connect();\n        case 9:\n          _context.prev = 9;\n          delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n          return _context.finish(9);\n        case 12:\n          topology = client.topology;\n          if (!(topology == null)) {\n            _context.next = 15;\n            break;\n          }\n          throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');\n        case 15:\n          // The driver sessions spec mandates that we implicitly create sessions for operations\n          // that are not explicitly provided with a session.\n          session = operation.session;\n          if (!(session == null)) {\n            _context.next = 21;\n            break;\n          }\n          owner = Symbol();\n          session = client.startSession({\n            owner: owner,\n            explicit: false\n          });\n          _context.next = 27;\n          break;\n        case 21:\n          if (!session.hasEnded) {\n            _context.next = 25;\n            break;\n          }\n          throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');\n        case 25:\n          if (!(session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads)) {\n            _context.next = 27;\n            break;\n          }\n          throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n        case 27:\n          readPreference = (_operation$readPrefer = operation.readPreference) !== null && _operation$readPrefer !== void 0 ? _operation$readPrefer : read_preference_1.ReadPreference.primary;\n          inTransaction = !!((_session = session) !== null && _session !== void 0 && _session.inTransaction());\n          if (!(inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary))) {\n            _context.next = 31;\n            break;\n          }\n          throw new error_1.MongoTransactionError(\"Read preference in a transaction must be primary, not: \".concat(readPreference.mode));\n        case 31:\n          if ((_session2 = session) !== null && _session2 !== void 0 && _session2.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n            session.unpin();\n          }\n          if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {\n            // GetMore and KillCursor operations must always select the same server, but run through\n            // server selection to potentially force monitor checks if the server is\n            // in an unknown state.\n            selector = (0, server_selection_1.sameServerSelector)((_operation$server = operation.server) === null || _operation$server === void 0 ? void 0 : _operation$server.description);\n          } else if (operation.trySecondaryWrite) {\n            // If operation should try to write to secondary use the custom server selector\n            // otherwise provide the read preference.\n            selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n          } else {\n            selector = readPreference;\n          }\n          _context.next = 35;\n          return topology.selectServerAsync(selector, {\n            session: session\n          });\n        case 35:\n          server = _context.sent;\n          if (!(session == null)) {\n            _context.next = 38;\n            break;\n          }\n          return _context.abrupt(\"return\", operation.execute(server, undefined));\n        case 38:\n          if (operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n            _context.next = 48;\n            break;\n          }\n          _context.prev = 39;\n          _context.next = 42;\n          return operation.execute(server, session);\n        case 42:\n          return _context.abrupt(\"return\", _context.sent);\n        case 43:\n          _context.prev = 43;\n          if (!(((_session3 = session) === null || _session3 === void 0 ? void 0 : _session3.owner) != null && session.owner === owner)) {\n            _context.next = 47;\n            break;\n          }\n          _context.next = 47;\n          return session.endSession().catch(function () {\n            return null;\n          });\n        case 47:\n          return _context.finish(43);\n        case 48:\n          willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n          willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;\n          hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n          hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n          willRetry = hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite;\n          if (hasWriteAspect && willRetryWrite) {\n            operation.options.willRetryWrite = true;\n            session.incrementTransactionNumber();\n          }\n          _context.prev = 54;\n          _context.next = 57;\n          return operation.execute(server, session);\n        case 57:\n          return _context.abrupt(\"return\", _context.sent);\n        case 60:\n          _context.prev = 60;\n          _context.t0 = _context[\"catch\"](54);\n          if (!(willRetry && _context.t0 instanceof error_1.MongoError)) {\n            _context.next = 66;\n            break;\n          }\n          _context.next = 65;\n          return retryOperation(operation, _context.t0, {\n            session: session,\n            topology: topology,\n            selector: selector\n          });\n        case 65:\n          return _context.abrupt(\"return\", _context.sent);\n        case 66:\n          throw _context.t0;\n        case 67:\n          _context.prev = 67;\n          if (!(((_session4 = session) === null || _session4 === void 0 ? void 0 : _session4.owner) != null && session.owner === owner)) {\n            _context.next = 71;\n            break;\n          }\n          _context.next = 71;\n          return session.endSession().catch(function () {\n            return null;\n          });\n        case 71:\n          return _context.finish(67);\n        case 72:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[6,, 9, 12], [39,, 43, 48], [54, 60, 67, 72]]);\n  }));\n  return _executeOperationAsync.apply(this, arguments);\n}\nfunction retryOperation(_x3, _x4, _x5) {\n  return _retryOperation.apply(this, arguments);\n}\nfunction _retryOperation() {\n  _retryOperation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(operation, originalError, _ref) {\n    var session, topology, selector, isWriteOperation, isReadOperation, server;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          session = _ref.session, topology = _ref.topology, selector = _ref.selector;\n          isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n          isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n          if (!(isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE)) {\n            _context2.next = 5;\n            break;\n          }\n          throw new error_1.MongoServerError({\n            message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n            errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n            originalError: originalError\n          });\n        case 5:\n          if (!(isWriteOperation && !(0, error_1.isRetryableWriteError)(originalError))) {\n            _context2.next = 7;\n            break;\n          }\n          throw originalError;\n        case 7:\n          if (!(isReadOperation && !(0, error_1.isRetryableReadError)(originalError))) {\n            _context2.next = 9;\n            break;\n          }\n          throw originalError;\n        case 9:\n          if (originalError instanceof error_1.MongoNetworkError && session.isPinned && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n            // If we have a cursor and the initial command fails with a network error,\n            // we can retry it on another connection. So we need to check it back in, clear the\n            // pool for the service id, and retry again.\n            session.unpin({\n              force: true,\n              forceClear: true\n            });\n          }\n          // select a new server, and attempt to retry the operation\n          _context2.next = 12;\n          return topology.selectServerAsync(selector, {\n            session: session\n          });\n        case 12:\n          server = _context2.sent;\n          if (!(isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server))) {\n            _context2.next = 15;\n            break;\n          }\n          throw new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes');\n        case 15:\n          _context2.prev = 15;\n          _context2.next = 18;\n          return operation.execute(server, session);\n        case 18:\n          return _context2.abrupt(\"return\", _context2.sent);\n        case 21:\n          _context2.prev = 21;\n          _context2.t0 = _context2[\"catch\"](15);\n          if (!(_context2.t0 instanceof error_1.MongoError && _context2.t0.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed))) {\n            _context2.next = 25;\n            break;\n          }\n          throw originalError;\n        case 25:\n          throw _context2.t0;\n        case 26:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[15, 21]]);\n  }));\n  return _retryOperation.apply(this, arguments);\n}","map":{"version":3,"names":["error_1","require","read_preference_1","server_selection_1","utils_1","operation_1","MMAPv1_RETRY_WRITES_ERROR_CODE","MONGODB_ERROR_CODES","IllegalOperation","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","executeOperation","client","operation","callback","maybeCallback","executeOperationAsync","exports","_x","_x2","_executeOperationAsync","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_operation$readPrefer","_session","_session2","topology","session","owner","readPreference","inTransaction","selector","_operation$server","server","_session3","willRetryRead","willRetryWrite","hasReadAspect","hasWriteAspect","willRetry","_session4","wrap","_callee$","_context","prev","next","AbstractCallbackOperation","MongoRuntimeError","s","hasBeenClosed","MongoNotConnectedError","options","Symbol","for","connect","finish","startSession","explicit","hasEnded","MongoExpiredSessionError","snapshotEnabled","capabilities","supportsSnapshotReads","MongoCompatibilityError","ReadPreference","primary","equals","MongoTransactionError","concat","mode","isPinned","transaction","isCommitted","bypassPinningCheck","unpin","hasAspect","Aspect","MUST_SELECT_SAME_SERVER","sameServerSelector","description","trySecondaryWrite","secondaryWritableServerSelector","commonWireVersion","selectServerAsync","sent","abrupt","execute","undefined","RETRYABLE","endSession","catch","retryReads","canRetryRead","retryWrites","supportsRetryableWrites","canRetryWrite","READ_OPERATION","WRITE_OPERATION","incrementTransactionNumber","t0","MongoError","retryOperation","stop","_x3","_x4","_x5","_retryOperation","_callee2","originalError","_ref","isWriteOperation","isReadOperation","_callee2$","_context2","code","MongoServerError","message","errmsg","isRetryableWriteError","isRetryableReadError","MongoNetworkError","CURSOR_CREATING","force","forceClear","MongoUnexpectedServerResponseError","hasErrorLabel","MongoErrorLabel","NoWritesPerformed"],"sources":["/home/salman/Documents/GitHub/FakeShop/node_modules/mongodb/src/operations/execute_operation.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport {\n  isRetryableReadError,\n  isRetryableWriteError,\n  MongoCompatibilityError,\n  MONGODB_ERROR_CODES,\n  MongoError,\n  MongoErrorLabel,\n  MongoExpiredSessionError,\n  MongoNetworkError,\n  MongoNotConnectedError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoTransactionError,\n  MongoUnexpectedServerResponseError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { ReadPreference } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport {\n  sameServerSelector,\n  secondaryWritableServerSelector,\n  type ServerSelector\n} from '../sdam/server_selection';\nimport type { Topology } from '../sdam/topology';\nimport type { ClientSession } from '../sessions';\nimport { type Callback, maybeCallback, supportsRetryableWrites } from '../utils';\nimport { AbstractCallbackOperation, Aspect } from './operation';\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\ntype ResultTypeFromOperation<TOperation> = TOperation extends AbstractCallbackOperation<infer K>\n  ? K\n  : never;\n\n/** @internal */\nexport interface ExecutionResult {\n  /** The server selected for the operation */\n  server: Server;\n  /** The session used for this operation, may be implicitly created */\n  session?: ClientSession;\n  /** The raw server response for the operation */\n  response: Document;\n}\n\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param topology - The topology to execute this operation on\n * @param operation - The operation to execute\n * @param callback - The command result callback\n */\nexport function executeOperation<\n  T extends AbstractCallbackOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T): Promise<TResult>;\nexport function executeOperation<\n  T extends AbstractCallbackOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T, callback: Callback<TResult>): void;\nexport function executeOperation<\n  T extends AbstractCallbackOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T, callback?: Callback<TResult>): Promise<TResult> | void;\nexport function executeOperation<\n  T extends AbstractCallbackOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T, callback?: Callback<TResult>): Promise<TResult> | void {\n  return maybeCallback(() => executeOperationAsync(client, operation), callback);\n}\n\nasync function executeOperationAsync<\n  T extends AbstractCallbackOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T): Promise<TResult> {\n  if (!(operation instanceof AbstractCallbackOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  if (client.topology == null) {\n    // Auto connect on operation\n    if (client.s.hasBeenClosed) {\n      throw new MongoNotConnectedError('Client must be connected before running operations');\n    }\n    client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n    try {\n      await client.connect();\n    } finally {\n      delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n    }\n  }\n\n  const { topology } = client;\n  if (topology == null) {\n    throw new MongoRuntimeError('client.connect did not create a topology but also did not throw');\n  }\n\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session = operation.session;\n  let owner: symbol | undefined;\n\n  if (session == null) {\n    owner = Symbol();\n    session = client.startSession({ owner, explicit: false });\n  } else if (session.hasEnded) {\n    throw new MongoExpiredSessionError('Use of expired sessions is not permitted');\n  } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n    throw new MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n  }\n\n  const readPreference = operation.readPreference ?? ReadPreference.primary;\n  const inTransaction = !!session?.inTransaction();\n\n  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {\n    throw new MongoTransactionError(\n      `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n    );\n  }\n\n  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n\n  let selector: ReadPreference | ServerSelector;\n\n  if (operation.hasAspect(Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = sameServerSelector(operation.server?.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = secondaryWritableServerSelector(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n\n  const server = await topology.selectServerAsync(selector, { session });\n\n  if (session == null) {\n    // No session also means it is not retryable, early exit\n    return operation.execute(server, undefined);\n  }\n\n  if (!operation.hasAspect(Aspect.RETRYABLE)) {\n    // non-retryable operation, early exit\n    try {\n      return await operation.execute(server, session);\n    } finally {\n      if (session?.owner != null && session.owner === owner) {\n        await session.endSession().catch(() => null);\n      }\n    }\n  }\n\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n\n  const willRetryWrite =\n    topology.s.options.retryWrites &&\n    !inTransaction &&\n    supportsRetryableWrites(server) &&\n    operation.canRetryWrite;\n\n  const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n  const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);\n  const willRetry = (hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite);\n\n  if (hasWriteAspect && willRetryWrite) {\n    operation.options.willRetryWrite = true;\n    session.incrementTransactionNumber();\n  }\n\n  try {\n    return await operation.execute(server, session);\n  } catch (operationError) {\n    if (willRetry && operationError instanceof MongoError) {\n      return await retryOperation(operation, operationError, {\n        session,\n        topology,\n        selector\n      });\n    }\n    throw operationError;\n  } finally {\n    if (session?.owner != null && session.owner === owner) {\n      await session.endSession().catch(() => null);\n    }\n  }\n}\n\n/** @internal */\ntype RetryOptions = {\n  session: ClientSession;\n  topology: Topology;\n  selector: ReadPreference | ServerSelector;\n};\n\nasync function retryOperation<\n  T extends AbstractCallbackOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(\n  operation: T,\n  originalError: MongoError,\n  { session, topology, selector }: RetryOptions\n): Promise<TResult> {\n  const isWriteOperation = operation.hasAspect(Aspect.WRITE_OPERATION);\n  const isReadOperation = operation.hasAspect(Aspect.READ_OPERATION);\n\n  if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n    throw new MongoServerError({\n      message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n      errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n      originalError\n    });\n  }\n\n  if (isWriteOperation && !isRetryableWriteError(originalError)) {\n    throw originalError;\n  }\n\n  if (isReadOperation && !isRetryableReadError(originalError)) {\n    throw originalError;\n  }\n\n  if (\n    originalError instanceof MongoNetworkError &&\n    session.isPinned &&\n    !session.inTransaction() &&\n    operation.hasAspect(Aspect.CURSOR_CREATING)\n  ) {\n    // If we have a cursor and the initial command fails with a network error,\n    // we can retry it on another connection. So we need to check it back in, clear the\n    // pool for the service id, and retry again.\n    session.unpin({ force: true, forceClear: true });\n  }\n\n  // select a new server, and attempt to retry the operation\n  const server = await topology.selectServerAsync(selector, { session });\n\n  if (isWriteOperation && !supportsRetryableWrites(server)) {\n    throw new MongoUnexpectedServerResponseError(\n      'Selected server does not support retryable writes'\n    );\n  }\n\n  try {\n    return await operation.execute(server, session);\n  } catch (retryError) {\n    if (\n      retryError instanceof MongoError &&\n      retryError.hasErrorLabel(MongoErrorLabel.NoWritesPerformed)\n    ) {\n      throw originalError;\n    }\n    throw retryError;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}